(* Main for the predicate project. Process command line and
 * does the appropriate workflow in terms of calling different
 * functions from elsewhere. As, you know, main usually does. *)

open List
open Globals (* global and utility functions *)
open File_process (* file input/output *)
open Predicate (* predicate table maniuplation and predicate ranking *)
open Prune (* pruning/filtering functions *)
open Baseline


(* We can prune the predicates and counters emitted by the sampler in several
 * ways. These heuristics are set by the -filter flag. The -filter flag
 * is one integer; you give it the sum of all the filters you want.
 * 
 * filter bits:
 * 1 - elimination by universal falsehood
 * 2 - elimination by lack of failing coverage
 * 4- elimination by lack of failing example
 * 8 - elimination when increase <= 0
 * 16 - only emit predicates that are sometimes > 0 on successful runs
 *      and always 0 on failing runs
 * 32 - only emit predicates that are always > 0 on all runs
 * 64 - emit predicates that are always 0 on successful runs and 
 *      sometimes > 0 on failing runs
 * 128 - eliminate importance <= 0
 * 
 *)

let main () = begin
  let compressed = ref true in
  let rank = ref true in

  let runs_in = ref "" in

  let hashes_in = ref "" in 
  let concise_runs_in = ref [] in
  let cbi_hash_tables = ref "" in
    
  let filters = ref 0 in

  let usageMsg = "Giant Predicate Processing Program of Doom\n" in
  let argDescr = [
    "-gen-baseline", Arg.Set_string baseline_out, 
    "\t Generate information from baseline run information, print to X. \
        Doesn't print rank info.";
    "-bin", Arg.Set_string baseline_in,
    "\t file in which to find baseline information for comparison\n";
    "-uncomp", Arg.Clear compressed, 
              "\t The input files are uncompressed. false by default." ;
    "-no-rank", Arg.Clear rank,
    "\t skip ranking, just produce concise run info." ;
    "-cbi-hin", Arg.Set_string cbi_hash_tables, 
    "\t File containing serialized hash tables from my implementation \
                of CBI." ;
    "-rs", Arg.Set_string runs_in,
            "\t File listing names of files containing runs, followed by a passed \
                or failed on the same line to delineate runs." ;
    "-cout", Arg.Set_string concise_runs_out, 
            "\t File to print out concise run info.";
    "-hout", Arg.Set_string hashes_out, 
             "\t File to serialize the hash tables.";
    "-cin", Arg.String (fun s -> concise_runs_in := s:: !concise_runs_in),
            "\t File to read in concise good run info. \
	    Requires -hin flag to be set.";
    "-hin", Arg.Set_string hashes_in, 
            "\t File to read serialized hash tables from. \
	     Required if reading in concise run info.";
    "-filter", Arg.Set_int filters, 
            "\t Integer denoting which filtering schemes to apply.";
    "-mi", Arg.Set modify_input, 
            "\t Output formatted to be read into modify.";
    "-debug", Arg.Set debug, "\t Debug printouts.";
  ] 
  in
  let process = ref [] in
  let handleArg a = process := !process @ [a] in
    Arg.parse argDescr handleArg usageMsg ; 
    if not (!hashes_in = "") then begin
      let in_channel = open_in_bin !hashes_in in
	run_num_to_fname_and_good := Marshal.from_channel in_channel;
	close_in in_channel
    end ;

    if not (!cbi_hash_tables == "") then begin
      let in_channel = open_in !cbi_hash_tables in
	site_ht := Marshal.from_channel in_channel
    end;

    if not (!runs_in = "") then begin
      let file_list = ref [] in
      let fin = open_in !runs_in in 
	try
	  while true do
	    let line = input_line fin in
	    let split = Str.split whitespace_regexp line in
	      file_list := ((hd split), (hd (tl split))) :: !file_list
	  done
	with _ -> close_in fin;
	  let conciseify = 
	    if !compressed then conciseify_compressed_file 
	    else compress_and_conciseify 
	  in
	    
	List.iter (fun (file, gorb) -> conciseify file gorb) !file_list;

	(* print concise runs to concise_run_out *) 
	let out_runs_file = open_out !concise_runs_out in
	  List.iter 
	    (fun (file, _) -> print_run out_runs_file file) 
	    !file_list;
	  close_out out_runs_file;

	  (* serialize out the hashtables so we can interpret the printed data 
	   * again later *)
	  let fout = open_out_bin !hashes_out in
	    Marshal.to_channel fout (!run_num_to_fname_and_good) [];
	    close_out fout;
	    print "post hashtable print\n";
    end;        
    (* we read in any concise output generated by print_run; this is
     * less efficient then just serializing the hashtable containing
     * runs to a file, but allows for human-readable output, which
     * for now is a win *)

    if (not (empty !concise_runs_in)) then
      List.iter (fun file -> read_run file) !concise_runs_in;

    (* OK. Now, under all circumstances, we have all of our runs into the 3 
     * hash tables. Now, process predicates *)
    let pred_tbl : (int, int list list) Hashtbl.t = make_pred_tbl () in

    let filter_bit_set bit = (!filters land bit) == bit in

    let pred_pruned =
      if (filter_bit_set 2) then 
        prune_on_full_set pred_tbl filter_bit_set 
      else pred_tbl in
    let exploded_tbl = explode_preds pred_pruned in 
    let counter_pruned = prune_on_individual_counters exploded_tbl filter_bit_set in
    let increase_pruned = if (filter_bit_set 8) then 
                           prune_on_increase counter_pruned 
                          else counter_pruned 
    in    
	let importance_pruned = if (filter_bit_set 128) then 
                           prune_on_importance increase_pruned 
                          else increase_pruned 
	in
    let ranked_preds = rank_preds importance_pruned in 
    let summarize_preds = summarize_preds ranked_preds exploded_tbl in 

      if !baseline_out <> "" then begin 
	rank := false;
	output_baseline summarize_preds ranked_preds pred_tbl exploded_tbl
      end;
      if !baseline_in <> "" then begin
	rank := false;
	let nums_and_names = 
	  compare_to_baseline ranked_preds summarize_preds pred_tbl exploded_tbl
	in
	let nums,names = List.split nums_and_names in
	let counter = ref 1 in
	  List.iter
	    (fun name ->
	       Printf.printf "f%d," !counter; incr counter) names;
	  flush stdout;
	  Printf.printf "\n"; flush stdout;
	  List.iter
	    (fun num ->
	       Printf.printf "%g," num) nums;
	  flush stdout;
(*	  List.iter
	    (fun (num,name) ->
	       Printf.printf "%g," num) nums_and_names;
	  flush stdout;*)
      end;
      if !rank then output_rank ranked_preds
end ;;

main () ;;
