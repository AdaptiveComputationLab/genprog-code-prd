/*
 * Elkhound Grammar for an OCaml parser for C
 *
 * Author: CLG
 * Date: November 22, 2010
 * Based on jabs, cil's frontc, and Scott McPeak's C++ parser. 
 * I sense that this is going to suck.
 */

/* option lang_OCaml; */

context_class cParser {
public:

};

verbatim {
open Cabs
open Cabshelper
open Lexerhack

let parse_error msg : unit = 
  failwith msg

let print = print_string

let cabslu = {lineno = -10; 
	      filename = "cabs loc unknown"; 
	      byteno = -10;
              ident = 0;}

(*
** Expression building
*)
let smooth_expression lst =
  match lst with
    [] -> nd(NOTHING)
  | [expr] -> expr
  | _ -> nd(COMMA (lst))


let currentFunctionName = ref "<outside any function>"
let fst4 (one,_,_,_) = one

let announceFunctionName name =
	let (n, decl, _, _) = dn name in
  !Lexerhack.add_identifier n;
  (* Start a context that includes the parameter names and the whole body. 
   * Will pop when we finish parsing the function body *)
  !Lexerhack.push_context ();
  (* Go through all the parameter names and mark them as identifiers *)
  let rec findProto p =
  match (dn p) with	
      PROTO (d, args, _) when isJUSTBASE d -> 
        List.iter (fun sn -> 
				     let (_, namenode) = (dn sn) in 
					 let an = fst4 (dn namenode) in 
					 	 !Lexerhack.add_identifier an) args

    | PROTO (d, _, _) -> findProto d
    | PARENTYPE (_, d, _) -> findProto d
    | PTR (_, d) -> findProto d
    | ARRAY (d, _, _) -> findProto d
    | _ -> parse_error "Cannot find the prototype in a function definition";
           raise Parsing.Parse_error 

  and isJUSTBASE d = 
    match (dn d) with
      JUSTBASE -> true
    | PARENTYPE (_, d, _) -> isJUSTBASE d
    | _ -> false
  in
  findProto decl;
  currentFunctionName := n



let applyPointer (ptspecs: attribute node list list) (dt: decl_type node)  
       : decl_type node = 
  (* Outer specification first *)
  let rec loop = function
      [] -> dt
    | attrs :: rest -> nd(PTR(attrs, loop rest))
  in
  loop ptspecs

let doDeclaration (loc: cabsloc) (specs: specifier node) (nl: init_name node list) : definition node = 
  if isTypedef (dn specs) then begin
    (* Tell the lexer about the new type names *)
        List.iter (fun sn -> 
				     let (namenode,_) = (dn sn) in 
					 let an = fst4 (dn namenode) in 
					 	 !Lexerhack.add_identifier an) nl;
    nd(TYPEDEF (nd(specs, List.map (fun nde -> let (n, _) = dn nde in n) nl), loc))
  end else
    if nl = [] then
      nd(ONLYTYPEDEF (specs, loc))
    else begin
      (* Tell the lexer about the new variable names *)
        List.iter (fun sn -> 
				     let (namenode,_) = (dn sn) in 
					 let an = fst4 (dn namenode) in 
					 	 !Lexerhack.add_identifier an) nl;
      nd(DECDEF (nd(specs, nl), loc))
    end


let doFunctionDef (loc: cabsloc)
                  (lend: cabsloc)
                  (specs: specifier node) 
                  (n: name node) 
                  (b: block node) : definition node = 
  let fname = nd(specs, n) in
  nd(FUNDEF (fname, b, loc, lend))


let doOldParDecl (names: string list)
                 ((pardefs: name_group node list), (isva: bool)) 
    : single_name node list * bool =
  let findOneName (n : string) : single_name node =
    (* Search in pardefs for the definition for this parameter *)
    let rec loopGroups (lst : name_group node list) : single_name node =
	  match lst with
        [] -> nd(nd([nd(SpecType (nd(Tint)))]), nd(n, nd(JUSTBASE), [], cabslu))
      | node :: restgroups ->
	    let (specs, names) = dn node in
          let rec loopNames (names : name node list) : single_name node = 
		     match names with
              [] -> loopGroups restgroups
			| sn :: restnames ->
			   let (n',_,_,_) = dn sn in
			     if n' = n then nd(specs, sn) 
			   else loopNames restnames
          in
          loopNames names
    in
    loopGroups pardefs
  in
  let args = List.map findOneName names in
  (args, isva)

let checkConnective (s : string) : unit =
begin
  (* checking this means I could possibly have more connectives, with *)
  (* different meaning *)
  if (s <> "to") then (
    parse_error "transformer connective must be 'to'";
    raise Parsing.Parse_error
  )
  else ()
end

let int64_to_char value =
  if (compare value (Int64.of_int 255) > 0) || (compare value Int64.zero < 0) then
    begin
      let msg = Printf.sprintf "cparser:intlist_to_string: character 0x%Lx too big" value in
      parse_error msg;
      raise Parsing.Parse_error
    end
  else
    Char.chr (Int64.to_int value)

(* takes a not-nul-terminated list, and converts it to a string. *)
let rec intlist_to_string (str: int64 list):string =
  match str with
    [] -> ""  (* add nul-termination *)
  | value::rest ->
      let this_char = int64_to_char value in
      (String.make 1 this_char) ^ (intlist_to_string rest)


let fst3 (result, _, _) = result
let snd3 (_, result, _) = result
let trd3 (_, _, result) = result


(*
   transform:  __builtin_offsetof(type, member)
   into     :  (size_t) (&(type * ) 0)->member
 *)

let transformOffsetOf (speclist, dtype) member =
  let rec addPointer d = 
    let _ = match (dn d) with
    | JUSTBASE ->
	d.node <- PTR([], nd(JUSTBASE))
    | PARENTYPE (attrs1, dtype, attrs2) ->
	d.node <- PARENTYPE (attrs1, addPointer dtype, attrs2)
    | ARRAY (dtype, attrs, expr) ->
	d.node <- ARRAY (addPointer dtype, attrs, expr)
    | PTR (attrs, dtype) ->
	d.node <- PTR (attrs, addPointer dtype)
    | PROTO (dtype, names, variadic) ->
	d.node <- PROTO (addPointer dtype, names, variadic)
   in
     d
  in
  let nullType = (speclist, addPointer dtype) in
  let nullExpr = nd(CONSTANT (CONST_INT "0")) in
  let castExpr = nd(CAST (nullType, nd(SINGLE_INIT nullExpr))) in

  let rec replaceBase b = 
    let _ = 
     match (dn b) with
    | VARIABLE field ->
	b.node <- MEMBEROFPTR (castExpr, field)
    | MEMBEROF (base, field) ->
	b.node <- MEMBEROF (replaceBase base, field)
    | INDEX (base, index) ->
	b.node <- INDEX (replaceBase base, index)
    | _ ->
	parse_error "malformed offset expression in __builtin_offsetof";
        raise Parsing.Parse_error 
    in 
	   b
  in
  let memberExpr = replaceBase member in
  let addrExpr = nd(UNARY (ADDROF, memberExpr)) in
  (* slight cheat: hard-coded assumption that size_t == unsigned int *)
  let sizeofType = nd([nd(SpecType (nd(Tunsigned)))]), nd(JUSTBASE) in
  let resultExpr = CAST (sizeofType, (nd(SINGLE_INIT addrExpr))) in
  nd resultExpr
}

terminals {
 include(c.tok)

precedence {
    // high precedence
    prec  200 PREFER_REDUCE;
	left  190 IDENT;
	right 185  NAMED_TYPE;    /* We'll use this to handle redefinitions of
                              * NAMED_TYPE as variables */
	left 90 "." "->" "(" "{";
	left 85	"[";
	right 80 ")" "!" "~" "++" "--" "sizeof" "alignof" TYPEOF;
	left 75 "*" "/" "%" "const" "restrict" "volatile";
	left 70 "+" "-";
	left 65 ">>" "<<";
	left 60 ">" "<" "<=" ">=";
	left 55 "==" "!=";
	left 50 "&";
	left 45 "^";
	left 40 "|";
	left 35 "&&";
	left 30 "||";
	right 25 "?" ":";
	right 20  "=" "+=" "-=" "*=" "/=" "%=" "&=" "|=" "^=" ">>=" "<<=" ;
	left 15 ",";
	nonassoc 10 "else";
	nonassoc 5 	"if";
    prec    1 PREFER_SHIFT;
  }

}

// now: non-terminals
nonterm(Cabs.definition node list) File -> EnterScope t:Globals LeaveScope { t }

// scoping
nonterm EnterScope -> empty    precedence(PREFER_REDUCE)
{ 
  !Lexerhack.push_context()
} 

nonterm LeaveScope -> empty   
{
  !Lexerhack.pop_context ()
}


// ---------------- higher-level syntax -----------------
// the section labels that follow (like "A.3") are from the
// C++ standard document (should track down a proper reference..)

// ------ A.3 Basic Concepts ------
// translated from "file" in cparser.mly, which maps to globals


nonterm(Cabs.definition node list) Globals {
  -> empty										        { [] }
  -> g:Global gs:Globals 								{ g :: gs }
  -> SEMICOLON gs:Globals								{ gs }
}

nonterm(Cabs.definition node) Global {
  -> d:Declaration
		    { d }
  -> f:FunctionDefinition
			{ f }
  -> e:ExternDeclaration
 			{ e } 
  -> a:ASM "(" sc:StringConstant ")" ";"
            { nd (GLOBASM(fst sc, a)) } 
  -> p:Pragma
		    { p }
}

nonterm(Cabs.definition node) ExternDeclaration {
  -> "extern" s:StringConstant d:Declaration      
            { nd (LINKAGE (fst s,snd s, [d])) }
  -> "extern" s:StringConstant "{" t:Globals "}"  
            { nd (LINKAGE (fst s,snd s,t))  }
}

// ------------- identifier ambiguity -------------------
// identifiers can play two primary roles, and this is the
// source of problems parsing C and C++
// name of a type; introduced by class, struct, union, enum, typedef

// names for situations where it does not matter what its previous
// meaning may have been
nonterm(string) IdOrTypeName {
  -> n:IDENT  	      { fst n } 	       
  -> n:NAMED_TYPE     { fst n }
  -> AT_NAME "(" n:IDENT ")"         { "@name("^ fst n ^")" }
}

nonterm(unit) MaybeComma {
  -> empty	   			{ () }
  -> ","				{ () }
}

// ------ A.4 Expressions ------
nonterm(Cabs.expression node * cabsloc) PrimaryExpression {
  -> n:IDENT
            { nd (VARIABLE(fst n)),snd n } 
  -> e:Constant  
            { nd (CONSTANT(fst e)),snd e }
  -> e:ParenCommaExpression      
            { nd (PAREN (smooth_expression(fst e))), snd e }
  -> l:LBRACE b:Block "}" 
            { nd (GNU_BODY(fst3 b)), l }
  -> a:AT_EXPR "(" v:IDENT ")" 
            { nd (EXPR_PATTERN(fst v)), a }
}

nonterm(Cabs.expression node * cabsloc) PostfixExpression {
  -> e:PrimaryExpression  { e }

  // array access
  -> a:PostfixExpression e:BracketCommaExpression
            { nd (INDEX (fst a, smooth_expression e)), snd a }

  // fn call
  -> f:PostfixExpression "(" e:Arguments ")"
            { nd (CALL (fst f, e)), snd f }
  -> bu:BUILTIN_VA_ARG "(" e:Expression "," t:TypeName ")"
            { let b, d = t in
                nd (CALL (nd(VARIABLE "__builtin_va_arg"),
                                [fst e; nd(TYPE_SIZEOF (b, d))])), bu }
  -> b:BUILTIN_TYPES_COMPAT "(" t1:TypeName "," t2:TypeName ")"
            { let b1,d1 = t1 in
              let b2,d2 = t2 in
                nd (CALL (nd(VARIABLE "__builtin_types_compatible_p"),
                                [nd(TYPE_SIZEOF(b1,d1)); nd(TYPE_SIZEOF(b2,d2))])), b }
  -> b:BUILTIN_OFFSETOF "(" t:TypeName "," o:OffsetofMemberDesignator ")"
            { transformOffsetOf t o, b } 
  // field access
  -> p:PostfixExpression "."  n:IdOrTypeName 
            { nd (MEMBEROF (fst p, n)), snd p }

  // deref + field access
  -> p:PostfixExpression "->" n:IdOrTypeName
            { nd (MEMBEROFPTR (fst p, n)), snd p }

  -> p:PostfixExpression "++"
            { nd (UNARY (POSINCR, fst p)), snd p }
  -> p:PostfixExpression "--"
            { nd (UNARY (POSDECR, fst p)), snd p }
  -> "(" t:TypeName ")" l:LBRACE lst:InitializerListOpt "}"
		    { nd (CAST(t, nd (COMPOUND_INIT lst))), l }
}

nonterm(Cabs.expression node) OffsetofMemberDesignator {	/* GCC extension for __builtin_offsetof */
  -> v:IdOrTypeName
            { nd (VARIABLE (v)) } 
  -> lst:OffsetofMemberDesignator "." v:IDENT  
            { nd (MEMBEROF (lst, fst v)) }
  -> lst:OffsetofMemberDesignator c:BracketCommaExpression
   	 	    { nd (INDEX (lst, smooth_expression c)) }
}

nonterm(Cabs.expression node * cabsloc) UnaryExpression {
  -> e:PostfixExpression                 { e }
  -> p:PLUS_PLUS e:UnaryExpression       { nd (UNARY (PREINCR, fst e)), p } 
  -> m:MINUS_MINUS e:UnaryExpression     { nd (UNARY (PREDECR, fst e)), m }
  -> s:SIZEOF e:UnaryExpression          { nd (EXPR_SIZEOF(fst e)), s }
  -> s:SIZEOF "(" t:TypeName ")"         { let b, d = t in nd (TYPE_SIZEOF (b,d)), s }
  -> a:ALIGNOF u:UnaryExpression         { nd( EXPR_ALIGNOF (fst u)), a}
  -> a:ALIGNOF "(" t:TypeName ")"	     { let b, d = t in nd(TYPE_ALIGNOF (b,d)), a }
  -> p:PLUS e:CastExpression             { nd (UNARY (PLUS, fst e)), p }
  -> m:MINUS e:CastExpression            { nd (UNARY (MINUS, fst e)), m }
  -> s:STAR e:CastExpression             { nd(UNARY (MEMOF, fst e)), s }
  -> a:AND e:CastExpression              { nd(UNARY (ADDROF, fst e)), a }
  -> x:EXCLAM e:CastExpression           { nd(UNARY (NOT, fst e)), x }
  -> t:TILDE e:CastExpression            { nd(UNARY (BNOT, fst e)), t }
  -> a:AND_AND v:IDENT  			     { nd(LABELADDR (fst v)), a }

}

nonterm(Cabs.expression node * cabsloc) CastExpression {
  -> u:UnaryExpression	  { u }
  -> "(" t:TypeName ")" e:CastExpression { nd (CAST (t, nd (SINGLE_INIT (fst e)))), snd e }
}

// ++++ binary operator expression ++++
nonterm(Cabs.expression node * cabsloc) MultiplicativeExpression {
  -> e:CastExpression                                         { e } // this needs to go somewhere 
  -> left:MultiplicativeExpression "*" right:CastExpression   { nd(BINARY(MUL, fst left, fst right)), snd left }
  -> left:MultiplicativeExpression "/" right:CastExpression   { nd(BINARY(DIV, fst left, fst right)), snd left }
  -> left:MultiplicativeExpression "%" right:CastExpression   { nd(BINARY(MOD, fst left, fst right)), snd left }
}

nonterm(Cabs.expression node * cabsloc) AdditiveExpression {
  -> e:MultiplicativeExpression							        { e }
  -> left:AdditiveExpression "+" right:MultiplicativeExpression { nd(BINARY(ADD, fst left, fst right)), snd left }
  -> left:AdditiveExpression "-" right:MultiplicativeExpression { nd(BINARY(SUB, fst left, fst right)), snd left }
}

nonterm(Cabs.expression node * cabsloc) ShiftExpression {
  -> e:AdditiveExpression 		   				         { e }
  -> left:ShiftExpression "<<" right:AdditiveExpression  { nd(BINARY(SHL, fst left, fst right)), snd left }
  -> left:ShiftExpression ">>" right:AdditiveExpression  { nd(BINARY(SHR, fst left, fst right)), snd left }
}

nonterm(Cabs.expression node * cabsloc) RelationalExpression {
  -> e:ShiftExpression 		   				              { e }
  -> left:RelationalExpression "<" right:ShiftExpression  { nd(BINARY(LT, fst left, fst right)), snd left }
  -> left:RelationalExpression ">" right:ShiftExpression  { nd(BINARY(GT, fst left, fst right)), snd left }
  -> left:RelationalExpression "<=" right:ShiftExpression { nd(BINARY(LE, fst left, fst right)), snd left }
  -> left:RelationalExpression ">=" right:ShiftExpression { nd(BINARY(GE, fst left, fst right)), snd left }
}

nonterm(Cabs.expression node * cabsloc) EqualityExpression {
  -> e:RelationalExpression 		   				           { e }
  -> left:EqualityExpression "==" right:RelationalExpression   { nd(BINARY(EQ, fst left, fst right)), snd left }
  -> left:EqualityExpression "!=" right:RelationalExpression   { nd(BINARY(NE, fst left, fst right)), snd left }
}

nonterm(Cabs.expression node * cabsloc) BitwiseAndExpression {
  -> e:EqualityExpression 		   						     { e }
  -> left:BitwiseAndExpression "&" right:EqualityExpression  { nd(BINARY(BAND, fst left, fst right)), snd left }
}

nonterm(Cabs.expression node * cabsloc) BitwiseXorExpression {
  -> e:BitwiseAndExpression		   					   	      { e }
  -> left:BitwiseXorExpression "^" right:BitwiseAndExpression { nd(BINARY(XOR, fst left, fst right)), snd left }
}

nonterm(Cabs.expression node * cabsloc) BitwiseOrExpression {
  -> e:BitwiseXorExpression		   					   	      { e }
  -> left:BitwiseOrExpression "|"  right:BitwiseXorExpression   { nd(BINARY(BOR, fst left, fst right)), snd left }
}

nonterm(Cabs.expression node * cabsloc) LogicalAndExpression {
  -> e:BitwiseOrExpression		   					   	      { e }
  -> left:LogicalAndExpression "&&" right:BitwiseOrExpression  { nd(BINARY(AND, fst left, fst right)), snd left }
}

nonterm(Cabs.expression node * cabsloc) LogicalOrExpression {
  -> e:LogicalAndExpression		   					           { e }
  -> left:LogicalOrExpression "||" right:LogicalAndExpression   { nd(BINARY(OR, fst left, fst right)), snd left }
}

nonterm(Cabs.expression node * cabsloc) ConditionalExpression {
  -> e:LogicalOrExpression   { e }
  -> cond:LogicalOrExpression "?" th:ExpressionOpt ":" el:ConditionalExpression 
       { nd(QUESTION (fst cond, th, fst el)), snd cond }
}

// why is conditional not allowed on left side of = ?  can I confirm
// that in another language spec?  clearly both alternatives would have
// to be like-typed lvalues, but...

nonterm(Cabs.expression node * cabsloc) AssignmentExpression {
  -> e:ConditionalExpression  { e }
  -> e1:CastExpression "=" e2:AssignmentExpression
			{ nd(BINARY(ASSIGN, fst e1, fst e2)), snd e1}
  -> e1:CastExpression "+=" e2:AssignmentExpression
			{ nd(BINARY(ADD_ASSIGN, fst e1, fst e2)), snd e1}
  -> e1:CastExpression "-=" e2:AssignmentExpression
			{ nd(BINARY(SUB_ASSIGN, fst e1, fst e2)), snd e1}
  -> e1:CastExpression "*=" e2:AssignmentExpression
			{ nd(BINARY(MUL_ASSIGN, fst e1, fst e2)), snd e1}
  -> e1:CastExpression "/=" e2:AssignmentExpression
			{ nd(BINARY(DIV_ASSIGN, fst e1, fst e2)), snd e1}
  -> e1:CastExpression "%=" e2:AssignmentExpression
			{ nd(BINARY(MOD_ASSIGN, fst e1, fst e2)), snd e1}
  -> e1:CastExpression "&=" e2:AssignmentExpression
			{ nd(BINARY(BAND_ASSIGN, fst e1, fst e2)), snd e1}
  -> e1:CastExpression "|=" e2:AssignmentExpression
			{ nd(BINARY(BOR_ASSIGN, fst e1, fst e2)), snd e1}
  -> e1:CastExpression "^=" e2:AssignmentExpression
			{ nd(BINARY(XOR_ASSIGN, fst e1, fst e2)), snd e1}
  -> e1:CastExpression "<<=" e2:AssignmentExpression	
			{ nd(BINARY(SHL_ASSIGN, fst e1, fst e2)), snd e1}
  -> e1:CastExpression ">>=" e2:AssignmentExpression
			{ nd(BINARY(SHR_ASSIGN, fst e1, fst e2)), snd e1}
}

nonterm (Cabs.expression node * cabsloc ) Expression {
  -> ae:AssignmentExpression { ae }
}

nonterm(Cabs.constant * cabsloc) Constant {
  -> i:CST_INT    {  CONST_INT(fst i),snd i }
  -> f:CST_FLOAT  {  CONST_FLOAT(fst f),snd f }
  -> c:CST_CHAR   { CONST_CHAR(fst c),snd c }
  -> c:CST_WCHAR  { CONST_WCHAR(fst c),snd c } 
  -> sc:StringConstant {CONST_STRING(fst sc),snd sc }
  -> ws:WStringList  { CONST_WSTRING (fst ws), snd ws }
}

nonterm(string * cabsloc) StringConstant {
->   slist:StringList                         {
     let queue, location = slist in
     let buffer = Buffer.create (Queue.length queue) in
     Queue.iter
       (List.iter
	  (fun value ->
	    let char = int64_to_char value in
	    Buffer.add_char buffer char))
       queue;
     Buffer.contents buffer, location
   }
}

nonterm(string) OneStringConstant {
  -> s:CST_STRING				  { intlist_to_string(fst s) }
}

nonterm(int64 list Queue.t * cabsloc) StringList {
  -> s:OneString	   					{  let queue = Queue.create () in 
        							   Queue.add (fst s) queue;
									   queue, snd s
									}
  -> list:StringList s:OneString		{  Queue.add (fst s) (fst list); list }
}

nonterm(int64 list * cabsloc) WStringList {
  -> s:CST_WSTRING                         { s }
  -> lst:WStringList s:OneString           { (fst lst) @ (fst s), snd lst } 
  -> lst:WStringList s:CST_WSTRING         { (fst lst) @ (fst s), snd lst }
}

nonterm(int64 list * cabsloc) OneString {
  -> s:CST_STRING				{s}
  -> f:FUNCTION__                {(Cabshelper.explodeStringToInts !currentFunctionName), f}
  -> pf:PRETTY_FUNCTION__           {(Cabshelper.explodeStringToInts !currentFunctionName), pf}
}

nonterm(Cabs.init_expression node) InitExpression {
  -> e:Expression				  { nd(SINGLE_INIT(fst e)) }
  -> "{" lst:InitializerListOpt "}"  { nd(COMPOUND_INIT(lst)) } 
}

nonterm((Cabs.initwhat node * Cabs.init_expression node) list) InitializerList {
  -> i:Initializer				 { [i] }
  -> i:Initializer "," lst:InitializerListOpt		 { i :: lst }
}

nonterm((Cabs.initwhat node * Cabs.init_expression node) list) InitializerListOpt {
  -> empty			   	         { [] }
  -> lst:InitializerList		 { lst }
}

nonterm(Cabs.initwhat node * Cabs.init_expression node) Initializer {
  -> id:InitDesignators EqOpt ie:InitExpression { (id, ie) }
  /* gcc_init_designators */
  -> g:GccInitDesignators i:InitExpression  { (g,i) }
  -> ie:InitExpression { (nd(NEXT_INIT), ie) }
}

nonterm( unit ) EqOpt {
  -> "=" 	   { () }
  -> empty 	   { () }
}

nonterm(Cabs.initwhat node) InitDesignators {
  -> "." i:IdOrTypeName lst:InitDesignatorsOpt      
            { nd(INFIELD_INIT(i, lst)) }
  -> "[" e:Expression "]" lst:InitDesignatorsOpt
            { nd(ATINDEX_INIT(fst e, lst)) }
  -> "[" e1:Expression "..." e2:Expression "]"
            { nd(ATINDEXRANGE_INIT(fst e1, fst e2)) }
}

nonterm(Cabs.initwhat node) InitDesignatorsOpt {
  -> empty	   					  { nd(NEXT_INIT) }
  -> lst:InitDesignators		  { lst }
}

nonterm(Cabs.initwhat node) GccInitDesignators {
  -> v:IdOrTypeName ":"			  { nd(INFIELD_INIT(v, nd(NEXT_INIT))) }
}

nonterm(Cabs.expression node list) Arguments {
  -> empty					      { [] }
  -> c:CommaExpression			  { fst c }
}

nonterm(Cabs.expression node)  ExpressionOpt {
  -> empty				  		  { nd(NOTHING) }
  -> c:CommaExpression			  { smooth_expression (fst c) }
}

nonterm(Cabs.expression node list * cabsloc ) CommaExpression {
  -> e:Expression    { [ fst e ], snd e }
  -> e1:Expression "," e2:CommaExpression 
      { (fst e1) :: (fst e2), snd e1 }
}

nonterm(Cabs.expression node) CommaExpressionOpt {
  -> empty				 { nd(NOTHING) }
  -> ce:CommaExpression	 { smooth_expression(fst ce) }
}

nonterm(Cabs.expression node list * cabsloc) ParenCommaExpression {
  -> "(" c:CommaExpression ")"		     { c }
}
nonterm(Cabs.expression node list) BracketCommaExpression {
  -> "[" c:CommaExpression "]"		     { fst c }
}

// ------ A.5 Statements ------
// labeled-statement


nonterm(Cabs.block node * cabsloc * cabsloc) Block {
  // I must enter scope immediately upon seeing the open-brace, so
  // that if the first token of the first statement changes or queries
  // the scope, it's in the new one
  -> EnterScope lb:LBRACE labels:LocalLabels attrs:BlockAttrs seq:BlockElementList LeaveScope r:RBRACE
     { nd({ blabels = labels; battrs = attrs; bstmts=seq }), lb, r}
} 

nonterm(Cabs.attribute node list) BlockAttrs {
  -> empty			   		 { [] }
  -> BLOCKATTRIBUTE lst:ParenAttrListNE { [nd ("__blockattribute__", lst)] }
}

nonterm( Cabs.statement node list ) BlockElementList {
  -> empty 					   		    { [] }
  ->  s:Statement seq:BlockElementList   { s :: seq }
       
  -> d:Declaration seq:BlockElementList  { nd(DEFINITION(d)) :: seq }
  -> v:IDENT ":"                        { [ nd(LABEL (fst v, nd( NOP (snd v)), snd v))] }
  ->  "pragma" seq:BlockElementList      { seq }
}

nonterm(string list) LocalLabels {
  -> empty                                       { [] }
  -> LABEL__ lst:LocalLabelNames ";" lst2:LocalLabels  { lst @ lst2 }
}

nonterm(string list) LocalLabelNames {
  -> i:IDENT                                 { [ fst i ] }
  -> i:IDENT "," lst:LocalLabelNames         { fst i :: lst }
}

nonterm( Cabs.statement node) Statement {
  -> s:SEMICOLON		    { nd (NOP(s)) }
  -> ce:CommaExpression ";" { nd(COMPUTATION (smooth_expression (fst ce), (snd ce))) }
  -> s:Block    			{ nd(BLOCK(fst3 s, (snd3 s))) }
  -> f:IF e:ParenCommaExpression s:Statement     precedence(IF)
            { nd(IF ((smooth_expression (fst e)), s, nd(NOP f), f)) }

  // if-then-else preferred over if-then when ambiguous
  -> f:IF e:ParenCommaExpression s1:Statement "else" s2:Statement
            { nd(IF ((smooth_expression  (fst e)), s1, s2, f )) }
  -> sw:SWITCH e:ParenCommaExpression s:Statement
            { nd(SWITCH (smooth_expression (fst e), s, sw )) }
  -> w:WHILE e:ParenCommaExpression s:Statement
            { nd(WHILE (smooth_expression (fst e), s, w )) }
  -> d:DO s:Statement "while" e:ParenCommaExpression ";"
            { nd(DOWHILE (smooth_expression (fst e), s, d)) }
  -> f:FOR LPAREN fc:ForClause oe1:ExpressionOpt ";" oe2:ExpressionOpt RPAREN s:Statement
            { nd(FOR( fc, oe1, oe2, s, f)) }

  -> n:IDENT ":" AttributeNoCVList s:Statement 
       {(* The only attribute that should appear here
                                     is "unused". For now, we drop this on the
                                     floor, since unused labels are usually
                                     removed anyways by Rmtmps. *)
									 nd(LABEL(fst n, s, snd n)) }
  -> c:CASE e:Expression ":" s:Statement
            { nd(CASE(fst e, s, c)) }
  // gnu extension
  -> c:CASE low:Expression "..." high:Expression ":" s:Statement
            { nd(CASERANGE ( fst low, fst high, s, c )) }

  -> d:DEFAULT ":"
            { nd(DEFAULT (nd(NOP d), d)) }
  -> r:RETURN ";"
            { nd(RETURN (nd(NOTHING), r)) }
  -> r:RETURN e:CommaExpression ";"
            { nd(RETURN (smooth_expression (fst e), r )) }
  -> b:BREAK ";"
            { nd(BREAK ( b )) }
  -> c:CONTINUE ";"
            { nd(CONTINUE( c )) }
  -> g:GOTO i:IDENT ";"
            { nd(GOTO(fst i,g)) }
  -> g:GOTO "*" c:CommaExpression ";"
            { nd(COMPGOTO ( smooth_expression (fst c), g)) }

  -> a:ASM aattr:ASMAttr "(" at:ASMTemplate ao:ASMOutputs ")" ";"
            { nd(ASM (aattr, at, ao, a)) }
  -> m:MSASM
            { nd(ASM ([], [fst m], nd(None), (*handleLoc*)(snd m))) }
  -> t:TRY bc:Block "except" c1:ParenCommaExpression  b2:Block
                        { let b, _, _ = bc in
                          let h, _, _ = b2 in
 (*                         if not !Cprint.msvcMode then 
    * FIXME                            parse_error "try/except in GCC code";*) 
                          nd(TRY_EXCEPT (b, nd(COMMA (fst c1)), h, (*handleLoc*) t)) }
  -> t:TRY bc:Block "finally" bc2:Block  
                        { let b, _, _ = bc in
                          let h, _, _ = bc2 in
(*                          if not !Cprint.msvcMode then 
  FIXME                          parse_error "try/finally in GCC code";*)
                          nd(TRY_FINALLY (b, h, (*handleLoc*) t)) }

}

nonterm( Cabs.for_clause node) ForClause {
  -> e:ExpressionOpt ";" { nd(FC_EXP(e)) }
  -> s:Declaration       { nd(FC_DECL(s)) }
}

// ----- A.6 Declarations ------

nonterm(Cabs.definition node) Declaration {
  -> d:DeclSpecList lst:InitDeclaratorList ";"
                 { doDeclaration ((*handleLoc*)(snd d)) (nd(fst d)) lst } 
  -> d:DeclSpecList ";"
                 { doDeclaration ((*handleLoc*)(snd d)) (nd(fst d)) [] } 
/* (* Old-style function prototype. This should be somewhere else, like in
   * "declaration". For now we keep it at global scope only because in local
    * scope it looks too much like a function call  *) */
 ->  v:IDENT "(" old:OldParameterListNE ")" ops:OldPardefList ";"
                           { (* Convert pardecl to new style *)
                             let pardecl, isva = doOldParDecl old ops in 
                             (* Make the function declarator *)
                             doDeclaration ((*handleLoc*) (snd v)) (nd([]))
                               [(nd(nd(fst v, nd(PROTO(nd(JUSTBASE), pardecl,isva)), [], cabslu),
                                 nd(NO_INIT)))]
                            }
/* (* Old style function prototype, but without any arguments *) */
-> v:IDENT "(" ")" ";"
                           { (* Make the function declarator *)
                             doDeclaration ((*handleLoc*)(snd v)) (nd([]))
                               [(nd(nd(fst v, nd(PROTO(nd(JUSTBASE),[],false)), [], cabslu),
                                 nd(NO_INIT)))]
                            }
}

// ------ A.7 Declarators ------
// -- declarator --
// a declarator is the "x" in a declaration like "int x"

nonterm(Cabs.init_name node list) InitDeclaratorList {
  -> d:InitDeclarator  		 { [d] }
  -> d:InitDeclarator "," list:InitDeclaratorList
       						 { d :: list }
}

nonterm(Cabs.init_name node) InitDeclarator {
  -> d:Declarator
            { nd(d, nd(NO_INIT)) }
  -> d:Declarator "=" i:InitExpression     // (int)  x = 5
            { nd(d,i) }
}

nonterm(Cabs.spec_elem node list * cabsloc ) DeclSpecList {
  -> t:TYPEDEF lst:DeclSpecListOpt   { nd(SpecTypedef) :: lst, t }
  -> e:EXTERN lst:DeclSpecListOpt    { nd(SpecStorage EXTERN) :: lst, e }
  -> s:STATIC lst:DeclSpecListOpt    { nd(SpecStorage STATIC) :: lst, s }
  -> a:AUTO lst:DeclSpecListOpt      { nd(SpecStorage AUTO) :: lst, a }
  -> r:REGISTER lst:DeclSpecListOpt  { nd(SpecStorage REGISTER) :: lst, r }
  -> t:TypeSpecifier lst:DeclSpecListOptNoNamed  { nd(SpecType (fst t)) :: lst, snd t } // FIXME: "opt no_named"
  -> i:INLINE lst:DeclSpecListOpt    { nd(SpecInline) :: lst, i }
  -> c:CVSpec lst:DeclSpecListOpt    { (fst c) :: lst, snd c  }
  -> attr:AttributeNoCV lst:DeclSpecListOpt { nd(SpecAttr(fst attr)) :: lst, snd attr }
  -> a:AT_SPECIFIER "(" n:IDENT ")"    { [nd(SpecPattern(fst n))], a }
  	 					   			
}

nonterm(Cabs.spec_elem node list) DeclSpecListOpt {
-> empty 				precedence(NAMED_TYPE)
 				{ [] } 
-> lst:DeclSpecList	{ fst lst }
}
nonterm(Cabs.spec_elem node list) DeclSpecListOptNoNamed {
-> empty 				precedence(IDENT)
 				{ [] } 
-> lst:DeclSpecList	{ fst lst }
}

nonterm(Cabs.typeSpecifier node * cabsloc) TypeSpecifier {
  -> v:VOID                     { nd(Tvoid), v }
  -> c:CHAR                     { nd(Tchar), c }
  -> s:SHORT					{ nd(Tshort), s }
  -> i:INT 					    { nd(Tint), i }
  -> l:LONG                     { nd(Tlong), l }
  -> i:INT64  				    { nd(Tint64), i }
  -> f:FLOAT                    { nd(Tfloat), f }
  -> d:DOUBLE                   { nd(Tdouble), d }
  -> s:SIGNED                   { nd(Tsigned), s }
  -> u:UNSIGNED  				{ nd(Tunsigned), u }
  -> s:STRUCT                   n:IdOrTypeName    		  			 { nd(Tstruct (n, None, [])), s } 
  -> s:STRUCT ja:JustAttributes n:IdOrTypeName                       { nd(Tstruct (n, None, ja)), s } 
  -> s:STRUCT                   n:IdOrTypeName "{" memb:StructDeclList "}"
                                          	                         { nd(Tstruct (n, Some memb, [])), s }
  -> s:STRUCT                                  "{" memb:StructDeclList "}"
  	 									   	                         { nd(Tstruct ("", Some memb, [])), s }
                                                 
  -> s:STRUCT ja:JustAttributes n:IdOrTypeName "{" memb:StructDeclList "}"
                                          	                         { nd(Tstruct (n, Some memb, ja)), s }
  -> s:STRUCT ja:JustAttributes                "{" memb:StructDeclList "}"
                                          	                         { nd(Tstruct ("", Some memb, ja)), s }

  -> s:UNION                   n:IdOrTypeName     		  			 { nd(Tunion (n, None, [])), s } 
  -> s:UNION                   n:IdOrTypeName "{" memb:StructDeclList "}"
                                          	                         { nd(Tunion (n, Some memb, [])), s }
  -> s:UNION                                  "{" memb:StructDeclList "}"
  	 									   	                         { nd(Tunion ("", Some memb, [])), s }
  -> s:UNION ja:JustAttributes n:IdOrTypeName "{" memb:StructDeclList "}"
                                          	                         { nd(Tunion (n, Some memb, ja)), s }
  -> s:UNION ja:JustAttributes                "{" memb:StructDeclList "}"
                                          	                         { nd(Tunion ("", Some memb, ja)), s }
                                                 
  -> s:ENUM                     n:IdOrTypeName 		  			     { nd(Tenum (n, None, [])), s } 
  -> s:ENUM  ja:JustAttributes  n:IdOrTypeName                       { nd(Tenum (n, None, ja)), s } 
  -> s:ENUM                     n:IdOrTypeName "{" memb:EnumList MaybeComma "}"
                                          	                         { nd(Tenum (n, Some memb, [])), s }
  -> s:ENUM                               "{" memb:EnumList MaybeComma "}"
  	 									   	                         { nd(Tenum ("", Some memb, [])), s }
                                                 
  -> s:ENUM  ja:JustAttributes  n:IdOrTypeName "{" memb:EnumList MaybeComma "}"
                                          	                         { nd(Tenum (n, Some memb, ja)), s }
  -> s:ENUM  ja:JustAttributes            "{" memb:EnumList MaybeComma "}"
                                          	                         { nd(Tenum ("", Some memb, ja)), s }

  // the existence of this production is part of why parsing C is hard
  -> n:NAMED_TYPE  	  	        { nd( Tnamed(fst n)), snd n }

  -> t:TYPEOF "(" e:Expression ")"  { nd(TtypeofE (fst e)), t }
  -> t:TYPEOF "(" e:TypeName  ")"	{ let s,d = e in nd(TtypeofT (s,d)), t}
  	 			   						  
}

nonterm(Cabs.field_group node list) StructDeclList { /* (* ISO 6.7.2. Except that we allow empty structs. We 
                      * also allow missing field names. *)
                   */
  -> empty  { [] }
  -> dlist:DeclSpecList ";" slist:StructDeclList
                                         { (nd(nd(fst dlist), 
                                            [(missingFieldDecl(), None)])) :: slist }
/*(* GCC allows extra semicolons *)*/
  -> ";" lst:StructDeclList      { lst }
  -> dlist:DeclSpecList flist:FieldDeclList ";" slist:StructDeclList 
                                         { nd(nd(fst dlist), flist) :: slist }
/*(* MSVC allows pragmas in strange places *)*/
  ->"pragma" slist:StructDeclList       { slist }
}

nonterm((Cabs.name node * expression node option) list) FieldDeclList {
  -> f:FieldDecl				           { [f] }
  -> f:FieldDecl "," fs:FieldDeclList  { f :: fs }
}

nonterm(Cabs.name node * expression node option) FieldDecl { /* (* ISO 6.7.2. Except that we allow unnamed fields. *) */
  -> d:Declarator                      { (d, None) }
  -> d:Declarator ":" e:Expression a:Attributes
                                    { let (n,decl,al,loc) = dn d in
                                      let al' = al @ a in
                                     (nd(n,decl,al',loc), Some (fst e)) }    
  -> ":" e:Expression     { (missingFieldDecl(), Some (fst e)) }
}

nonterm(Cabs.enum_item node list) EnumList {  /* (* ISO 6.7.2.2 *) */
  -> e:Enumerator				{[e]}
  -> lst:EnumList "," e:Enumerator	        {lst @ [e]}
}

nonterm(Cabs.enum_item node) Enumerator {
  -> i:IDENT			{nd(fst i, nd(NOTHING), snd i)}
  -> i:IDENT "=" e:Expression		{nd(fst i, fst e, snd i)}
}

nonterm(Cabs.name node) Declarator {
  -> p:PointerOpt d:DirectDeclarator aas:AttributesWithASM
  	   { let n,decl = d in nd(n, applyPointer (fst p) decl,aas, snd p) } 
}

nonterm(string * Cabs.decl_type node) DirectDeclarator {
  -> n:IdOrTypeName       { (n, nd(JUSTBASE)) }  

  -> "(" a:Attributes d:Declarator ")"
                                  { let (n,decl,al,loc) = dn d in
                                     (n, nd(PARENTYPE(a,decl,al))) }

  -> d:DirectDeclarator "[" aas:Attributes c:CommaExpressionOpt "]"
  	 							   { let (n,decl) = d in
								     (n, nd(ARRAY(decl, aas, c))) }
  -> d:DirectDeclarator EnterScope "(" ps:ParameterDeclList LeaveScope ")"
  	 							   { let (n, decl) = d in
                                     let (params, isva) = ps in
                                     (n, nd(PROTO(decl, params, isva)))
                                   }  	 							   
}

nonterm(Cabs.single_name node list * bool) ParameterDeclList {
   -> empty	   					   { [], false }
  -> p:ParameterDecl rest:RestParList1 	   {  let (params, isva) = rest in 
                                     (p :: params, isva)  }
}

nonterm(Cabs.single_name node list * bool) RestParList1 {
   -> empty				 	  		  	   { ([], false) }
   -> "," "..."					   		   { ([], true) }
   -> "," p:ParameterDecl rst:RestParList1 {  let (params, isva) = rst in 
                                           (p :: params, isva) }
}

nonterm(Cabs.single_name node) ParameterDecl {
  -> ds:DeclSpecList d:Declarator  { nd(nd(fst ds), d) }
  -> ds:DeclSpecList ad:AbstractDeclarator 
  	 						  { let d,a = ad in
							  	nd(nd(fst ds), nd("",d,a,cabslu)) } 
  -> ds:DeclSpecList  { nd(nd(fst ds), nd("",nd(JUSTBASE), [], cabslu)) }
  -> "(" p:ParameterDecl ")" { p }   	 						  
}

/* (* Old style prototypes. Like a declarator *) */
nonterm(Cabs.name node) OldProtoDecl {
  -> p:PointerOpt ds:DirectOldProtoDecl   { let (n, decl, a) = ds in
					  					  	    nd(n, applyPointer (fst p) decl, a, snd p) 
                                          }
}

nonterm(string * Cabs.decl_type node * Cabs.attribute node list) DirectOldProtoDecl { 
  -> d:DirectDeclarator "(" lst:OldParameterListNE ")" ops:OldPardefList
                                   { let par_decl, isva = doOldParDecl lst ops in
                                     let n, decl = d in
                                     (n, nd(PROTO(decl, par_decl, isva)), [])
                                   }
  -> d:DirectDeclarator "(" ")"
                                   { let n, decl = d in
                                     (n, nd(PROTO(decl, [], false)), [])
                                   }

/* (* appears sometimesm but generates a shift-reduce conflict. *)
 | LPAREN STAR direct_decl LPAREN old_parameter_list_ne RPAREN RPAREN LPAREN RPAREN old_pardef_list
                                   { let par_decl, isva 
                                             = doOldParDecl $5 $10 in
                                     let n, decl = $3 in
                                     (n, nd(PROTO(decl, par_decl, isva)), [])
                                   }
*/
}

nonterm (string list) OldParameterListNE {
  -> v:IDENT                                       { [fst v] }
  -> v:IDENT "," lst:OldParameterListNE 
                                               {  (fst v :: lst) }
}

nonterm(Cabs.name_group node list * bool) OldPardefList { 
  -> empty  { ([], false) }
  -> ds:DeclSpecList o:OldPardef ";" "..."
                                          { ([nd(nd(fst ds), o)], true) }  
  -> ds:DeclSpecList o:OldPardef ";" lst:OldPardefList 
                                          { let rest, isva = lst in
                                            (nd(nd(fst ds), o) :: rest, isva) 
                                          }
}

nonterm(Cabs.name node list) OldPardef {
  -> d:Declarator						     { [d] }
  -> d:Declarator "," o:OldPardef            { d :: o }
}

nonterm(Cabs.attribute node list list * cabsloc) Pointer { /* (* ISO 6.7.5 *) */ 
  -> s:STAR attrs:Attributes p:PointerOpt  { attrs :: (fst p), s }
}

nonterm(Cabs.attribute node list list * cabsloc) PointerOpt {
  -> empty 	   { [], cabslu }
  -> p:Pointer  { p } 
}


nonterm(Cabs.specifier node * Cabs.decl_type node) TypeName {
 -> d1:DeclSpecList ab:AbstractDeclarator 
 								{ let d2, a = ab in
                                 if a <> [] then begin
                                   parse_error "attributes in type name";
                                   raise Parsing.Parse_error
                                 end;
                                 (nd(fst d1), d2) 
                               }
  -> d:DeclSpecList
            { (nd(fst d), nd(JUSTBASE)) }
}

// an abstract declarator (not opt) must have *some* ground syntax in it
nonterm(Cabs.decl_type node * Cabs.attribute node list) AbstractDeclarator {
  -> p:PointerOpt d:DirectAbstractDeclarator a:Attributes { applyPointer ( fst p) d, a }
  -> p:Pointer  { applyPointer (fst p) (nd(JUSTBASE)), [] }
}

// this also must have some ground syntax
nonterm(Cabs.decl_type node) DirectAbstractDeclarator {
  -> "(" attrs:Attributes a:AbstractDeclarator ")" 
                                   { let d, a2 =  a in 
                                     nd(PARENTYPE (attrs, d, a2))
                                   }

  -> d:DirectAbstractDeclaratorOpt "[" ae:CommaExpressionOpt "]" 
                                   { nd(ARRAY(d, [], ae)) }

  -> d:DirectAbstractDeclarator EnterScope "(" lst:ParameterDeclList LeaveScope ")"
  	 							   { let params,isva = lst in
								      nd(PROTO(d, params, isva)) }
}


nonterm(Cabs.decl_type node) DirectAbstractDeclaratorOpt {
  -> empty                       { nd(JUSTBASE) }
  -> d:DirectAbstractDeclarator  { d } 
}

// -- function definition --
nonterm(Cabs.definition node) FunctionDefinition {
  -> start:FunctionDefStart b:Block
          {  let (loc, specs, decl) = start in
            currentFunctionName := "<__FUNCTION__ used outside any functions>";
            !Lexerhack.pop_context (); (* The context pushed by 
                                        * announceFunctionName. Sort of a bad hack *)
            doFunctionDef ((*handleLoc*) loc) (trd3 b) specs decl (fst3 b)
          } 
}

nonterm(cabsloc * Cabs.specifier node * Cabs.name node) FunctionDefStart {
  -> ds:DeclSpecList d:Declarator
                            { announceFunctionName d;
							  (snd ds, nd(fst ds), d)
                            } 

/* (* Old-style function prototype *) */
  -> ds:DeclSpecList old:OldProtoDecl
                            { announceFunctionName old;
							 (snd ds, nd(fst ds), old) 
                            } 
/* (* New-style function that does not have a return type *) */
  -> v:IDENT EnterScope "(" lst:ParameterDeclList LeaveScope ")"
                           { 
						   let (params, isva) = lst in
                             let fdec = 
                               nd(fst v, nd(PROTO(nd(JUSTBASE), params, isva)), [], snd v) in
                             announceFunctionName fdec;
                             (* Default is int type *)
                             let defSpec = nd([(nd(SpecType (nd(Tint))))]) in
                              (snd v, defSpec, fdec)
                           }

/* (* No return type and old-style parameter list *) */
  -> v:IDENT "(" lst:OldParameterListNE ")" ops:OldPardefList
                           { (* Convert pardecl to new style *)
                             let pardecl, isva = doOldParDecl lst ops in
                             (* Make the function declarator *)
                             let fdec = nd(fst v,
                                         nd(PROTO(nd(JUSTBASE), pardecl,isva)), 
                                         [], snd v) in
                             announceFunctionName fdec;
                             (* Default is int type *)
                             let defSpec = nd([(nd(SpecType (nd(Tint))))]) in
							 (snd v, defSpec, fdec)
                            }
/* (* No return type and no parameters *) */
  -> v:IDENT "(" ")" 
                           { (* Make the function declarator *)
                             let fdec = nd(fst v,
                                         nd(PROTO(nd(JUSTBASE), [], false)), 
                                         [], snd v) in
                             announceFunctionName fdec;
                             (* Default is int type *)
                             let defSpec = nd([(nd(SpecType (nd(Tint))))]) in
							 (snd v, defSpec, fdec)
                            }
}

nonterm(Cabs.spec_elem node * cabsloc) CVSpec {
  -> c:CONST                               { nd(SpecCV(nd(CV_CONST))), c }
  -> v:VOLATILE                            { nd(SpecCV(nd(CV_VOLATILE))), v }
  -> r:RESTRICT                            { nd(SpecCV(nd(CV_RESTRICT))), r }
}

nonterm(Cabs.attribute node list) Attributes {
  -> empty			   		 	     { [] }
  -> t:Attribute lst:Attributes      { fst t :: lst }
}

nonterm(Cabs.attribute node list) AttributesWithASM {
  -> empty			   		 { [] }
  -> a:Attribute rest:AttributesWithASM { (fst a) :: rest }
  -> ASM "(" s:StringConstant ")" aas:Attributes 
                                        { nd("__asm__", 
					   [nd(CONSTANT(CONST_STRING (fst s)))]) :: aas }

}

nonterm(Cabs.attribute node * cabsloc ) AttributeNoCV {
  -> a:ATTRIBUTE ps:ParenAttrList
                                        { nd("__attribute__", ps), a }
  -> d:DECLSPEC p:ParenAttrListNE       { nd("__declspec", p), d }
  -> m:MSATTR                           { nd(fst m, []), snd m }
                                        /* ISO 6.7.3 */
  -> t:THREAD                              { nd("__thread",[]), t }
}

nonterm(Cabs.attribute node list) AttributeNoCVList {
  -> empty 	   					 { [] }
  -> a:AttributeNoCV aas:AttributeNoCVList  { fst a :: aas }
}

/* __attribute__ plus const/volatile */
nonterm (Cabs.attribute node * cabsloc) Attribute {
  -> a:AttributeNoCV 	 		   { a }
  -> c:CONST                       { nd("const", []), c }
  -> r:RESTRICT                    { nd("restrict",[]), r }
  -> v:VOLATILE                    { nd("volatile",[]), v }
}

/* (* sm: I need something that just includes __attribute__ and nothing more,
 *  to support them appearing between the 'struct' keyword and the type name. 
 * Actually, a declspec can appear there as well (on MSVC) *)  */
nonterm (Cabs.attribute node) JustAttribute {
  -> ATTRIBUTE ps:ParenAttrList
            { nd("__attribute__", ps) }
  -> DECLSPEC ps:ParenAttrListNE
            { nd("__declspec", ps) }
}

/* this can't be empty, b/c I folded that possibility into the calling
 * productions to avoid some S/R conflicts */
nonterm (Cabs.attribute node list) JustAttributes {
  -> j:JustAttribute                      { [j] }
  -> j:JustAttribute js:JustAttributes    { j :: js }
}

/** (* PRAGMAS and ATTRIBUTES *) ***/
nonterm(Cabs.definition node) Pragma {
  -> p:PRAGMA a:Attr PRAGMA_EOL		{ nd(PRAGMA (a, p)) }
  -> p:PRAGMA a:Attr ";" PRAGMA_EOL	{ nd(PRAGMA (a, p)) }
  -> p:PRAGMA_LINE                  { nd(PRAGMA (nd(VARIABLE (fst p)), snd p)) }
                                                  
}

/* (* We want to allow certain strange things that occur in pragmas, so we 
    * cannot use directly the language of expressions *) */ 
nonterm(Cabs.expression node) PrimaryAttr {
  -> v:IDENT				    { nd(VARIABLE (fst v)) }
    /*(* The NAMED_TYPE here creates conflicts with IDENT *)*/
  -> t:NAMED_TYPE				{ nd(VARIABLE (fst t)) } 
  -> "(" a:Attr ")"             { a } 
  -> a:IDENT b:IDENT            { nd(CALL(nd(VARIABLE (fst a)), [nd(VARIABLE (fst b))])) }
  -> i:CST_INT                  { nd(CONSTANT(CONST_INT (fst i))) }
  -> sc:StringConstant          { nd(CONSTANT(CONST_STRING (fst sc))) }
                                  /*(* Const when it appears in 
                                   * attribute lists, is translated 
                                   * to aconst *)*/
  -> CONST  { nd(VARIABLE "aconst") }

  -> i:IDENT ":" ci:CST_INT     
            { nd(VARIABLE (fst i ^ ":" ^ fst ci)) }

/*(* The following rule conflicts with the ? : attributes. We give it a very 
   * low priority *)*/ 
  -> ci:CST_INT ":" ci2:CST_INT 
            { nd(VARIABLE (fst ci ^ ":" ^ fst ci2)) } 

  -> DEFAULT ":" ci:CST_INT   
            { nd(VARIABLE ("default:" ^ fst ci)) }
                                /*(** GCC allows this as an 
                                 * attribute for functions, 
                                 * synonim for noreturn **)*/
  -> VOLATILE
            { nd(VARIABLE ("__noreturn__")) }
}

nonterm(Cabs.expression node) PostfixAttr { 
  -> p:PrimaryAttr				         { p }
                                         /* (* use a VARIABLE "" so that the 
                                             * parentheses are printed *) */
  -> i:IDENT "(" ")"                     { nd(CALL(nd(VARIABLE (fst i)), [nd(VARIABLE "")])) }
  -> i:IDENT ps:ParenAttrListNE 		 { nd(CALL(nd(VARIABLE (fst i)), ps)) }
  -> p:PostfixAttr "->" a:IdOrTypeName   { nd(MEMBEROFPTR (p, a)) } 
  -> p:PostfixAttr "." a:IdOrTypeName    { nd(MEMBEROF (p, a)) }  
  -> p:PostfixAttr "[" a:Attr "]"        { nd(INDEX (p, a)) }
}

/*(* Since in attributes we use both IDENT and NAMED_TYPE as indentifiers, 
 * that leads to conflicts for SIZEOF and ALIGNOF. In those cases we require 
 * that their arguments be expressions, not attributes *)*/
nonterm (Cabs.expression node) UnaryAttr {
  -> p:PostfixAttr
            { p }
  -> "sizeof" e:UnaryExpression
            {nd(EXPR_SIZEOF (fst e)) }
  -> "sizeof" "(" t:TypeName ")"
		    {let b, d = t in nd(TYPE_SIZEOF (b, d)) }
  -> "alignof" e:UnaryExpression             
            { nd(EXPR_ALIGNOF (fst e)) }
  -> "alignof" "(" t:TypeName ")"      {let b, d = t in nd(TYPE_ALIGNOF (b, d))}
  -> "+" ea:CastAttr
            { nd(UNARY (PLUS, ea)) }
  -> "-" ea:CastAttr
            { nd(UNARY (MINUS, ea)) }
  -> "*" ea:CastAttr
            { nd(UNARY (MEMOF, ea)) }
  -> "&" ea:CastAttr
            { nd(UNARY (ADDROF, ea)) }
  -> "!" ea:CastAttr
            { nd(UNARY (NOT, ea)) }
  -> "~" ea:CastAttr
            { nd(UNARY (BNOT, ea)) }
}

nonterm (Cabs.expression node) CastAttr {
  -> ca:UnaryAttr		  		   { ca }
}

nonterm (Cabs.expression node) MultiplicativeAttr {
  -> e:CastAttr			  			  { e }
  -> ua1:MultiplicativeAttr "*" ua2:CastAttr  {nd(BINARY(MUL, ua1, ua2))}
  -> ua1:MultiplicativeAttr "/" ua2:CastAttr  {nd(BINARY(DIV, ua1, ua2))}
  -> ua1:MultiplicativeAttr "%" ua2:CastAttr  {nd(BINARY(MOD, ua1, ua2))}
}

nonterm (Cabs.expression node) AdditiveAttr {
  -> c:MultiplicativeAttr 					     { c }
  -> ua1:AdditiveAttr "+" ua2:MultiplicativeAttr {nd(BINARY(ADD, ua1, ua2))} 
  -> ua1:AdditiveAttr "-" ua2:MultiplicativeAttr {nd(BINARY(SUB, ua1, ua2))}
}

nonterm (Cabs.expression node) ShiftAttr {
  -> a:AdditiveAttr						 { a }
  -> ua1:ShiftAttr "<<" ua2:AdditiveAttr {nd(BINARY(SHL, ua1, ua2))}
  -> ua1:ShiftAttr ">>" ua2:AdditiveAttr {nd(BINARY(SHR, ua1, ua2))}
}

nonterm (Cabs.expression node) RelationalAttr {
  -> a:ShiftAttr						   { a }
  -> ua1:RelationalAttr "<" ua2:ShiftAttr  {nd(BINARY(LT, ua1, ua2))}
  -> ua1:RelationalAttr ">" ua2:ShiftAttr  {nd(BINARY(GT, ua1, ua2))}
  -> ua1:RelationalAttr "<=" ua2:ShiftAttr {nd(BINARY(LE, ua1, ua2))}
  -> ua1:RelationalAttr ">=" ua2:ShiftAttr {nd(BINARY(GE, ua1, ua2))}
}

nonterm (Cabs.expression node) EqualityAttr {
  -> a:RelationalAttr						   { a }
  -> ua1:EqualityAttr "==" ua2:RelationalAttr  {nd(BINARY(EQ, ua1, ua2))}
  -> ua1:EqualityAttr "!=" ua2:RelationalAttr  {nd(BINARY(NE, ua1, ua2))}
}

nonterm (Cabs.expression node) BitwiseAndAttr {
  -> a:EqualityAttr						     { a }
  -> ua1:BitwiseAndAttr "&" ua2:EqualityAttr {nd(BINARY(BAND, ua1, ua2))}
}

nonterm (Cabs.expression node) BitwiseXorAttr {
  -> a:BitwiseAndAttr						   { a }
  -> ua1:BitwiseXorAttr "^" ua2:BitwiseAndAttr {nd(BINARY(XOR, ua1, ua2))}
}

nonterm (Cabs.expression node) BitwiseOrAttr {
  -> a:BitwiseXorAttr						  { a }
  -> ua1:BitwiseOrAttr "|" ua2:BitwiseXorAttr {nd(BINARY(BOR, ua1, ua2))}
}

nonterm (Cabs.expression node) LogicalAndAttr {
  -> a:BitwiseOrAttr						   { a }
  -> ua1:LogicalAndAttr "&&" ua2:BitwiseOrAttr {nd(BINARY(AND, ua1, ua2))}
}

nonterm (Cabs.expression node) LogicalOrAttr {
  -> a:LogicalAndAttr						   { a }
  -> ua1:LogicalOrAttr "||" ua2:LogicalAndAttr {nd(BINARY(OR, ua1, ua2))}
}

nonterm (Cabs.expression node) ConditionalAttr {
  -> a:LogicalOrAttr							{ a }
/* This is in conflict for now */
  -> ua1:LogicalOrAttr "?" ua2:ConditionalAttr ":" ua3:ConditionalAttr
                                          { nd(QUESTION(ua1, ua2, ua3)) }
}

nonterm(Cabs.expression node) Attr {
  -> u:ConditionalAttr		 	  { u }
}

nonterm(Cabs.expression node list) AttrListNE {
  -> a:Attr                                  { [a] }
  -> a:Attr "," lst:AttrListNE               { a :: lst }
}

nonterm(Cabs.expression node list) AttrList {
  -> empty
            { [] }
  -> lst:AttrListNE
            { lst }
}

nonterm(Cabs.expression node list) ParenAttrListNE {
  -> "(" lst:AttrListNE ")"               { lst }
}

nonterm(Cabs.expression node list) ParenAttrList {
  -> "(" lst:AttrList ")"               { lst }
}

/*** GCC ASM instructions ***/
nonterm(Cabs.attribute node list) ASMAttr {
  -> empty	                           { [] }
  -> VOLATILE a:ASMAttr                { nd("volatile", []) :: a }
  -> CONST a:ASMAttr                   { nd("const", []) :: a } 
}

nonterm(string list) ASMTemplate {
  -> o:OneStringConstant                          { [o] }
  -> o:OneStringConstant a:ASMTemplate            { o :: a }
}

nonterm(Cabs.asm_details option node) ASMOutputs { 
  -> empty           { nd(None) }
  -> ":" os:ASMOperands ai:ASMInputs 
                        { let (ins, clobs) = ai in
						   let n = {aoutputs = os; ainputs = ins; aclobbers = clobs} in 
                          nd(Some (n)) }
}

nonterm((string option * string * expression node) list) ASMOperands { 
  -> empty 	   			   	 { [] } 
  -> ao:ASMOperandsNE        { List.rev ao }
}

nonterm((string option * string * expression node) list) ASMOperandsNE {
  -> ao:ASMOperand                            { [ao] }
  -> lst:ASMOperandsNE "," ao:ASMOperand  { ao :: lst }
}

nonterm(string option * string * expression node) ASMOperand {
  -> name:ASMOpName sc:StringConstant "(" e:Expression ")"    { (name, fst sc, fst e) }
}

nonterm((string option * string * expression node) list * string list) ASMInputs {
  -> empty                { ([], []) }
  -> ":" ao:ASMOperands ac:ASMClobber
                        { (ao, ac) }
}

nonterm(string option) ASMOpName {
  -> empty                         { None }
  -> "[" i:IDENT "]"             { Some (fst i) }
}

nonterm(string list) ASMClobber {
  -> empty                         { [] }
  -> ":" lst:ASMCloberLstNE                 { lst }
}

nonterm(string list) ASMCloberLstNE {
  -> osc:OneStringConstant                           { [osc] }
  -> osc:OneStringConstant "," lst:ASMCloberLstNE     { osc :: lst }
}