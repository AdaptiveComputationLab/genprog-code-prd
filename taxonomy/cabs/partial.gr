// **** TODO LIST ****
// FIXME: make a blank or SP blank and blank or FP blank for pretty much 
// everything.
// FIXME: do I want to track the number of errors, or just the number of 
// terminals sucessfully munched?
// currently just doing the latter

nonterm(Cabs.statement node list * int) MiddleStatements {
  -> s1:StmtOrSPStmt e:ELSE s2:StmtOrFPStmt precedence(IF)
  	 		{ [nd(IF(nd(NOTHING), fst s1, fst s2, e))], snd s1 + snd s2 + 3 }
// the following is a hack 
  -> s1:StmtOrSPStmt RBRACE e:ELSE s2:StmtOrFPStmt precedence(IF) 
  	 		{ [nd(IF(nd(NOTHING), fst s1, fst s2, e))], snd s1 + snd s2 + 3 }
  -> bes:BlockElementList 
  	 		{ fst bes, snd bes }
  -> bes:SPBlockElementList
  	        { fst bes, snd bes }       
  -> s1:StmtOrSPStmt e:ELSE s2:StmtOrFPStmt precedence(IF)
  	 		{ [nd(IF(nd(NOTHING), fst s1, fst s2, e))], snd s1 + snd s2 + 3 }
// the following is a hack 
  -> s1:StmtOrSPStmt RBRACE e:ELSE s2:StmtOrFPStmt precedence(IF) 
  	 		{ [nd(IF(nd(NOTHING), fst s1, fst s2, e))], snd s1 + snd s2 + 3 }
  -> s1:StmtOrSPStmt RBRACE e:ELSE LBRACE s2:StmtOrFPStmt precedence(IF) 
  	 		{ [nd(IF(nd(NOTHING), fst s1, fst s2, e))], snd s1 + snd s2 + 3 }
  -> cases:MiddleSwitch 
            { fst cases, snd cases } 
  -> case:SPStatement cases:MiddleSwitch
  	        { fst case :: fst cases, snd case + snd cases }
   -> bes1:SPBlockElementList bes2:BlockElementList bes3:FPBlockElementList
      { (fst bes1 @ fst bes2 @ fst bes3), snd bes1 + snd bes2 + snd bes3 }
  -> bes1:BlockElementList bes2:FPBlockElementList 
  	        { fst bes1 @ fst bes2, snd bes1 + snd bes2 }
}

nonterm(Cabs.statement node list * int) MiddleSwitch {
   -> empty { [], 0 }
   -> s:FPStatement
			{ [fst s], snd s }
   -> c:CASE e:Expression ":" s:Statement rest:MiddleSwitch
            { nd(CASE(fst3 e, fst s, c)) :: fst rest, snd rest + trd3 e + snd s + 2 }
   -> c:CASE e:Expression ":" s:StmtOrFPStmt
            { [nd(CASE(fst3 e, fst s, c))], trd3 e + snd s + 2 }
   -> c:CASE e:Expression ":" 
            { [nd(CASE(fst3 e, nd(NOP c), c))], trd3 e + 3 }
   -> c:CASE e:ExpOrFPExp
            { [nd(CASE(fst3 e, nd(NOP c), c))], trd3 e + 5}
}

nonterm(Cabs.definition node * int) FPGlobal {
  -> e:FPExternDeclaration
 			{ e } 
  -> f:FPFunctionDefinition
			{ f }
  -> a:ASM LPAREN sc:StringConstant RPAREN
            { nd(GLOBASM(fst3 sc, a)), trd3 sc + 3 }
  -> a:ASM LPAREN sc:StringConstant
            { nd(GLOBASM(fst3 sc, a)), trd3 sc + 2 }
  -> a:ASM LPAREN
            { nd(GLOBASM("", a)), 2 }
  -> a:ASM  { nd(GLOBASM("", a)), 1 }
  -> p:FPPragma
  			{ p }

  -> d:FPDeclaration
			{ d }
}

nonterm(Cabs.definition node list * int) FPGlobals {
  -> g:FPGlobal 
            { [fst g], snd g }
  -> g:Global gs:FPGlobals
 			{ fst g :: fst gs, snd g + snd gs }
  -> ";" gs:FPGlobals
			{ gs }
}

nonterm(Cabs.definition node list * int) SPGlobals {
  -> g:SPGlobal gs:Globals
 			{ fst g :: fst gs, snd g + snd gs }
}

nonterm(Cabs.definition node * int) SPGlobal {
  -> d:SPDeclaration
			{ d }
  -> e:SPExternDeclaration
 			{ e } 
  -> f:SPFunctionDefinition
			{ f }
  -> l:LPAREN sc:StringConstant RPAREN ";"
            { nd(GLOBASM(fst3 sc, l)), trd3 sc + 3 }
  -> sc:StringConstant RPAREN ";"
            { nd(GLOBASM(fst3 sc, snd3 sc)), trd3 sc + 2 }
  -> p:SPPragma
 			{ p }
}

// ---------------- One or the Other -----------------

nonterm(Cabs.statement node * int) StmtOrFPStmt {
  -> s:Statement			   
            { fst s, snd s }
  -> sp:FPStatement	   
            { fst sp, snd sp }
}

nonterm(Cabs.statement node * int) StmtOrSPStmt {
  -> s:Statement
            { s }
  -> sp:SPStatement
            { sp }
}

nonterm(Cabs.expression node * cabsloc * int) ExpOrFPExp {
  -> e:Expression
 	 	    { e }
  -> e:FPExpression	   
            { e } 
}

nonterm(Cabs.expression node * cabsloc * int) ExpOrSPExp {
  -> e:Expression 	   { e }
  -> e:SPExpression	   { e }
}

nonterm(Cabs.expression node * int) ExpOptOrFPExpOpt {
  -> e:ExpressionOpt    { e }
  -> e:FPExpressionOpt	{ e }
}

nonterm(Cabs.expression node * int) ExpOptOrSPExpOpt {
  -> e:ExpressionOpt	{ e } 
  -> e:SPExpressionOpt	{ e } 
}

nonterm(Cabs.expression node list * cabsloc * int) CEorFPCE {
  -> ce:CommaExpression 
            { ce } 
  -> ce:FPCommaExpression
            { ce } 
}

nonterm(Cabs.expression node list * cabsloc * int) CEorSPCE {
  -> ce:CommaExpression
            { ce } 
  -> ce:SPCommaExpression
            { ce } 
}

nonterm(Cabs.expression node list * int) ArgsOrFPArgs {
  -> a:Arguments
            { a }
  -> a:FPArguments
            { a }
}

nonterm(Cabs.expression node list * int) ArgsOrSPArgs {
  -> a:Arguments
            { a } 
  -> a:SPArguments
            { a }
}

nonterm(Cabs.block * int) BlockOrFPBlock {
  -> b:Block
            { fst4 b, frth4 b }
  -> b:FPBlock  
            { fst4 b, frth4 b }
}

nonterm(Cabs.block * int) BlockOrSPBlock {
  -> b:Block
            { fst4 b, frth4 b  }
  -> b:SPBlock  
            { fst4 b, frth4 b }
}

nonterm(Cabs.specifier * Cabs.decl_type * int) TypeNameOrFPTypeName {
  -> t:TypeName
            { t } 
  -> t:FPTypeName
            { t }
}

nonterm(Cabs.specifier * Cabs.decl_type * int) TypeNameOrSPTypeName {
  -> t:TypeName
            { t } 
  -> t:SPTypeName
            { t }
}

nonterm(Cabs.expression node * int) OoMDorFPOoMD {
  -> o:OffsetofMemberDesignator
            { o } 
  -> o:FPOffsetofMemberDesignator 
            { o } 
}

nonterm(Cabs.expression node * int) OoMDorSPOoMD {
  -> o:OffsetofMemberDesignator
            { o } 
  -> o:SPOffsetofMemberDesignator 
            { o } 
}

nonterm(Cabs.for_clause * int) FCorFPFC{
  -> f:ForClause
            { f } 
  -> f:FPForClause
            { f } 
}

nonterm(Cabs.for_clause * int) FCorSPFC{
  -> f:ForClause
            { f } 
  -> f:SPForClause
            { f } 
}

nonterm(Cabs.definition node * int) FPExternDeclaration {
  -> "extern" s:StringConstant d:FPDeclaration      
            { nd(LINKAGE (fst3 s, snd3 s, [fst d])), snd d + trd3 s + 1 }
  -> "extern" s:StringConstant
            { nd(LINKAGE (fst3 s, snd3 s, [])), trd3 s + 1 }
  -> e:EXTERN
            { nd(LINKAGE ("", e, [])), 1 }
  -> e:EXTERN s:StringConstant LBRACE t:Globals
            { nd(LINKAGE ("", e, fst t)), snd t + trd3 s + 2 }
  -> "extern" s:StringConstant LBRACE t:FPGlobals
            { nd(LINKAGE (fst3 s, snd3 s, fst t)), snd t + trd3 s + 2 }
  -> "extern" s:StringConstant LBRACE 
            { nd(LINKAGE (fst3 s, snd3 s, [])), trd3 s + 2 }
}

nonterm(Cabs.definition node * int) SPExternDeclaration {
  -> s:StringConstant d:Declaration      
            { nd(LINKAGE (fst3 s, snd3 s, [(fst d)])), snd d + trd3 s}
  -> l:LBRACE t:Globals RBRACE
            { nd(LINKAGE ("", l, fst t)), snd t + 2 }
  -> t:Globals r:RBRACE
            { nd(LINKAGE ("", r, fst t)), snd t + 1 }
  -> t:SPGlobals r:RBRACE
            { nd(LINKAGE ("", r, fst t)), snd t + 1 }
}

nonterm(string * int) FPIdOrTypeName {
  -> AT_NAME LPAREN n:IDENT
            { "@name("^ fst n ^")", 3 }
  -> AT_NAME LPAREN
            { "@name("^ "" ^")", 2 }
  -> AT_NAME          
            { "@name("^ "" ^")", 1 }
}

nonterm(string * int) SPIdOrTypeName {
  -> LPAREN n:IDENT RPAREN
            { "@name("^ fst n ^")", 3 }
  -> n:IDENT RPAREN
            { "@name("^ fst n ^")", 2 }
}

nonterm(Cabs.expression node * cabsloc * int) FPPrimaryExpression {
  -> LPAREN e:CEorFPCE      
            { nd(PAREN (smooth_expression (fst3 e))), snd3 e, trd3 e + 1 }
  -> l:LPAREN  // this can be about a million things      
            { nd(PAREN (nd(NOTHING))), l, 1 }
  -> a:AT_EXPR LPAREN v:IDENT 
            { nd(EXPR_PATTERN(fst v)), a, 3 }
  -> a:AT_EXPR LPAREN
            { nd(EXPR_PATTERN("")), a, 2 }
  -> a:AT_EXPR
            { nd(EXPR_PATTERN("")), a, 1 }
}

nonterm(Cabs.expression node * cabsloc * int) SPPrimaryExpression {
  -> e:CEorSPCE RPAREN      
            { nd(PAREN (smooth_expression(fst3 e))), snd3 e, trd3 e + 1}
}

nonterm(Cabs.expression node * cabsloc * int) FPPostfixExpression {
  -> e:FPPrimaryExpression  { e }

  // array access
  -> a:PostfixExpression LBRACKET e:CEorFPCE
            { nd(INDEX (fst3 a, smooth_expression(fst3 e))), snd3 a, trd3 e + trd3 a + 1 }
  -> a:PostfixExpression LBRACKET 
            { nd(INDEX (fst3 a, nd(NOTHING))), snd3 a, trd3 a + 1 }

  // fn call
  -> f:PostfixExpression LPAREN e:ArgsOrFPArgs 
            { nd(CALL (fst3 f, fst e)), snd3 f, trd3 f + snd e + 1  }
  -> f:PostfixExpression LPAREN 
            { nd(CALL (fst3 f, [])), snd3 f, trd3 f + 1  }

  -> bu:BUILTIN_VA_ARG LPAREN e:Expression "," t:TypeName
            { let b, d, count = t in
                nd(CALL (nd(VARIABLE "__builtin_va_arg"), 
                            [(fst3 e); (nd(TYPE_SIZEOF (b, d)))])), bu, count + trd3 e + 3 }
  -> bu:BUILTIN_VA_ARG LPAREN e:Expression "," t:FPTypeName
            { let b, d, count = t in
                nd(CALL (nd(VARIABLE "__builtin_va_arg"), 
                            [(fst3 e); (nd(TYPE_SIZEOF (b, d)))])), bu, count + trd3 e + 3 }
  -> bu:BUILTIN_VA_ARG LPAREN e:Expression "," 
            { nd(CALL (nd(VARIABLE "__builtin_va_arg"), 
                         [(fst3 e)])), bu, trd3 e + 3 }
  -> bu:BUILTIN_VA_ARG LPAREN e:ExpOrFPExp
            { nd(CALL (nd(VARIABLE "__builtin_va_arg"), 
                         [(fst3 e)])), bu, trd3 e + 2 }
  -> bu:BUILTIN_VA_ARG LPAREN
            { nd(CALL (nd(VARIABLE "__builtin_va_arg"), [])), bu, 2 }
  -> b:BUILTIN_TYPES_COMPAT LPAREN t1:TypeName "," t2:TypeName
            { let b1,d1,count1 = t1 in
              let b2,d2,count2 = t2 in
                nd(CALL (nd(VARIABLE "__builtin_types_compatible_p"), 
                                [nd(TYPE_SIZEOF(b1,d1)); nd(TYPE_SIZEOF(b2,d2))])), 
								b, count1 + count2 + 3 }
  -> b:BUILTIN_TYPES_COMPAT LPAREN t1:TypeName "," t2:FPTypeName
            { let b1,d1,count1 = t1 in
              let b2,d2,count2 = t2 in
                nd(CALL (nd(VARIABLE "__builtin_types_compatible_p"), 
                                [nd(TYPE_SIZEOF(b1,d1)); nd(TYPE_SIZEOF(b2,d2))])), 
								b, count1 + count2 + 3 }
  -> b:BUILTIN_TYPES_COMPAT LPAREN t1:TypeName "," 
            { let b1,d1,count1 = t1 in
                nd(CALL (nd(VARIABLE "__builtin_types_compatible_p"), 
                                [nd(TYPE_SIZEOF(b1,d1))])), b, count1 + 3 }
  -> b:BUILTIN_TYPES_COMPAT LPAREN t1:TypeName
            { let b1,d1,count1 = t1 in
                nd(CALL (nd(VARIABLE "__builtin_types_compatible_p"), 
                                [nd(TYPE_SIZEOF(b1,d1))])), b, count1 + 2 }
  -> b:BUILTIN_TYPES_COMPAT LPAREN t1:FPTypeName 
            { let b1,d1,count1 = t1 in
                nd(CALL (nd(VARIABLE "__builtin_types_compatible_p"), 
                                [nd(TYPE_SIZEOF(b1,d1))])), b, count1 + 2 }
  -> b:BUILTIN_TYPES_COMPAT LPAREN 
            { nd(CALL (nd(VARIABLE "__builtin_types_compatible_p"), 
                                [])), b, 2 }
  -> b:BUILTIN_OFFSETOF LPAREN t:TypeName "," o:OoMDorFPOoMD
            { transformOffsetOf (pair3 t) (fst o), b, trd3 t + snd o + 3 }
  -> b:BUILTIN_OFFSETOF LPAREN t:TypeName "," 
            { transformOffsetOf (pair3 t) (nd(NOTHING)), b, trd3 t + 3 }
  -> b:BUILTIN_OFFSETOF LPAREN t:TypeNameOrFPTypeName
            { transformOffsetOf (pair3 t) (nd(NOTHING)), b, trd3 t + 2 }
  -> b:BUILTIN_OFFSETOF LPAREN 
            { transformOffsetOf ([], JUSTBASE) (nd(NOTHING)), b, 2 }
  // field access
  -> p:PostfixExpression "."  n:FPIdOrTypeName 
            { nd(MEMBEROF (fst3 p, fst n)), snd3 p, trd3 p + snd n + 2 } 
  -> p:PostfixExpression "."  
            { nd(MEMBEROF (fst3 p, "")), snd3 p, trd3 p + 2 } 

  // deref + field access
  -> p:PostfixExpression "->" n:FPIdOrTypeName
            { nd(MEMBEROFPTR (fst3 p, fst n)), snd3 p, trd3 p + snd n + 1}
  -> p:PostfixExpression "->"
            { nd(MEMBEROFPTR (fst3 p, "")), snd3 p, trd3 p + 1}
  -> LPAREN t:TypeName RPAREN l:LBRACE lst:InitializerListOpt
		    { let ses,dt,count = t in
			  nd(CAST ((ses,dt), COMPOUND_INIT (fst lst))),
               l, trd3 t + snd lst + 3 }
  -> LPAREN t:TypeName RPAREN l:LBRACE lst:FPInitializerList
		    { let ses,dt,count = t in
			  nd(CAST ((ses,dt), COMPOUND_INIT (fst lst))), 
               l, trd3 t + snd lst + 3 }
  -> LPAREN t:TypeName RPAREN l:LBRACE 
		    { let ses,dt,count = t in
			  nd(CAST ((ses,dt), NO_INIT)), l, trd3 t + 3 }
  -> l:LPAREN t:TypeName RPAREN precedence(STAR)
		    { let ses,dt,count = t in
			  nd(CAST ((ses,dt), NO_INIT)), l, trd3 t + 2 }
  -> l:LPAREN t:TypeName
		    { let ses,dt,count = t in
			  nd(CAST ((ses,dt), NO_INIT)), l, trd3 t + 1 }
  -> l:LPAREN t:FPTypeName
		    { nd(CAST (pair3 t, NO_INIT)), l, trd3 t + 1 }
}

nonterm(Cabs.expression node * cabsloc * int) SPPostfixExpression { 

  -> t:SPTypeName l:RPAREN   // BROKEN
            { let b, d,count = t in
              nd(CALL (nd(VARIABLE "__builtin_va_arg"),
                  [nd(TYPE_SIZEOF (b, d))])), l, count + 1 }
  -> t1:SPTypeName c:COMMA t2:TypeName RPAREN
            { let b1,d1, count1 = t1 in
              let b2,d2, count2 = t2 in
                nd(CALL (nd(VARIABLE "__builtin_types_compatible_p"),
                    [nd(TYPE_SIZEOF(b1,d1)); nd(TYPE_SIZEOF(b2,d2))])), c, count1 + count2 + 2 }
  -> t:TypeNameOrSPTypeName c:COMMA o:OffsetofMemberDesignator RPAREN
            { transformOffsetOf (pair3 t) (fst o), c, trd3 t + snd o + 2 }


  -> e:SPPrimaryExpression  { e }
  // array access
  -> a:SPPostfixExpression LBRACKET e:CommaExpression RBRACKET
            { nd(INDEX (fst3 a, smooth_expression (fst3 e))), snd3 a, trd3 a + trd3 e + 2 }
  -> l:LBRACKET e:CommaExpression RBRACKET
            { nd(INDEX (nd(NOTHING), smooth_expression (fst3 e))), l, trd3 e + 2 }
  -> e:CEorSPCE RBRACKET
            { nd(INDEX (nd(NOTHING), smooth_expression (fst3 e))), snd3 e, (trd3 e) + 1 }
  -> r:RBRACKET
            { nd(INDEX (nd(NOTHING), nd(NOTHING))), r, 1 }
  // fn call
  -> f:SPPostfixExpression LPAREN e:Arguments RPAREN
            { nd(CALL (fst3 f, fst e)), snd3 f, (trd3 f) + snd e + 2}
  -> l:LPAREN e:Arguments RPAREN
            { nd(CALL (nd(NOTHING), fst e)), l, snd e + 2 }
  -> e:ArgsOrSPArgs r:RPAREN
            { nd(CALL (nd(NOTHING), fst e)), r, snd e + 1 }
  -> l:LPAREN e:Expression "," t:TypeName RPAREN
            { let b, d, count = t in
              nd(CALL (nd(VARIABLE "__builtin_va_arg"),
				[(fst3 e); nd(TYPE_SIZEOF (b, d))])), l, trd3 e + count + 3 }
  -> e:ExpOrSPExp c:COMMA t:TypeName RPAREN
            { let b, d,count = t in
              nd(CALL (nd(VARIABLE "__builtin_va_arg"),
				[(fst3 e); nd(TYPE_SIZEOF (b, d))])), c, trd3 e + count + 2 }
  -> c:COMMA t:TypeName RPAREN
            { let b, d, count = t in
              nd(CALL (nd(VARIABLE "__builtin_va_arg"),
                  [nd(TYPE_SIZEOF (b, d))])), c, count + 2 }
  -> t:TypeName l:RPAREN  
            { let b, d,count = t in
              nd(CALL (nd(VARIABLE "__builtin_va_arg"),
                  [nd(TYPE_SIZEOF (b, d))])), l, count + 1 }
  -> l:LPAREN t1:TypeName "," t2:TypeName RPAREN
            { let b1,d1, count1 = t1 in
              let b2,d2, count2 = t2 in
                nd(CALL (nd(VARIABLE "__builtin_types_compatible_p"),
                    [nd(TYPE_SIZEOF(b1,d1)); nd(TYPE_SIZEOF(b2,d2))])), l, count1 + count2 + 3 }
  -> t1:TypeName c:COMMA t2:TypeName RPAREN
            { let b1,d1, count1 = t1 in
              let b2,d2, count2 = t2 in
                nd(CALL (nd(VARIABLE "__builtin_types_compatible_p"),
                    [nd(TYPE_SIZEOF(b1,d1)); nd(TYPE_SIZEOF(b2,d2))])), c, count1 + count2 + 2 }
  -> l:LPAREN t:TypeName "," o:OffsetofMemberDesignator RPAREN
            { transformOffsetOf (fst3 t, snd3 t) (fst o), l, trd3 t + snd o + 3 } 
  ->  c:COMMA o:OffsetofMemberDesignator RPAREN
            { transformOffsetOf ([],JUSTBASE) (fst o), c, snd o + 2}
  -> o:OoMDorSPOoMD r:RPAREN
            { transformOffsetOf ([],JUSTBASE) (fst o), r, snd o + 1 }

  // field access
  -> p:SPPostfixExpression "."  n:IdOrTypeName 
            { nd(MEMBEROF (fst3 p, fst n)), snd3 p, trd3 p + snd n + 1}
  -> d:DOT  n:IdOrTypeName 
            { nd(MEMBEROF (nd(NOTHING), fst n)), d, snd n + 1 }

  // deref + field access
  -> p:SPPostfixExpression "->" n:IdOrTypeName
            { nd(MEMBEROFPTR (fst3 p, fst n)), snd3 p, trd3 p + snd n + 1 }
  -> a:ARROW n:IdOrTypeName
            { nd(MEMBEROFPTR (nd(NOTHING), fst n)), a, snd n + 1 }

  -> p:SPPostfixExpression "++"
            { nd(UNARY (POSINCR, nd(NOTHING))), snd3 p, trd3 p + 1 }
  -> p:PLUS_PLUS
            { nd(UNARY (POSINCR, nd(NOTHING))), p, 1 }
  -> p:SPPostfixExpression "--"
            { nd(UNARY (POSDECR, fst3 p)), snd3 p, trd3 p + 1 }
  -> m:MINUS_MINUS
            { nd(UNARY (POSDECR, nd(NOTHING))), m, 1 }

  -> t:TypeName RPAREN l:LBRACE lst:InitializerListOpt RBRACE
		    { nd(CAST (pair3 t, COMPOUND_INIT (fst lst))), l, snd lst + trd3 t + 2 }
  -> r:RPAREN LBRACE lst:InitializerListOpt RBRACE
		    { nd(CAST (([],JUSTBASE), COMPOUND_INIT (fst lst))), r, snd lst + 2 }
  -> lst:InitializerList r:RBRACE // can't be empty, because then it's just an extraneous RBRACE
		    { nd(CAST (([],JUSTBASE), COMPOUND_INIT (fst lst))), r, snd lst + 1 }
  -> t:SPTypeName RPAREN l:LBRACE lst:InitializerListOpt RBRACE
		    { nd(CAST (pair3 t, COMPOUND_INIT (fst lst))), l, snd lst + trd3 t + 2 }
  -> lst:SPInitializerList r:RBRACE // can't be empty, because then it's just an extraneous RBRACE
		    { nd(CAST (([],JUSTBASE), COMPOUND_INIT (fst lst))), r, snd lst + 1 }

}

nonterm(Cabs.expression node * int) FPOffsetofMemberDesignator {	/* GCC extension for __builtin_offsetof */
  -> v:FPIdOrTypeName 							           
            { nd(VARIABLE (fst v)), snd v }
  -> lst:OffsetofMemberDesignator "." 
            { nd(MEMBEROF (fst lst, "")), snd lst + 1 }
  -> lst:OffsetofMemberDesignator LBRACKET c:CEorFPCE 
  			{ nd(INDEX (fst lst, smooth_expression(fst3 c))), snd lst + trd3 c + 1 }
  -> lst:OffsetofMemberDesignator LBRACKET
  			{ nd(INDEX (fst lst,nd(NOTHING))), snd lst + 1 }
}

nonterm(Cabs.expression node * int) SPOffsetofMemberDesignator {
  -> v:SPIdOrTypeName 			    
            { nd(VARIABLE(fst v)), snd v }
  -> lst:SPOffsetofMemberDesignator "." v:IDENT  
            { nd(MEMBEROF (fst lst, fst v)), snd lst + 2 }
  -> "." v:IDENT  
            { nd(MEMBEROF (nd(NOTHING), fst v)), 2 }
  -> lst:SPOffsetofMemberDesignator LBRACKET c:CommaExpression RBRACKET
            { nd(INDEX (fst lst, smooth_expression (fst3 c))), (snd lst) + (trd3 c) + 2}
}

nonterm(Cabs.expression node * cabsloc * int) FPUnaryExpression {
  -> e:FPPostfixExpression                 
            { e }
  -> p:PLUS_PLUS u:FPUnaryExpression       
            { nd(UNARY (PREINCR, fst3 u)), p, 1 + trd3 u}
  -> p:PLUS_PLUS       
            { nd(UNARY (PREINCR, nd(NOTHING))), p, 1 }
  -> m:MINUS_MINUS u:FPUnaryExpression
            { nd(UNARY (PREDECR, fst3 u)), m, 1 + trd3 u }
  -> m:MINUS_MINUS
            { nd(UNARY (PREDECR, nd(NOTHING))), m, 1  }
  -> s:SIZEOF e:FPUnaryExpression
            { nd(EXPR_SIZEOF(fst3 e)), s, trd3 e + 1 }
  -> s:SIZEOF 
            { nd(EXPR_SIZEOF(nd(NOTHING))), s, 1 }
  -> s:SIZEOF LPAREN t:TypeName
            { let b, d, count = t in nd(TYPE_SIZEOF ( b,d)), s, count + 2 }
  -> s:SIZEOF LPAREN t:FPTypeName
            { let b, d, count = t in nd(TYPE_SIZEOF (b,d)), s, count + 2 }
  -> s:SIZEOF LPAREN
            { nd(TYPE_SIZEOF ([],JUSTBASE)), s, 2 }
  -> a:ALIGNOF u:FPUnaryExpression         
            { nd(EXPR_ALIGNOF (fst3 u)), a, trd3 u + 1 }
  -> a:ALIGNOF
            { nd(EXPR_ALIGNOF (nd(NOTHING))), a, 1 }
  -> a:ALIGNOF LPAREN t:TypeName 
  	        { let b, d, count = t in nd(TYPE_ALIGNOF ( b,d)), a, count + 2 }
  -> a:ALIGNOF LPAREN t:FPTypeName 
  	        { let b, d, count = t in nd(TYPE_ALIGNOF (b,d)), a, count + 2 }
  -> a:ALIGNOF LPAREN
  	        { nd(TYPE_ALIGNOF ([],JUSTBASE)), a, 2 }
  -> p:PLUS e:FPCastExpression             
            { nd(UNARY (PLUS, fst3 e)), p, trd3 e + 1 }
  -> p:PLUS { nd(UNARY (PLUS, nd(NOTHING))), p, 1 }
  -> m:MINUS e:FPCastExpression            
            { nd(UNARY (MINUS, fst3 e)), m, trd3 e + 1 }
  -> m:MINUS { nd(UNARY (MINUS, nd(NOTHING))), m, 1 }
  -> s:STAR e:FPCastExpression             
            { nd(UNARY (MEMOF, fst3 e)), s, trd3 e + 1 }
  -> s:STAR { nd(UNARY (MEMOF, nd(NOTHING))), s, 1 }
  -> a:AND e:FPCastExpression              
            { nd(UNARY (ADDROF, fst3 e)), a, trd3 e + 1 }
  -> a:AND  { nd(UNARY (ADDROF, nd(NOTHING))), a, 1 }
  -> x:EXCLAM e:FPCastExpression           
            { nd(UNARY (NOT, (fst3 e))), x, trd3 e + 1 }
  -> x:EXCLAM { nd(UNARY (NOT, nd(NOTHING))), x, 1 }
  -> t:TILDE e:FPCastExpression            
            { nd(UNARY (BNOT, fst3 e)),t, trd3 e + 1 }
  -> t:TILDE { nd(UNARY (BNOT, nd(NOTHING))),t, 1 }
  -> a:AND_AND
	        { nd(LABELADDR ("")), a, 1 }
}

nonterm(Cabs.expression node * cabsloc * int) SPUnaryExpression {
  -> e:SPPostfixExpression                 
            { e }
}

nonterm(Cabs.expression node * cabsloc * int) FPCastExpression {
  -> u:FPUnaryExpression	  
            { u }
  -> LPAREN t:TypeName RPAREN e:FPCastExpression 
            { let ses,dt,count = t in
			  nd(CAST ( (ses,dt),SINGLE_INIT (fst3 e))),
                snd3 e, trd3 e + trd3 t + 2 }
}

nonterm(Cabs.expression node * cabsloc * int) SPCastExpression {
  -> u:SPUnaryExpression	  
            { u }

  -> t:TypeName RPAREN e:CastExpression 
            { let ses,dt,count = t in
			  nd(CAST ((ses,dt), SINGLE_INIT (fst3 e))), 
                snd3 e, trd3 t + trd3 e + 1}
  -> t:SPTypeName RPAREN e:CastExpression 
            { let ses,dt,count = t in
			  nd(CAST ((ses,dt),SINGLE_INIT (fst3 e))), 
                snd3 e, trd3 t + trd3 e + 1}
  ->  RPAREN e:CastExpression 
            { nd(CAST (([],JUSTBASE), SINGLE_INIT (fst3 e))), snd3 e, trd3 e + 1 }
}

// ++++ binary operator expression ++++
nonterm(Cabs.expression node * cabsloc * int) FPBinaryExpression {
  -> e:FPCastExpression                                   { e } 
  -> left:BinaryExpression bop:BinaryOp right:FPBinaryExpression   
            { nd(BINARY(bop, fst3 left, fst3 right)), snd3 left, trd3 left + 1 + trd3 right }
  -> left:BinaryExpression bop:BinaryOp
            { nd(BINARY(bop, fst3 left, nd(NOTHING))), snd3 left, trd3 left + 1 }
}

nonterm(Cabs.expression node * cabsloc * int) SPBinaryExpression {
  -> left:SPBinaryExpression b:BinaryOp right:BinaryExpression   
            { nd(BINARY(b, fst3 left, fst3 right)), snd3 left, trd3 left + trd3 right + 1 }
  -> b:BinaryOp right:BinaryExpression   
            { nd(BINARY(b, nd(NOTHING), fst3 right)), snd3 right, trd3 right + 1 }
  -> e:SPCastExpression
            { e }  

}

nonterm(Cabs.expression node * cabsloc * int) FPConditionalExpression {
  -> e:FPBinaryExpression	  { e }
  -> cond:BinaryExpression "?" th:ExpressionOpt ":" el:FPConditionalExpression 
       { nd(QUESTION (fst3 cond, fst th, fst3 el)), 
                snd3 cond, trd3 cond + 1 + snd th + 1 + trd3 el }
  -> cond:BinaryExpression "?" th:ExpressionOpt ":" 
       { nd(QUESTION (fst3 cond, fst th, nd(NOTHING))),
                snd3 cond, trd3 cond + 1 + snd th + 1 }
  -> cond:BinaryExpression "?" th:ExpOptOrFPExpOpt
       { nd(QUESTION (fst3 cond, fst th, nd(NOTHING))),
                snd3 cond, trd3 cond + 1 + snd th + 1 }
}

nonterm(Cabs.expression node * cabsloc * int) SPConditionalExpression {
  -> cond:SPBinaryExpression "?" th:ExpressionOpt ":" el:ConditionalExpression 
       { nd(QUESTION (fst3 cond, fst th, fst3 el)), snd3 cond,
                (trd3 cond) +  snd th + trd3 el + 2}

  -> e:SPBinaryExpression	  { e }


  ->  th:ExpOptOrSPExpOpt ":" el:ConditionalExpression
       { nd(QUESTION (nd(NOTHING), fst th, fst3 el)), snd3 el,
                snd th + trd3 el + 1 }

  ->  ":" el:ConditionalExpression  
       { nd(QUESTION (nd(NOTHING), nd(NOTHING), fst3 el)), snd3 el, trd3 el + 1 }
}

nonterm(Cabs.expression node * cabsloc * int) FPAssignmentExpression {
  -> e:FPConditionalExpression  { e }
  -> e1:UnaryExpression a:AssignmentOp e2:FPAssignmentExpression
			{nd(BINARY(a, fst3 e1, fst3 e2)), 
                snd3 e1, trd3 e1 + trd3 e2 + 1 }
  -> e1:UnaryExpression a:AssignmentOp 
			{nd(BINARY(a, fst3 e1, nd(NOTHING))),
                snd3 e1, trd3 e1 + 1 }
}

nonterm(Cabs.expression node * cabsloc * int) SPAssignmentExpression {  
  -> e1:SPUnaryExpression a:AssignmentOp e2:AssignmentExpression
			{nd(BINARY(a, fst3 e1, fst3 e2)), snd3 e1, 
                trd3 e1 + trd3 e2 + 1 }
  -> e:SPConditionalExpression  { e }
  -> a:AssignmentOp e2:AssignmentExpression
			{nd(BINARY(a, nd(NOTHING), fst3 e2)), snd3 e2, trd3 e2 + 1 }
}

nonterm (Cabs.expression node * cabsloc * int) FPExpression {
  -> ae:FPAssignmentExpression { ae }
}

nonterm(Cabs.expression node * cabsloc * int) SPExpression {
  -> ae:SPAssignmentExpression { ae }
}

nonterm(Cabs.init_expression * int) FPInitExpression {
  -> e:FPExpression				  
            { SINGLE_INIT(fst3 e), trd3 e }
  -> LBRACE lst:InitializerListOpt  
            { COMPOUND_INIT(fst lst), snd lst + 1 }
  -> LBRACE lst:FPInitializerList
            { COMPOUND_INIT(fst lst), snd lst + 1 }
}

nonterm(Cabs.init_expression * int) SPInitExpression {
  -> e:SPExpression		  
            { SINGLE_INIT(fst3 e), trd3 e }
  -> lst:InitializerListOpt RBRACE
            { COMPOUND_INIT(fst lst), snd lst + 1}  
}

nonterm((Cabs.initwhat * Cabs.init_expression) list * int) FPInitializerList {
  -> i:FPInitializer				 
            { [ pair3 i ], trd3 i }
  -> i:Initializer "," lst:FPInitializerList
		    { (pair3 i) :: (fst lst), trd3 i + snd lst + 1 }
               
}

nonterm((Cabs.initwhat * Cabs.init_expression) list * int) SPInitializerList {
  -> i:SPInitializer
            { [pair3 i ], trd3 i }
  -> i:SPInitializer  "," lst:InitializerListOpt 		 
			{ (pair3 i) :: (fst lst), snd lst + trd3 i + 1}
  ->  "," lst:InitializerListOpt
			{ fst lst, snd lst + 1 }
}

nonterm(Cabs.initwhat * Cabs.init_expression * int) FPInitializer { 
  -> id:InitDesignators e:EqOpt ie:FPInitExpression 
            { fst id, fst ie, snd id + e + snd ie }
  -> id:InitDesignators "="
            { fst id, NO_INIT, snd id + 1 }
  -> id:FPInitDesignators
  	        { fst id, NO_INIT, snd id }
  /* gcc_init_designators */
  -> g:GccInitDesignators i:FPInitExpression  
            { fst g, fst i, snd g + snd i }
  -> g:FPGccInitDesignators   
            { fst g, NO_INIT, snd g }
  -> ie:FPInitExpression 
            { NEXT_INIT, fst ie, snd ie }
}

nonterm(Cabs.initwhat * Cabs.init_expression * int) SPInitializer {
  -> id:SPInitDesignators e:EqOpt ie:InitExpression 
            { fst id, fst ie, snd id + e + snd ie}
  ->  "=" ie:InitExpression 
            { NEXT_INIT, (fst ie), snd ie + 1}
  /* gcc_init_designators */
  -> ":" i:InitExpression  
            { NEXT_INIT, (fst i), snd i + 1  }
  -> ie:SPInitExpression 
            { NEXT_INIT, fst ie, snd ie }
}

nonterm(Cabs.initwhat * int) FPInitDesignators {
  -> "." i:IdOrTypeName lst:FPInitDesignators
            { INFIELD_INIT(fst i, fst lst), snd lst + snd i + 1 }
  -> "." i:IdOrTypeName
            { INFIELD_INIT(fst i, NEXT_INIT), snd i + 1 }
  -> "." i:FPIdOrTypeName
            { INFIELD_INIT(fst i, NEXT_INIT),  snd i + 1 }
  -> "."    { INFIELD_INIT("", NEXT_INIT), 1 }
  -> LBRACKET e:Expression RBRACKET lst:FPInitDesignators
            { ATINDEX_INIT(fst3 e, fst lst), trd3 e + snd lst + 2 }
  -> LBRACKET e:Expression RBRACKET
            { ATINDEX_INIT(fst3 e, NEXT_INIT), trd3 e + 2 }
  -> LBRACKET e:ExpOrFPExp
            { ATINDEX_INIT(fst3 e, NEXT_INIT), trd3 e + 1 }
  -> LBRACKET    
            { ATINDEX_INIT(nd(NOTHING), NEXT_INIT), 1 }
  -> LBRACKET e1:Expression "..." e2:ExpOrFPExp
            { ATINDEXRANGE_INIT(fst3 e1, fst3 e2), trd3 e1 + trd3 e2 + 2 }
  -> LBRACKET e1:Expression "..." 
            { ATINDEXRANGE_INIT(fst3 e1,nd(NOTHING)), trd3 e1 + 2 }
  -> LBRACKET e1:ExpOrFPExp
            { ATINDEXRANGE_INIT(fst3 e1,nd(NOTHING)), trd3 e1 + 1 }
}

nonterm(Cabs.initwhat * int) SPInitDesignators {
  -> i:IdOrTypeName lst:InitDesignatorsOpt      
            { INFIELD_INIT(fst i, fst lst), snd lst + snd i }
  -> i:SPIdOrTypeName lst:InitDesignatorsOpt      
            { INFIELD_INIT(fst i, fst lst), snd lst + snd i }
  -> e:ExpOrSPExp RBRACKET lst:InitDesignatorsOpt
            { ATINDEX_INIT(fst3 e, fst lst), (trd3 e) + (snd lst) + 1 }
  -> RBRACKET lst:InitDesignators
            { ATINDEX_INIT(nd(NOTHING), fst lst), (snd lst) + 1}
  -> e1:ExpOrSPExp "..." e2:Expression RBRACKET
            { ATINDEXRANGE_INIT(fst3 e1, fst3 e2), 
                trd3 e1 + trd3 e2 + 1  }
  -> "..." e2:Expression RBRACKET
            { ATINDEXRANGE_INIT(nd(NOTHING), fst3 e2), trd3 e2 + 2 }
  -> e2:ExpOrSPExp RBRACKET
            { ATINDEXRANGE_INIT(nd(NOTHING), fst3 e2), trd3 e2 + 1 }
}

nonterm(Cabs.initwhat * int) FPGccInitDesignators {
  -> v:IdOrTypeName 			  
            { INFIELD_INIT(fst v, NEXT_INIT), snd v }
  -> v:FPIdOrTypeName 			  
            { INFIELD_INIT(fst v, NEXT_INIT), snd v }
}

nonterm(Cabs.expression node list * int) FPArguments {
  -> c:FPCommaExpression  	      { fst3 c, trd3 c }
}

nonterm(Cabs.expression node list * int) SPArguments {
  -> c:SPCommaExpression		  { fst3 c, trd3 c }
}

nonterm(Cabs.expression node * int)  FPExpressionOpt {
  -> c:FPCommaExpression		  
            { let e = match fst3 c with
			            [] -> nd(NOTHING)
					  | [e] -> e
					  |	_ -> nd(COMMA(fst3 c))
			   in e,trd3 c }
}

nonterm(Cabs.expression node * int)  SPExpressionOpt {
  -> c:SPCommaExpression		  
            { let e = match fst3 c with
			            [] -> nd(NOTHING)
					  | [e] -> e
					  |	_ -> nd(COMMA(fst3 c))
			   in e,trd3 c }
}

nonterm(Cabs.expression node list * cabsloc * int ) FPCommaExpression {
  -> e:FPExpression    { [ (fst3 e) ], snd3 e, trd3 e }
  -> e1:Expression "," e2:FPCommaExpression 
      { (fst3 e1) :: (fst3 e2), snd3 e1, trd3 e1 + trd3 e2 + 1 }
  -> e2:CommaExpression ","
      { fst3 e2, snd3 e2, trd3 e2 + 1 }
}

nonterm(Cabs.expression node list * cabsloc * int ) SPCommaExpression {
  -> e:SPExpression    { [ (fst3 e) ], snd3 e, trd3 e }
  -> e1:SPCommaExpression "," e2:Expression
      { (fst3 e1) @ [(fst3 e2)], snd3 e1, trd3 e1 + trd3 e2 + 1 }
  -> c:COMMA e1:Expression 
      { [(fst3 e1)], c, trd3 e1 + 1 }
}


nonterm(Cabs.block * cabsloc * cabsloc * int) FPBlock {
  // I must enter scope immediately upon seeing the open-, so
  // that if the first token of the first statement changes or queries
  // the scope, it's in the new one
  -> lb:LBRACE labels:LocalLabels attrs:BlockAttrs seq:BlockElementList 
            { { blabels = fst labels; battrs = fst attrs; bstmts=fst seq }, lb, cabslu,
                (snd labels) + (snd attrs) + (snd seq) + 1 }
  ->  lb:LBRACE labels:LocalLabels attrs:BlockAttrs seq:FPBlockElementList 
            { { blabels = fst labels; battrs = fst attrs; bstmts=fst seq }, lb, cabslu,
                (snd labels) + (snd attrs) + (snd seq) + 1 }
  ->  lb:LBRACE labels:LocalLabels attrs:BlockAttrsNE 
            { { blabels = fst labels; battrs = fst attrs; bstmts=[] }, lb, cabslu,
                (snd labels) + (snd attrs) + 1 }
  ->  lb:LBRACE labels:LocalLabels attrs:FPBlockAttrs 
            { { blabels = fst labels; battrs = fst attrs; bstmts=[] }, lb, cabslu,
                (snd labels) + (snd attrs) + 1 }
  ->  lb:LBRACE labels:LocalLabels 
            { { blabels = fst labels; battrs = []; bstmts=[] }, lb, cabslu,
                (snd labels) + 1 }
  -> lb:LBRACE labels:FPLocalLabels 
            { { blabels = fst labels; battrs = []; bstmts=[] }, lb, cabslu,
                (snd labels) + 1 }
} 

nonterm(Cabs.block * cabsloc * cabsloc * int) SPBlock {
  ->  labels:LocalLabelsNE attrs:BlockAttrs seq:BlockElementList  r:RBRACE
            { { blabels = fst labels; battrs = fst attrs; bstmts=fst seq }, cabslu, r,
                snd labels + snd attrs + snd seq + 1 }
  ->  labels:SPLocalLabels attrs:BlockAttrs seq:BlockElementList  r:RBRACE
            { { blabels = fst labels; battrs = fst attrs; bstmts=fst seq },  cabslu, r,
                snd labels + snd attrs + snd seq + 1 }
  ->  attrs:BlockAttrsNE seq:BlockElementList  r:RBRACE
            { { blabels = []; battrs = fst attrs; bstmts=fst seq }, cabslu, r, 
                snd attrs + snd seq + 1 }
  ->  seq:BlockElementList  r:RBRACE
            { { blabels = []; battrs = []; bstmts=fst seq }, cabslu, r, 
                snd seq + 1 }
  ->  seq:SPBlockElementList  r:RBRACE
            { { blabels = []; battrs = []; bstmts=fst seq }, cabslu, r, 
                snd seq + 1 }
}

nonterm(Cabs.attribute list * int) FPBlockAttrs {
  -> BLOCKATTRIBUTE LPAREN lst:AttrListNE 
            { [("__blockattribute__", fst lst)], snd lst + 2 }
  -> BLOCKATTRIBUTE LPAREN lst:FPAttrList
            { [("__blockattribute__", fst lst)], snd lst + 2 }
  -> BLOCKATTRIBUTE LPAREN  
            { [("__blockattribute__", [])], 2 }
  -> BLOCKATTRIBUTE
            { [("__blockattribute__", [])], 1 }
}

nonterm( Cabs.statement node list * int ) FPBlockElementList {
  ->  "pragma" seq:FPBlockElementList     
            { fst seq, snd seq + 1 }
  -> s:FPStatement 
            { [(fst s)], snd s }
  -> s:Statement seq:FPBlockElementList  
            { (fst s) :: (fst seq), snd s + snd seq }
  -> d:Declaration seq:FPBlockElementList 
            { nd(DEFINITION(fst d)) :: (fst seq), snd d + snd seq }
  ->  "pragma"
            {[], 1}
  -> d:FPDeclaration 
            { [nd(DEFINITION(fst d))], snd d }
  -> v:IDENT                        
            { [ nd(LABEL (fst v, nd(NOP (snd v)), snd v))], 1 }

}

nonterm( Cabs.statement node list * int ) SPBlockElementList { 
   -> s:SPStatement  seq:BlockElementList 
   	  		{ (fst s) :: (fst seq), snd s + snd seq }
  -> d:SPDeclaration seq:BlockElementList 
            { nd(DEFINITION(fst d)) :: (fst seq),  snd d + snd seq }
  -> s:SEMICOLON    
            { [ nd(LABEL("", nd(NOP(s)), cabslu))], 1 }                    
}

nonterm(string list * int) FPLocalLabels {
  -> LABEL__ lst:FPLocalLabelNames  
            { (fst lst), snd lst + 1 }
}

nonterm(string list * int) SPLocalLabels {
  -> lst:LocalLabelNames ";" lst2:LocalLabels  
            { (fst lst) @ (fst lst2), snd lst + snd lst2 + 2 }
  -> lst:SPLocalLabelNames ";" lst2:LocalLabels  
            { (fst lst) @ (fst lst2), snd lst + snd lst2 + 2 }
  -> ";" lst2:LocalLabels  
            { (fst lst2), snd lst2 + 1 }
}

nonterm(string list * int) FPLocalLabelNames {
  -> i:IDENT
             { [ fst i ], 1 }
  -> i:IDENT "," lst:LocalLabelNames
            { fst i :: (fst lst), snd lst + 2 }
  -> i:IDENT ","          
            { [fst i], 2 }
}

nonterm(string list * int) SPLocalLabelNames {
  -> "," lst:LocalLabelNames         
            { fst lst, snd lst + 2 }
}

nonterm( Cabs.statement node * int) FPStatement {
  -> ce:CEorFPCE
            { nd(COMPUTATION (smooth_expression(fst3 ce), snd3 ce)), trd3 ce + 1 }
  -> s:FPBlock    			
            { nd(BLOCK(fst4 s, snd4 s)), frth4 s }
  -> f:IF LPAREN e:CommaExpression RPAREN s:FPStatement     precedence(IF)
            { nd(IF (smooth_expression(fst3 e), fst s, nd(NOP f), f)), trd3 e + snd s + 3 }
  -> f:IF LPAREN e:CommaExpression RPAREN      precedence(IF)
            { nd(IF (smooth_expression(fst3 e), nd(NOP f), nd(NOP f), f)), trd3 e + 3 }
  -> f:IF LPAREN e:CEorFPCE      precedence(IF)
            { nd(IF (smooth_expression (fst3 e), nd(NOP f), nd(NOP f), f)), trd3 e + 2 }
  -> f:IF LPAREN      precedence(IF)
            { nd(IF (nd(NOTHING), nd(NOP f), nd(NOP f), f)), 2 }
  -> f:IF       precedence(IF)
            { nd(IF (nd(NOTHING), nd(NOP f), nd(NOP f), f)), 1 }

  // if-then-else preferred over if-then when ambiguous
  -> f:IF LPAREN e:CommaExpression RPAREN s1:Statement "else" s2:FPStatement
            { nd(IF (smooth_expression (fst3 e), fst s1, fst s2, f )), 
                trd3 e + snd s1 + snd s2 + 4 }
  -> f:IF LPAREN e:CommaExpression RPAREN s1:Statement "else" 
            { nd(IF (smooth_expression (fst3 e), fst s1, nd(NOP f), f)), 
                trd3 e + snd s1 + 4 }

  -> sw:SWITCH LPAREN e:CommaExpression RPAREN s:FPStatement
            { nd(SWITCH (smooth_expression (fst3 e), fst s, sw )), snd s + trd3 e + 3 }
  -> sw:SWITCH LPAREN e:CommaExpression RPAREN 
            { nd(SWITCH (smooth_expression (fst3 e), nd(NOP sw), sw )), trd3 e + 3 }
  -> sw:SWITCH LPAREN e:CEorFPCE
            { nd(SWITCH (smooth_expression (fst3 e), nd(NOP sw), sw )), trd3 e + 2 }
  -> sw:SWITCH LPAREN
            { nd(SWITCH (nd(NOTHING), nd(NOP sw), sw )), 2 }
  -> w:WHILE LPAREN e:CommaExpression RPAREN s:FPStatement
            { nd(WHILE (smooth_expression (fst3 e), fst s, w )), 
                trd3 e + snd s + 3 }
  -> w:WHILE LPAREN e:CommaExpression RPAREN 
            { nd(WHILE (smooth_expression (fst3 e), nd(NOP w), w )), trd3 e + 3 }
  -> w:WHILE LPAREN e:CEorFPCE
            { nd(WHILE (smooth_expression (fst3 e), nd(NOP w), w )), trd3 e + 2 }
  -> w:WHILE LPAREN
            { nd(WHILE (nd(NOTHING), nd(NOP w), w )), 2 }
  -> w:WHILE
            { nd(WHILE (nd(NOTHING), nd(NOP w), w )), 1 }
  -> d:DO s:Statement "while" LPAREN e:CommaExpression RPAREN
            { nd(DOWHILE (smooth_expression (fst3 e), fst s, d)), trd3 e + snd s + 4 }
  -> d:DO s:Statement "while" LPAREN e:CEorFPCE
            { nd(DOWHILE (smooth_expression (fst3 e), fst s, d)), trd3 e + snd s + 3 }
  -> d:DO s:Statement "while" LPAREN 
            { nd(DOWHILE (nd(NOTHING), fst s, d)), snd s + 3 }
  -> d:DO s:Statement "while"
            { nd(DOWHILE (nd(NOTHING), fst s, d)), snd s + 2 }
  -> d:DO s:StmtOrFPStmt
            { nd(DOWHILE (nd(NOTHING), fst s, d)), snd s + 1 }
  -> d:DO   { nd(DOWHILE (nd(NOTHING), nd(NOP d), d)), 1 }

  -> f:FOR LPAREN fc:ForClause oe1:ExpressionOpt ";" oe2:ExpressionOpt RPAREN s:FPStatement
            { nd(FOR(fst fc, fst oe1, fst oe2, fst s, f)), 
                snd fc + snd oe1 + snd oe2 + snd s + 4  }
  -> f:FOR LPAREN fc:ForClause oe1:ExpressionOpt ";" oe2:ExpressionOpt RPAREN 
            { nd(FOR(fst fc, fst oe1, fst oe2, nd(NOP f), f)), 
                snd fc + snd oe1 + snd oe2 + 4  }
  -> f:FOR LPAREN fc:ForClause oe1:ExpressionOpt ";" oe2:ExpOptOrFPExpOpt
            { nd(FOR(fst fc, fst oe1, fst oe2, nd(NOP f), f)), 
                snd fc + snd oe1 + snd oe2 + 3  }
  -> f:FOR LPAREN fc:ForClause oe1:ExpressionOpt ";" 
            { nd(FOR(fst fc, fst oe1, nd(NOTHING), nd(NOP f), f)), 
                snd fc + snd oe1 + 3  }
  -> f:FOR LPAREN fc:ForClause oe1:ExpOptOrFPExpOpt
            { nd(FOR(fst fc, fst oe1, nd(NOTHING), nd(NOP f), f)),
                snd fc + snd oe1 + 2  }
  -> f:FOR LPAREN fc:FCorFPFC
            { nd(FOR(fst fc, nd(NOTHING), nd(NOTHING), nd(NOP f), f)),
                snd fc + 2  }
  -> f:FOR LPAREN 
            { nd(FOR(FC_EXP(nd(NOTHING)), nd(NOTHING), nd(NOTHING), nd(NOP f), f)), 2 }
  -> f:FOR  { nd(FOR(FC_EXP(nd(NOTHING)), nd(NOTHING), nd(NOTHING), nd(NOP f), f)), 1 }

  -> n:IDENT ":" a:AttributeNoCVList s:FPStatement 
            { nd(LABEL(fst n, fst s, snd n)), 2 + snd a + snd s }
  -> n:IDENT ":" a:AttributeNoCVList 
            { nd(LABEL(fst n, nd(NOP (snd n)), snd n)), 2 + snd a }
  -> n:IDENT ":" a:FPAttributeNoCVList 
            { nd(LABEL(fst n, nd(NOP (snd n)), snd n)), 2 + snd a }
  -> c:CASE e:Expression ":" s:FPStatement
            { nd(CASE(fst3 e, fst s, c)), trd3 e + snd s + 2 }
  -> c:CASE e:Expression ":" 
            { nd(CASE(fst3 e, nd(NOP c), c)), trd3 e + 2 }
  -> c:CASE e:ExpOrFPExp
            { nd(CASE(fst3 e, nd(NOP c), c)), trd3 e + 1 }
  // gnu extension
  -> c:CASE low:Expression "..." high:Expression ":" s:FPStatement
            { nd(CASERANGE (fst3 low, fst3 high, fst s, c )), 
                trd3 low + trd3 high + snd s + 3 }
  -> c:CASE low:Expression "..." high:Expression co:COLON
            { nd(CASERANGE (fst3 low, fst3 high, nd(NOP co), c )), 
                trd3 low + trd3 high + 3 }
  -> c:CASE low:Expression "..." high:ExpOrFPExp
            { nd(CASERANGE (fst3 low, fst3 high, nd(NOP c), c )), 
                trd3 low + trd3 high + 2 }
  -> c:CASE low:Expression "..." 
            { nd(CASERANGE (fst3 low, nd(NOTHING), nd(NOP c), c )), 
                trd3 low + 2 }
  -> c:CASE { nd(CASE (nd(NOTHING), nd(NOP c), c )), 1}
  -> d:DEFAULT 	  	  	   	       
            { nd(DEFAULT(nd(NOP d), d)), 1 }
  -> r:RETURN
            { nd(RETURN (nd(NOTHING), r)), 1 }
  -> r:RETURN e:CEorFPCE
            { nd(RETURN (smooth_expression (fst3 e), r )), trd3 e + 1 }
  -> b:BREAK
            { nd(BREAK ( b )), 1 }
  -> c:CONTINUE
            { nd(CONTINUE( c )), 1 }
  -> g:GOTO i:IDENT
            { nd(GOTO(fst i,g)), 2 }
  -> g:GOTO
            { nd(GOTO("",g)), 1 }
  -> g:GOTO "*" c:CEorFPCE
			{ nd(COMPGOTO (smooth_expression (fst3 c), g)), trd3 c + 2}
  -> g:GOTO "*"
			{ nd(COMPGOTO (nd(NOTHING), g)), 2}

  -> a:ASM aattr:ASMAttr LPAREN at:ASMTemplate ao:ASMOutputs RPAREN
            { nd(ASM (fst aattr, fst at, fst ao, a)), snd aattr + snd at + snd ao + 3 }
  -> a:ASM aattr:ASMAttr LPAREN at:ASMTemplate ao:ASMOutputs
            { nd(ASM (fst aattr, fst at, fst ao, a)), snd aattr + snd at + snd ao + 2 }
  -> a:ASM aattr:ASMAttr LPAREN at:ASMTemplate ao:FPASMOutputs
            { nd(ASM (fst aattr, fst at, fst ao, a)), snd aattr + snd at + snd ao + 2 }
  -> a:ASM aattr:ASMAttr LPAREN at:ASMTemplate 
            { nd(ASM (fst aattr, fst at, None, a)), snd aattr + snd at + 2 }
  -> a:ASM aattr:ASMAttr LPAREN 
            { nd(ASM (fst aattr, [], None, a)), snd aattr + 2 }
  -> a:ASM aattr:ASMAttr
            { nd(ASM (fst aattr, [], None, a)), snd aattr + 1 }
  -> a:ASM  { nd(ASM ([], [], None, a)), 1 }
             
  -> t:TRY bc:Block "except" LPAREN c1:CommaExpression RPAREN  b2:FPBlock
            { let b, _, _, count1 = bc in
              let h, _,_,count2 = b2 in
                nd(TRY_EXCEPT (b, smooth_expression (fst3 c1), h, t)), count1 + count2 + trd3 c1 + 4 }
  -> t:TRY bc:Block "except" LPAREN c1:CommaExpression RPAREN  
            { let b, _, _, count1 = bc in
                nd(TRY_EXCEPT (b, smooth_expression (fst3 c1), empty_block, t)), count1 + trd3 c1 + 4 }
  -> t:TRY bc:Block "except" LPAREN c1:CEorFPCE
            { let b, _, _, count1 = bc in
                nd(TRY_EXCEPT (b, smooth_expression (fst3 c1), empty_block, t)), count1 + trd3 c1 + 3 }
  -> t:TRY bc:Block "except" LPAREN 
            { let b, _, _, count1 = bc in
                nd(TRY_EXCEPT (b, nd(NOTHING), empty_block, t)), count1 + 3 }
  -> t:TRY bc:Block "except"
            { let b, _, _, count1 = bc in
                nd(TRY_EXCEPT (b, nd(NOTHING), empty_block, t)), count1 + 2 }
  -> t:TRY bc:BlockOrFPBlock
            { nd(TRY_EXCEPT (fst bc, nd(NOTHING), empty_block, t)), snd bc + 1 }
  -> t:TRY 
            { nd(TRY_EXCEPT (empty_block, nd(NOTHING), empty_block, t)), 1 }
  -> t:TRY bc:Block "finally" bc2:FPBlock  
            { let b, _, _, count1 = bc in
              let h, _,_, count2 = bc2 in
                nd(TRY_FINALLY (b, h, t)), count1 + count2 + 2 }
  -> t:TRY bc:Block "finally"
            { let b, _, _, count1 = bc in
                nd(TRY_FINALLY (b, empty_block, t)), count1 + 2 }
}

nonterm(Cabs.statement node * int) SPStatement { 
  -> e:CEorSPCE r:RPAREN s:Statement
            { nd(IF(smooth_expression (fst3 e), (fst s), nd(NOP r), snd3 e)), trd3 e + snd s + 1 }

  -> e:CEorSPCE RPAREN s1:Statement "else" s2:Statement      
	        { nd(IF(smooth_expression (fst3 e), fst s1, fst s2, snd3 e)), trd3 e + snd s1 + snd s2 + 2 }

  -> e:ExpOrSPExp ":" s:Statement 
            { nd(CASE(fst3 e, fst s, snd3 e)), trd3 e + snd s + 1 }

  -> low:ExpOrSPExp "..." high:Expression ":" s:Statement
            { nd(CASERANGE(fst3 low, fst3 high, fst s, snd3 low)), 
                trd3 low + trd3 high + snd s + 2 }
// everything above this is broken

  -> fc:FCorSPFC oe1:ExpressionOpt se:SEMICOLON oe2:ExpressionOpt RPAREN s:Statement
            { nd(FOR(fst fc, fst oe1, fst oe2, fst s, se)),
                snd fc + snd oe1 + snd oe2 + snd s + 2 }
  -> oe1:ExpOptOrSPExpOpt se:SEMICOLON oe2:ExpressionOpt RPAREN s:Statement
            { nd(FOR(FC_EXP(nd(NOTHING)), fst oe1, fst oe2, fst s, se)), 
                snd oe1 + snd oe2 + snd s + 2 }
  -> oe2:SPExpressionOpt r:RPAREN s:Statement
            { nd(FOR(FC_EXP(nd(NOTHING)), nd(NOTHING), fst oe2, fst s, r)), 
                snd oe2 + snd s + 1 }
  -> lst:SPAttributeNoCVList s:Statement 
            { nd(LABEL("", fst s, cabslu)), snd s + snd lst}
  -> lst:AttributeNoCVListNE s:Statement
  	 		{ nd(LABEL("", fst s, cabslu)), snd s + snd lst}
  -> i:IDENT ";"
            { nd(GOTO(fst i, snd i)), 2 }
  -> "*" c:CommaExpression ";"
            { nd(COMPGOTO(smooth_expression (fst3 c), snd3 c)),  trd3 c + 2 }


// pasted the above
  -> l:LPAREN e:CommaExpression RPAREN s:Statement 	 precedence(IF)
            { nd(IF(smooth_expression (fst3 e), fst s, nd(NOP l), snd3 e)), trd3 e + snd s + 2} 

  -> r:RPAREN s:Statement precedence(IF)
            { nd(IF(nd(NOTHING), fst s, nd(NOP r), r)), snd s + 1 } 
  -> LPAREN e:CommaExpression RPAREN s1:Statement "else" s2:Statement  
	        { nd(IF(smooth_expression (fst3 e), fst s1, fst s2, snd3 e)), trd3 e + snd s1 + snd s2 + 2 }

  -> r:RPAREN s1:Statement "else" s2:Statement
            { nd(IF(nd(NOTHING), fst s1, fst s2, r)), snd s1 + snd s2 + 2 }
  -> e:ELSE s2:Statement
            { nd(IF(nd(NOTHING), nd(NOP e), fst s2, e)), snd s2 + 1 }

  -> s1:StmtOrSPStmt e:ELSE s2:Statement
            { nd(IF(nd(NOTHING), fst s1, fst s2, e)), snd s1 + snd s2 + 1 }
  -> s:StmtOrSPStmt "while" LPAREN e:CommaExpression RPAREN ";"
            { nd(DOWHILE(smooth_expression (fst3 e), fst s, snd3 e)),
                snd s + trd3 e + 4}
  -> w:WHILE LPAREN e:CommaExpression RPAREN ";"
            { nd(DOWHILE(smooth_expression(fst3 e), nd(NOP w), snd3 e)), trd3 e + 4}
  -> c:COLON s:Statement
            { nd(CASE(nd(NOTHING), fst s, c)), snd s + 1 }
  -> "..." high:Expression ":" s:Statement
            { nd(CASERANGE(nd(NOTHING), fst3 high, fst s, snd3 high)), trd3 high + snd s + 2 }

  -> l:LPAREN fc:ForClause oe1:ExpressionOpt ";" oe2:ExpressionOpt RPAREN s:Statement
            { nd(FOR(fst fc, fst oe1, fst oe2, fst s, l)),
                snd fc + snd oe1 + snd oe2 + snd s + 3  }
  -> se:SEMICOLON oe2:ExpressionOpt RPAREN s:Statement
            { nd(FOR(FC_EXP(nd(NOTHING)), nd(NOTHING), fst oe2, fst s, se)), 
                snd oe2 + snd s + 2 }
  -> c:COLON lst:AttributeNoCVList s:Statement 
            { nd(LABEL("", fst s, c)), snd s + 1 + snd lst}
  -> c:SPCommaExpression ";" // BROKEN
            { nd(COMPUTATION(smooth_expression(fst3 c), snd3 c)), trd3 c } 

  -> b:SPBlock
            { nd(BLOCK(fst4 b, snd4 b)), frth4 b } 
  -> at:ASMTemplate ao:ASMOutputs r:RPAREN ";"
            { nd(ASM([], fst at, fst ao, r)), snd at + snd ao + 2 }
  -> ao:ASMOutputs r:RPAREN ";"
            {  nd(ASM([], [], fst ao, r)), snd ao + 2 }
  -> ao:SPASMOutputs r:RPAREN ";"
            { nd(ASM([], [], fst ao, r)), snd ao + 2 }
  -> aattr:ASMAttr l:LPAREN at:ASMTemplate ao:ASMOutputs RPAREN ";"
            {  nd(ASM(fst aattr, fst at, fst ao, l)), snd aattr + snd at + snd ao + 3 }
  -> l:LPAREN at:ASMTemplate ao:ASMOutputs RPAREN ";"
            { nd(ASM([], fst at, fst ao, l)), snd at + snd ao + 3 }
  -> l:LPAREN e:CommaExpression RPAREN s:Statement 	 precedence(IF)
            { nd(IF(smooth_expression (fst3 e), fst s, nd(NOP l), snd3 e)), trd3 e + snd s + 2} 

  -> bc:BlockOrSPBlock "except" LPAREN c1:CommaExpression RPAREN  b2:Block
            { nd(TRY_EXCEPT(fst bc, smooth_expression (fst3 c1), fst4 b2, snd3 c1)),
                snd bc + trd3 c1 + frth4 b2 + 3 }
  -> "except" LPAREN c1:CommaExpression RPAREN  b2:Block
            { nd(TRY_EXCEPT(empty_block, smooth_expression (fst3 c1), (fst4 b2), snd3 c1)), 
			    trd3 c1 + frth4 b2 + 3 }

  -> RPAREN  b2:Block
            { nd(TRY_EXCEPT(empty_block, nd(NOTHING), fst4 b2, cabslu)), 
			    frth4 b2 + 1 }
  -> bc:BlockOrSPBlock f:FINALLY bc2:Block  
            { nd(TRY_FINALLY(fst bc, fst4 bc2, f)), snd bc + frth4 bc2 + 1 }

  -> f:FINALLY bc2:Block  
            { nd(TRY_FINALLY(empty_block, fst4 bc2, f)), frth4 bc2 + 1 }
}

nonterm( Cabs.for_clause * int) FPForClause {
// this ExpressionOpt thing is a stupid problem
  -> e:FPExpressionOpt ";" 
            { FC_EXP(fst e), snd e + 1}
  -> s:FPDeclaration
            { FC_DECL(fst s), snd s }
}

nonterm( Cabs.for_clause * int) SPForClause {
  -> e:SPExpressionOpt ";" { FC_EXP(fst e), snd e + 1}
  -> s:SPDeclaration       { FC_DECL(fst s), snd s }
}

nonterm(Cabs.definition node * int) FPDeclaration {
  -> d:DeclSpecList lst:InitDeclaratorList
            { doDeclaration (snd3 d) (fst3 d) (fst lst), trd3 d + snd lst }
  -> d:DeclSpecList lst:FPInitDeclaratorList
            { doDeclaration (snd3 d) (fst3 d) (fst lst), trd3 d + snd lst }
  -> d:FPDeclSpecList
            { doDeclaration (snd3 d) (fst3 d) [], trd3 d }
  -> v:IDENT LPAREN old:OldParameterListNE RPAREN ops:OldPardefList
            { (* Convert pardecl to new style *)
               let pardecl, isva = doOldParDecl (fst old) (pair3 ops) in 
                  (* Make the function declarator *)
                   doDeclaration (snd v) []
                               [((fst v, PROTO(JUSTBASE, pardecl,isva), [], cabslu),
                                 NO_INIT)], snd old + trd3 ops + 3
			}
  -> v:IDENT LPAREN old:OldParameterListNE RPAREN ops:FPOldPardefList
            { (* Convert pardecl to new style *)
               let pardecl, isva = doOldParDecl (fst old) (pair3 ops) in 
                  (* Make the function declarator *)
                   doDeclaration (snd v) []
                               [((fst v, PROTO(JUSTBASE, pardecl,isva), [], cabslu),
                                 NO_INIT)], snd old + trd3 ops + 3
			}
  -> v:IDENT LPAREN old:OldParameterListNE
            { (* Convert pardecl to new style *)
               let pardecl, isva = doOldParDecl (fst old) ([], false) in 
                  (* Make the function declarator *)
                   doDeclaration (snd v) []
                               [((fst v, PROTO(JUSTBASE, pardecl,isva), [], cabslu),
                                 NO_INIT)], snd old + 2
			}
  -> v:IDENT LPAREN
            { (* Make the function declarator *)
                   doDeclaration (snd v) []
                               [((fst v, PROTO(JUSTBASE, [],false), [], cabslu),
                                 NO_INIT)], 2
            }
}

nonterm(Cabs.definition node * int) SPDeclaration { 
   -> d:SPDeclSpecList lst:InitDeclaratorList s:SEMICOLON 
            { doDeclaration s (fst3 d) (fst lst), trd3 d + snd lst + 1}

   -> lst:InitDeclaratorList s:SEMICOLON 
            { doDeclaration s [] (fst lst), snd lst + 1}
  -> d:SPDeclSpecList ";"
            { doDeclaration (snd3 d) (fst3 d) [], trd3 d + 1}
  -> l:LPAREN old:OldParameterListNE RPAREN ops:OldPardefList ";" 
            { (* Convert pardecl to new style *)
               let pardecl, isva = doOldParDecl (fst old) (pair3 ops) in 
               (* Make the function declarator *)
               doDeclaration l []
                               [(("PARTIAL", PROTO(JUSTBASE, pardecl,isva), [], cabslu),
                                 NO_INIT)], snd old + trd3 ops + 3
            }
 ->  old:OldParameterListNE r:RPAREN ops:OldPardefList ";" 
            { (* Convert pardecl to new style *)
              let pardecl, isva = doOldParDecl (fst old) (pair3 ops) in 
               (* Make the function declarator *)
               doDeclaration r []
                               [(("PARTIAL", PROTO(JUSTBASE, pardecl,isva), [], cabslu),
                                 NO_INIT)], snd old + trd3 ops + 2
            }
 ->  old:SPOldParameterListNE r:RPAREN ops:OldPardefList ";" 
            { (* Convert pardecl to new style *)
              let pardecl, isva = doOldParDecl (fst old) (pair3 ops) in
              (* Make the function declarator *)
               doDeclaration r []
                               [(("PARTIAL", PROTO(JUSTBASE, pardecl,isva), [], cabslu),
                                 NO_INIT)], snd old + trd3 ops + 2
            }
 ->  r:RPAREN ops:OldPardefList ";" 
            { (* Convert pardecl to new style *)
              let pardecl, isva = doOldParDecl [] (pair3 ops) in 
                (* Make the function declarator *)
               doDeclaration r []
                               [(("PARTIAL", PROTO(JUSTBASE, pardecl,isva), [], cabslu),
                                 NO_INIT)], trd3 ops + 2
            }
 -> ops:OldPardefList s:SEMICOLON 
            { (* Convert pardecl to new style *)
              let pardecl, isva = doOldParDecl [] (pair3 ops) in 
               (* Make the function declarator *)
               doDeclaration s []
                               [(("PARTIAL", PROTO(JUSTBASE, pardecl,isva), [], cabslu),
                                 NO_INIT)], trd3 ops + 1
            }
  -> ops:SPOldPardefList s:SEMICOLON // This one is BROKEN
            { (* Convert pardecl to new style *)
              let pardecl, isva = doOldParDecl [] (pair3 ops) in 
               (* Make the function declarator *)
               doDeclaration s []
                               [(("PARTIAL", PROTO(JUSTBASE, pardecl,isva), [], cabslu),
                                 NO_INIT)], trd3 ops + 1
			}

}

nonterm(Cabs.init_name list * int) FPInitDeclaratorList {
  -> d:FPInitDeclarator
  		    { [(fst d)], snd d }
  -> d:InitDeclarator "," lst:FPInitDeclaratorList
       		{ (fst d) :: (fst lst), snd d + snd lst + 1 }
  -> d:InitDeclarator "," 
       		{ [(fst d)], snd d + 1 }
}

nonterm(Cabs.init_name list * int) SPInitDeclaratorList {
  -> d:SPInitDeclarator  		 
            { [(fst d)], snd d }
  -> d:SPInitDeclarator "," lst:InitDeclaratorList
       		{ (fst d) :: (fst lst), snd d + snd lst + 1 }
  -> "," lst:InitDeclaratorList
       		{ fst lst, snd lst + 1 }
}

nonterm(Cabs.init_name * int) FPInitDeclarator {
  -> d:FPDeclarator
            { (fst d, NO_INIT), snd d }
  -> d:Declarator "=" i:FPInitExpression     // (int)  x = 5
  	 		{ (fst d, fst i), snd d + snd i + 1 }
  -> d:Declarator "=" 
  	 	    { (fst d, NO_INIT), snd d + 1 }
}

nonterm(Cabs.init_name * int) SPInitDeclarator {
  -> d:SPDeclarator
            { (fst d, NO_INIT), snd d }
  -> d:SPDeclarator "=" i:InitExpression     // (int)  x = 5
  	 		{ (fst d, fst i), snd d + snd i + 1 }
  -> "=" i:InitExpression     // (int)  x = 5. FIXME: add loc to e
  	 		{ (("",JUSTBASE,[],cabslu), fst i), snd i + 1 }
  -> i:InitExpression     // (int)  x = 5
  	 		{ (("",JUSTBASE,[],cabslu), fst i), snd i + 1 }
  -> i:SPInitExpression     // (int)  x = 5
  	 		{ (("",JUSTBASE,[],cabslu), (fst i)), snd i + 1 }
}

nonterm(Cabs.spec_elem list * cabsloc * int) FPDeclSpecList {
  ->  t:FPTypeSpecifier 
  	        { [SpecType(fst3 t)], snd3 t, trd3 t }
  -> lst:DeclSpecList t:FPTypeSpecifier  
            { (fst3 lst) @ [SpecType (fst3 t)], snd3 lst, trd3 t + trd3 lst }
  -> lst:DeclSpecList attr:FPAttributeNoCV
            { (fst3 lst) @ [SpecAttr(fst3 attr)], snd3 attr, trd3 attr + trd3 lst}
  -> lst:DeclSpecList a:AT_SPECIFIER LPAREN n:IDENT
            { (fst3 lst) @ [SpecPattern(fst n)], a, 3 + trd3 lst }
  -> lst:DeclSpecList a:AT_SPECIFIER LPAREN
            { (fst3 lst) @ [SpecPattern("")], a, 2 + trd3 lst }
  -> lst:DeclSpecList a:AT_SPECIFIER LPAREN
            { (fst3 lst) @ [SpecPattern("")], a, 1 + trd3 lst }
  -> lst:DeclSpecList a:AT_SPECIFIER
            { (fst3 lst) @ [SpecPattern("")], a, 1 + trd3 lst }
}

nonterm(Cabs.spec_elem list * cabsloc * int) SPDeclSpecList {
  ->  t:SPTypeSpecifier lst:DeclSpecListOptNoNamed
            { SpecType (fst3 t) :: fst lst, snd3 t, trd3 t + snd lst }
  -> attr:SPAttributeNoCV lst:DeclSpecListOpt
            { SpecAttr(fst3 attr) :: fst lst, snd3 attr, snd lst + trd3 attr }
  -> l:LPAREN n:IDENT RPAREN lst:DeclSpecListOpt
            { SpecPattern(fst n) :: fst lst, l, 3 + snd lst }
  -> n:IDENT r:RPAREN lst:DeclSpecListOpt
            { SpecPattern(fst n) :: fst lst, r, 2 + snd lst }
  ->  r:RPAREN lst:DeclSpecListOpt
            { SpecPattern("") :: fst lst, r, 1 + snd lst }
}

nonterm(Cabs.typeSpecifier * cabsloc * int) FPTypeSpecifier {
// FIXME: do I want struct name as an option, even though it's a real type
// specifier?  I think not, for now
  -> s:STRUCT                   n:FPIdOrTypeName
            { Tstruct (fst n, None, []), s, 1 + snd n} 
  -> s:STRUCT
            { Tstruct ("", None, []), s, 1 } 
  -> s:STRUCT ja:JustAttributes n:FPIdOrTypeName
            { Tstruct (fst n, None, fst ja), s, snd n + snd ja + 1 }
  -> s:STRUCT ja:JustAttributes 
            { Tstruct ("", None, fst ja), s, snd ja + 1 }
  -> s:STRUCT ja:FPJustAttributes 
            { Tstruct ("", None, fst ja), s, snd ja + 1 }
  -> s:STRUCT                   n:IdOrTypeName LBRACE memb:StructDeclList
            { Tstruct (fst n, Some(fst memb), []), s, 
                snd memb + snd n + 2 }
  -> s:STRUCT                   n:IdOrTypeName LBRACE memb:FPStructDeclList
            { Tstruct (fst n, Some(fst memb), []), s, 
                snd memb + snd n + 2 }
  -> s:STRUCT                   n:IdOrTypeName LBRACE 
            { Tstruct (fst n, None, []), s, snd n + 2 }
  -> s:STRUCT                                  LBRACE memb:StructDeclList
  	 		{ Tstruct ("", Some(fst memb), []), s, snd memb + 2 }
  -> s:STRUCT                                  LBRACE memb:FPStructDeclList
  	 		{ Tstruct ("", Some(fst memb), []), s, snd memb + 2 }
  -> s:STRUCT                                  LBRACE 
  	 		{ Tstruct ("", None, []), s, 2 }
  -> s:STRUCT ja:JustAttributes n:IdOrTypeName LBRACE memb:StructDeclList
            { Tstruct (fst n, Some(fst memb), fst ja), s, snd memb + snd ja + snd n + 3 }
  -> s:STRUCT ja:JustAttributes n:IdOrTypeName LBRACE memb:FPStructDeclList
            { Tstruct (fst n, Some(fst memb), fst ja), s, snd memb + snd ja + snd n + 2 }
  -> s:STRUCT ja:JustAttributes n:IdOrTypeName LBRACE 
            { Tstruct (fst n, None, fst ja), s, snd ja + snd n + 2 }
  -> s:STRUCT ja:JustAttributes                LBRACE memb:StructDeclList
            { Tstruct ("", Some(fst memb), fst ja), s, snd memb + snd ja + 2 }
  -> s:STRUCT ja:JustAttributes                LBRACE memb:FPStructDeclList
            { Tstruct ("", Some(fst memb), fst ja), s, snd memb + snd ja + 2 }
  -> s:STRUCT ja:JustAttributes                LBRACE
            { Tstruct ("", None, fst ja), s, snd ja + 2 }

  -> s:UNION                   n:FPIdOrTypeName     		  			 
            { Tunion (fst n, None, []), s, snd n + 1 }
  -> s:UNION
            { Tunion ("", None, []), s, 1 }
  -> s:UNION                   n:IdOrTypeName LBRACE memb:StructDeclList
            { Tunion (fst n, Some(fst memb), []), s, snd memb + snd n + 2 }
  -> s:UNION                   n:IdOrTypeName LBRACE memb:FPStructDeclList
            { Tunion (fst n, Some(fst memb), []), s, snd memb + snd n + 2 }
  -> s:UNION                   n:IdOrTypeName LBRACE
            { Tunion (fst n, None, []), s, snd n + 2 }
  -> s:UNION                                  LBRACE memb:StructDeclList
  	 		{ Tunion ("", Some(fst memb), []), s, snd memb + 2 }
  -> s:UNION                                  LBRACE memb:FPStructDeclList
  	 		{ Tunion ("", Some(fst memb), []), s, snd memb + 2 }
  -> s:UNION                                  LBRACE 
  	 		{ Tunion ("", None, []), s, 2 }
  -> s:UNION ja:JustAttributes n:IdOrTypeName LBRACE memb:StructDeclList 
            { Tunion (fst n, Some(fst memb), fst ja), s, snd memb + snd ja + snd n + 2 }
  -> s:UNION ja:JustAttributes n:IdOrTypeName LBRACE memb:FPStructDeclList 
            { Tunion (fst n, Some(fst memb), fst ja), s, snd memb + snd ja + snd n + 2 }
  -> s:UNION ja:JustAttributes n:IdOrTypeName LBRACE 
            { Tunion (fst n, None, fst ja), s, snd ja + snd n + 2 }
  -> s:UNION ja:JustAttributes n:FPIdOrTypeName
            { Tunion (fst n, None, fst ja), s, snd ja + snd n + 1 }
  -> s:UNION ja:JustAttributes
            { Tunion ("", None, fst ja), s, snd ja + 1 }
  -> s:UNION ja:FPJustAttributes
            { Tunion ("", None, fst ja), s, snd ja + 1 }

  -> s:UNION ja:JustAttributes                LBRACE memb:StructDeclList
            { Tunion ("", Some(fst memb), fst ja), s, snd memb + snd ja + 2 }
  -> s:UNION ja:JustAttributes                LBRACE memb:FPStructDeclList
            { Tunion ("", Some(fst memb), fst ja), s, snd memb + snd ja + 2 }
  -> s:UNION ja:JustAttributes                LBRACE 
            { Tunion ("", None, fst ja), s, snd ja + 2 }
                                                 
  -> s:ENUM                     n:FPIdOrTypeName
            { Tenum (fst n, None, []), s, snd n + 1 }
  -> s:ENUM
            { Tenum ("", None, []), s, 1 }
  -> s:ENUM  ja:JustAttributes  n:FPIdOrTypeName                       
            { Tenum (fst n, None, fst ja), s, snd ja + snd n + 1}
  -> s:ENUM  ja:JustAttributes
            { Tenum ("", None, fst ja), s, snd ja + 1}
  -> s:ENUM  ja:FPJustAttributes
            { Tenum ("", None, fst ja), s, snd ja + 1}
  -> s:ENUM                     n:IdOrTypeName LBRACE memb:EnumList m:MaybeComma
            { Tenum (fst n, Some(fst memb), []), s, snd memb + m + snd n + 2 }
  -> s:ENUM                     n:IdOrTypeName LBRACE memb:FPEnumList 
            { Tenum (fst n, Some(fst memb), []), s, snd memb + snd n + 2 }
  -> s:ENUM                     n:IdOrTypeName LBRACE 
            { Tenum (fst n, None, []), s, snd n + 2 }
  -> s:ENUM                               LBRACE memb:EnumList m:MaybeComma
  	 		{ Tenum ("", Some(fst memb), []), s, snd memb + m + 2 }
  -> s:ENUM                               LBRACE memb:FPEnumList
  	 		{ Tenum ("", Some(fst memb), []), s, snd memb + 2 }
  -> s:ENUM                               LBRACE 
  	 		{ Tenum ("", None, []), s, 2 }
  -> s:ENUM  ja:JustAttributes  n:IdOrTypeName LBRACE memb:EnumList m:MaybeComma 
            { Tenum (fst n, Some(fst memb),fst ja), s, snd memb + snd ja + m + snd n + 2 }
  -> s:ENUM  ja:JustAttributes  n:IdOrTypeName LBRACE memb:FPEnumList
            { Tenum (fst n, Some(fst memb),fst ja), s, snd memb + snd ja + snd n + 2 }
  -> s:ENUM  ja:JustAttributes  n:IdOrTypeName LBRACE 
            { Tenum (fst n, None, fst ja), s,snd ja + snd n + 2 }
  -> s:ENUM  ja:JustAttributes            LBRACE memb:EnumList m:MaybeComma
            { Tenum ("", Some(fst memb), fst ja), s, snd memb + snd ja + m + 2 }
  -> s:ENUM  ja:JustAttributes            LBRACE memb:FPEnumList 
            { Tenum ("", Some(fst memb), fst ja), s, snd memb + snd ja + 2 }
  -> s:ENUM  ja:JustAttributes            LBRACE 
            { Tenum ("", None, fst ja), s, snd ja + 2 }

  -> t:TYPEOF LPAREN e:ExpOrFPExp
            { TtypeofE (fst3 e), t, trd3 e + 2}
  -> t:TYPEOF LPAREN
            { TtypeofE (nd(NOTHING)), t, 2}
  -> t:TYPEOF
            { TtypeofE (nd(NOTHING)), t, 1}
  -> t:TYPEOF LPAREN e:TypeNameOrFPTypeName
            { TtypeofT (fst3 e, snd3 e), t, trd3 e + 2 }
}

nonterm(Cabs.typeSpecifier * cabsloc * int) SPTypeSpecifier {
  -> n:SPIdOrTypeName   /* (* FIXME: do I need this production? *) */
            { Tstruct (fst n, None, []), cabslu, snd n + 1 } 
  -> ja:JustAttributes n:IdOrTypeName                  
            { Tstruct ("", None, fst ja), cabslu, snd ja + snd n }
  -> n:IdOrTypeName l:LBRACE memb:StructDeclList RBRACE
            { Tstruct (fst n, Some(fst memb), []), l, snd memb + snd n + 2 }
  -> n:SPIdOrTypeName l:LBRACE memb:StructDeclList RBRACE
            { Tstruct (fst n, Some(fst memb), []), l, snd memb + snd n + 2 }
  -> l:LBRACE memb:StructDeclList RBRACE
            { Tstruct ("", Some(fst memb), []), l, snd memb + 2 }
  -> memb:StructDeclList r:RBRACE 
            { Tstruct ("", Some(fst memb), []), r, snd memb + 1 }
  -> ja:JustAttributes n:IdOrTypeName l:LBRACE memb:StructDeclList RBRACE
            { Tstruct (fst n, Some(fst memb), fst ja), l, 
                snd memb + snd ja + snd n + 2 }
  -> ja:JustAttributes l:LBRACE memb:StructDeclList RBRACE
            { Tstruct ("", Some(fst memb), fst ja), l, 
                snd memb + snd ja + 2 }
  -> n:IdOrTypeName l:LBRACE memb:EnumList m:MaybeComma RBRACE
            { Tenum (fst n, Some(fst memb), []), l, snd memb + m + snd n + 2 }
  -> n:SPIdOrTypeName l:LBRACE memb:EnumList m:MaybeComma RBRACE
            { Tenum (fst n, Some(fst memb), []), l, snd memb + m + snd n + 2 }

  -> l:LBRACE memb:EnumList m:MaybeComma RBRACE
            { Tenum ("", Some(fst memb), []), l, snd memb + m + 2 }
  -> memb:EnumList m:MaybeComma r:RBRACE
            { Tenum ("", Some(fst memb), []), r, snd memb + m + 1 }

  -> "," r:RBRACE /* (* FIXME do I want this? Can SP Enum list be empty? *) */ 
            { Tenum ("", None, []), r, 2 }
  -> ja:JustAttributes  n:IdOrTypeName l:LBRACE memb:EnumList m:MaybeComma RBRACE
            { Tenum (fst n, Some(fst memb), fst ja), l, snd memb + snd ja + m + snd n + 2 }
  -> ja:JustAttributes            l:LBRACE memb:EnumList m:MaybeComma RBRACE
            { Tenum ("", Some(fst memb), fst ja), l, 
                snd memb + snd ja + m + 2 }

  -> l:LPAREN e:Expression RPAREN  { TtypeofE (fst3 e), l, trd3 e + 2} 
  -> l:LPAREN e:TypeName RPAREN
            { TtypeofT (fst3 e, snd3 e), l, trd3 e + 2 }

}

nonterm(Cabs.field_group list * int) FPStructDeclList {
  -> dlist:DeclSpecList ";" slist:FPStructDeclList
            { (fst3 dlist, [(missingFieldDecl, None)]) :: fst slist, 
                trd3 dlist + snd slist + 1 }
/*(* GCC allows extra semicolons *)*/
  -> ";" lst:FPStructDeclList      
            { fst lst, snd lst + 1 }
  -> dlist:DeclSpecList flist:FieldDeclList ";" slist:FPStructDeclList 
            { ((fst3 dlist), fst flist) :: fst slist, 
                trd3 dlist + snd flist +  snd slist + 1}
  -> dlist:DeclSpecList flist:FieldDeclList ";" 
            { [((fst3 dlist), fst flist)], 
                trd3 dlist + snd flist + 1}
  -> dlist:DeclSpecList flist:FieldDeclList
            { [((fst3 dlist), fst flist)],
                trd3 dlist + snd flist}
  -> dlist:DeclSpecList flist:FPFieldDeclList
            { [((fst3 dlist), fst flist)], trd3 dlist + snd flist}
  -> dlist:DeclSpecList 
            { [((fst3 dlist), [(missingFieldDecl, None)])], trd3 dlist}
  -> dlist:FPDeclSpecList 
            { [((fst3 dlist), [(missingFieldDecl, None)])], trd3 dlist}
/*(* MSVC allows pragmas in strange places *)*/
  ->"pragma" slist:FPStructDeclList       
            { slist }
}

nonterm(Cabs.field_group list * int) SPStructDeclList {
  -> dlist:SPDeclSpecList ";" slist:StructDeclList
            { ((fst3 dlist), [(missingFieldDecl, None)]) :: fst slist, 
                trd3 dlist + snd slist + 1 }
  -> dlist:SPDeclSpecList flist:FieldDeclList ";" slist:StructDeclList 
             { ((fst3 dlist), fst flist) :: fst slist, 
                trd3 dlist + snd flist +  snd slist + 1}
  -> flist:FieldDeclList ";" slist:StructDeclList 
             { ([], fst flist) :: fst slist, 
                snd flist +  snd slist + 1}
  -> flist:SPFieldDeclList ";" slist:StructDeclList 
             { ([], fst flist) :: fst slist, 
                snd flist + snd slist + 1}
  -> ";" slist:StructDeclList 
             { fst slist, snd slist + 1}
}

nonterm((Cabs.name * expression node option) list * int) FPFieldDeclList {
  -> f:FPFieldDecl
		    { [pair3 f], trd3 f }
  -> f:FieldDecl "," fs:FPFieldDeclList
            { (pair3 f) :: (fst fs), trd3 f + snd fs + 1 }
  -> f:FieldDecl ","
            { [(pair3 f)], trd3 f + 1 }
}

nonterm((Cabs.name * expression node option) list * int) SPFieldDeclList {
  -> f:SPFieldDecl				           
            { [pair3 f], trd3 f }
  -> f:SPFieldDecl "," fs:FieldDeclList  
            { (pair3 f) :: (fst fs), 
                trd3 f + snd fs + 1 }
  -> "," fs:FieldDeclList  
            { (fst fs), snd fs + 1 }
}

nonterm(Cabs.name * expression node option * int) FPFieldDecl { 
  -> d:FPDeclarator                      
            { fst d, None, snd d }
  -> d:Declarator ":" e:Expression a:FPAttributes
            { let (n,decl,al,loc), count = d in
              let al' =  al @ (fst a) in
              (n,decl,al',loc), Some (fst3 e), count + 1 + trd3 e + snd a }
  -> d:Declarator ":" e:ExpOrFPExp
            { let (n,decl,al,loc), count = d in 
              (n,decl,al,loc), Some (fst3 e), count + 1 + trd3 e }
  -> d:Declarator ":" 
            { let (n,decl,al,loc), count = d in
              (n,decl,al,loc), None, count + 1 }
  -> ":" e:FPExpression     
            { missingFieldDecl, Some (fst3 e), trd3 e + 1 }
  -> ":"    { missingFieldDecl, None, 1 }
}

nonterm(Cabs.name * expression node option * int) SPFieldDecl { 
 // we throw attributes away because it's easier; let's hope they don't matter 
 // hugely when it comes to diffs
  -> d:SPDeclarator
            { fst d, None, snd d }
  -> d:SPDeclarator ":" e:Expression a:Attributes
            { fst d, Some(fst3 e), snd d + 1 + trd3 e + snd a }
  -> ":" e:Expression a:Attributes
            { missingFieldDecl, Some (fst3 e), 1 + trd3 e + snd a }
  -> e:ExpOrSPExp a:Attributes
            { missingFieldDecl, Some (fst3 e), trd3 e + snd a }
  -> a:Attributes
            { missingFieldDecl, None, snd a }
  -> a:SPAttributes
            { missingFieldDecl, None, snd a }
  -> e:SPExpression
            { missingFieldDecl, Some (fst3 e), trd3 e }
}

nonterm(Cabs.enum_item list * int) FPEnumList {  /* (* ISO 6.7.2.2 *) */
  -> e:FPEnumerator				
            {[fst e], snd e }
  -> lst:EnumList "," e:FPEnumerator
	        { fst lst @ [ (fst e) ], snd lst + 1 + snd e }
}

nonterm(Cabs.enum_item list * int) SPEnumList {
  -> e:SPEnumerator
			{[fst e], snd e }
  -> lst:SPEnumList "," e:Enumerator
	        { (fst lst) @ [ (fst e) ], snd lst + 1 + snd e }
			  
  -> "," e:Enumerator
	        { [ (fst e) ], 1 + snd e }
}

nonterm(Cabs.enum_item * int ) FPEnumerator {
  -> i:IDENT "=" e:FPExpression
		{(fst i, fst3 e, snd i), trd3 e + 2 }
  -> i:IDENT "="
		{(fst i, nd(NOTHING), snd i), 2 }
}

nonterm(Cabs.enum_item * int ) SPEnumerator {
  -> "=" e:Expression
		{("", fst3 e, snd3 e), trd3 e + 1 }
  -> e:ExpOrSPExp
		{("", fst3 e, snd3 e), trd3 e }
}

nonterm(Cabs.name * int ) FPDeclarator {
  -> p:PointerOpt d:DirectDeclarator aas:FPAttributesWithASM
  	        { let n,decl, count = d in 
                (n, (applyPointer (fst3 p) decl), fst aas, snd3 p), 
                trd3 p + count + snd aas }
  -> p:PointerOpt d:DirectDeclarator
  	        { let n,decl, count = d in 
                (n, applyPointer (fst3 p) decl,[], snd3 p), 
                  trd3 p + count }
  -> p:PointerOpt d:FPDirectDeclarator
  	        { let n,decl, count = d in 
                (n, applyPointer (fst3 p) decl,[], snd3 p), trd3 p + count }
}

nonterm(Cabs.name * int ) SPDeclarator {
  -> p:SPPointer d:DirectDeclarator aas:AttributesWithASM
  	        { let n,decl, count = d in 
                (n, applyPointer (fst3 p) decl, fst aas, snd3 p), 
                  trd3 p + count + snd aas }
  -> d:DirectDeclarator aas:AttributesWithASM
  	        { let n,decl, count = d in 
                (n, applyPointer [] decl, fst aas, cabslu), count + snd aas }
  -> d:SPDirectDeclarator aas:AttributesWithASM
  	        { let n,decl, count = d in 
                (n, applyPointer [] decl, fst aas, cabslu), count + snd aas }
  -> aas:AttributesWithASM
  	        { ("", JUSTBASE, fst aas, cabslu), snd aas }
  -> aas:SPAttributesWithASM
  	        { ("", JUSTBASE, fst aas, cabslu), snd aas }
}

nonterm(string * Cabs.decl_type * int) FPDirectDeclarator {
  -> n:FPIdOrTypeName
            { fst n, JUSTBASE, snd n }  
  -> LPAREN a:Attributes d:Declarator
            { let (n,decl,al,loc), count = d in 
                n, PARENTYPE(fst a,decl,al), snd a + count + 1 }
  -> LPAREN a:Attributes d:FPDeclarator
            { let (n,decl,aas,loc),count = d in
                n, PARENTYPE(fst a, decl, aas), snd a + count + 1 }
  -> LPAREN a:Attributes
            { "", PARENTYPE(fst a, JUSTBASE, []), snd a + 1 }
  -> LPAREN a:FPAttributes
            { "", PARENTYPE(fst a, JUSTBASE, []), snd a + 1 }
  -> d:DirectDeclarator LBRACKET aas:Attributes c:CEorFPCE
  	 		{ let n,decl,count = d in
			    n, ARRAY(decl, fst aas, smooth_expression (fst3 c)),
                  count + snd aas + trd3 c + 1 }
  -> d:DirectDeclarator LBRACKET aas:Attributes 
  	 		{ let n,decl,count = d in
			    n, ARRAY(decl, fst aas, nd(NOTHING)), count + snd aas + 1 }
  -> d:DirectDeclarator LBRACKET aas:FPAttributes 
  	 		{ let n,decl,count = d in
			    n, ARRAY(decl, fst aas, nd(NOTHING)), count + snd aas + 1 }
  -> d:DirectDeclarator LBRACKET 
  	 		{ let n,decl,count = d in
			    n, ARRAY(decl, [], nd(NOTHING)), count + 1 }
  -> d:DirectDeclarator  LPAREN ps:ParameterDeclList 
  	 		{ let n, decl, count1 = d in
              let params, isva, count2 = ps in
                n, PROTO(decl,  params, isva), 
                  count1 + count2 + 1 }
  -> d:DirectDeclarator  LPAREN ps:FPParameterDeclList 
  	 	    { let n, decl, count1 = d in
              let params, isva, count2 = ps in
                n, PROTO(decl, params, isva), count1 + count2 + 1 }
  -> d:DirectDeclarator LPAREN 
 /* (* FIXME: what's the bool for? *) */
  	 		{ let n, decl, count1 = d in
                n, PROTO(decl, [], false), count1 + 1 }
}

nonterm(string * Cabs.decl_type * int) SPDirectDeclarator {
  -> n:SPIdOrTypeName
            { fst n, JUSTBASE, snd n }  
  -> a:Attributes d:Declarator RPAREN
            { let (n,decl,al,loc), count = d in 
                n, PARENTYPE(fst a,decl, al), snd a + count + 1 }
  -> a:SPAttributes d:Declarator RPAREN
            { let (n,decl,al,loc), count = d in 
                n, PARENTYPE(fst a, decl, al), 
                  snd a + count + 1 }
  -> d:Declarator RPAREN
            { let (n,decl,al,loc), count = d in 
                n, PARENTYPE([],decl, al), 
                  count + 1 }
  -> d:SPDeclarator RPAREN
            { let (n,decl,al,loc),count = d in 
                n, PARENTYPE([],decl,al), count + 1 }
  -> d:SPDirectDeclarator LBRACKET aas:Attributes c:CommaExpressionOpt RBRACKET
  	 		{ let n,decl,count = d in
				n, ARRAY(decl,fst aas, fst c), 
                  count + snd aas + snd c + 2 }
  -> LBRACKET aas:Attributes c:CommaExpressionOpt RBRACKET
  	 		{ "", ARRAY(JUSTBASE, fst aas,fst c), 
                snd aas + snd c + 2 }
  -> aas:Attributes c:CommaExpressionOpt RBRACKET
  	 		{ "", ARRAY(JUSTBASE, fst aas,fst c), 
                snd aas + snd c + 1 }
  -> aas:SPAttributes c:CommaExpressionOpt RBRACKET
  	 		{ "", ARRAY(JUSTBASE, fst aas,fst c), 
                snd aas + snd c + 1 }
  -> d:SPDirectDeclarator  LPAREN ps:ParameterDeclList  RPAREN
  	 		{ let n, decl, count1 = d in
              let params, isva, count2 = ps in
                n, PROTO((decl,  params, isva)), 
                  count1 + count2 + 2 }
}

nonterm(Cabs.single_name list * bool * int) FPParameterDeclList {
  -> p:ParameterDecl rest:FPRestParList1
 	        {  let params, isva, count = rest in 
                  (fst p) :: params, isva, snd p + count  }
  -> p:FPParameterDecl rest:FPRestParList1
 	        {  let params, isva, count = rest in 
                  (fst p) :: params, isva, snd p + count  }
}

nonterm(Cabs.single_name list * bool * int) SPParameterDeclList {
   -> empty { [], false, 0 }
  -> p:SPParameterDecl rest:RestParList1
 	        {  let params, isva, count = rest in 
                  (fst p) :: params, isva, snd p + count  }
}

nonterm(Cabs.single_name list * bool * int ) FPRestParList1 {
   -> ","	{ [], false, 1 }
   -> "," p:ParameterDecl rst:FPRestParList1 
            {  let (params, isva, count) = rst in 
               (fst p) :: params, isva, count + snd p + 1  }
   -> "," p:FPParameterDecl
            { [(fst p)], false, snd p + 1  }
}

nonterm(Cabs.single_name * int ) FPParameterDecl {
  -> ds:DeclSpecList d:FPDeclarator  
            { (fst3 ds, fst d), trd3 ds + snd d }
  -> ds:FPDeclSpecList 
            { (fst3 ds, ("",JUSTBASE, [], cabslu)), trd3 ds }
  -> ds:DeclSpecList ad:FPAbstractDeclarator 
  	 		{ let d,a, count= ad in
				(fst3 ds, ("",d,a,cabslu)),
                  trd3 ds + count }
  -> LPAREN p:ParameterDecl 
            { (fst p), snd p + 1 }
  -> LPAREN p:FPParameterDecl 
            { fst p, snd p + 1 }
  -> l:LPAREN { ([], ("",JUSTBASE,[],l)) , 1 }   
}

nonterm(Cabs.single_name * int ) SPParameterDecl {
  -> ds:SPDeclSpecList d:Declarator  
            { (fst3 ds, fst d), 
                trd3 ds + snd d }
  -> d:Declarator  
            { ([], fst d), snd d }
  -> d:SPDeclarator  
            { ([], fst d), snd d }
  -> ds:SPDeclSpecList ad:AbstractDeclarator 
  	 		{ let d,a, count = ad in
				(fst3 ds, ("",d,a,cabslu)), trd3 ds + count }
  -> ad:AbstractDeclarator 
  	 		{ let d,a, count = ad in
				([], ("",d,a,cabslu)), count }
  -> ad:SPAbstractDeclarator 
  	 		{ let d,a, count = ad in
				([], ("",d,a,cabslu)), count }
  -> ds:SPDeclSpecList  
            { (fst3 ds, ("",JUSTBASE, [], cabslu)), trd3 ds }
  -> p:ParameterDecl RPAREN 
            { (fst p), snd p + 1 }
  -> p:SPParameterDecl RPAREN 
            { fst p, snd p + 1 }
  -> r:RPAREN { ([], ("",JUSTBASE,[],r)), 1}
}

/* (* Old style prototypes. Like a declarator *) */
nonterm(Cabs.name * int ) FPOldProtoDecl {
  -> ds:FPDirectOldProtoDecl
            { let n, decl, a, count = ds in
			    (n, decl, a, cabslu), count
            }
  -> p:Pointer ds:FPDirectOldProtoDecl
            { let n, decl, a, count = ds in
			    (n, applyPointer (fst3 p) decl, a, snd3 p), trd3 p + count
            }
  -> p:FPPointer  
            { ("<PARTIAL FUNCTION WITHOUT A PROTO>", 
                    applyPointer (fst3 p) JUSTBASE, [], cabslu), trd3 p }
}

nonterm(Cabs.name * int ) SPOldProtoDecl {
  -> p:SPPointer ds:DirectOldProtoDecl   
            { let n, decl, a, count = ds in
			  let aas =  a in
				(n, applyPointer (fst3 p) decl, aas, snd3 p), count
            }
  -> ds:SPDirectOldProtoDecl   
            { let n, decl, a, count = ds in
				(n, applyPointer [] decl, a, cabslu), count
            }
}

nonterm(string * Cabs.decl_type * Cabs.attribute list * int) FPDirectOldProtoDecl { 
  -> d:DirectDeclarator LPAREN lst:OldParameterListNE RPAREN ops:FPOldPardefList
            { let par_decl, isva = doOldParDecl (fst lst) (pair3 ops) in
              let n, decl, count = d in
                n, PROTO(decl, par_decl, isva), [], trd3 ops + snd lst + count + 2
            }
  -> d:DirectDeclarator LPAREN lst:OldParameterListNE RPAREN 
            { let par_decl, isva = doOldParDecl (fst lst) ([], false) in
              let n, decl, count = d in
                n, PROTO(decl,  par_decl, isva), [], snd lst + count + 2
            }
  -> d:DirectDeclarator LPAREN lst:OldParameterListNE
            { let par_decl, isva = doOldParDecl (fst lst) ([], false) in
              let n, decl, count = d in
                n, PROTO(decl,  par_decl, isva), [], snd lst + count + 1
            }
  -> d:DirectDeclarator LPAREN lst:FPOldParameterListNE
            { let par_decl, isva = doOldParDecl (fst lst) ([], false) in
              let n, decl, count = d in
                n, PROTO(decl, par_decl, isva), [], snd lst + count + 1
            }
}

nonterm(string * Cabs.decl_type * Cabs.attribute list * int) SPDirectOldProtoDecl { 
  -> d:SPDirectDeclarator LPAREN lst:OldParameterListNE RPAREN ops:OldPardefList
            { let par_decl, isva = doOldParDecl (fst lst) (pair3 ops)
			in
              let n, decl, count = d in
                n, PROTO(decl, par_decl, isva), [], trd3 ops + snd lst + count + 2
             }
  ->  LPAREN lst:OldParameterListNE RPAREN ops:OldPardefList
             { let par_decl, isva = doOldParDecl (fst lst) (pair3 ops) in
                 "", PROTO(JUSTBASE,par_decl, isva), [], trd3 ops + snd lst + 2
             }
  ->  lst:OldParameterListNE RPAREN ops:OldPardefList
             { let par_decl, isva = doOldParDecl (fst lst) (pair3 ops) in
                 "", PROTO(JUSTBASE,par_decl, isva), [], trd3 ops + snd lst + 1
             }
  ->  lst:SPOldParameterListNE RPAREN ops:OldPardefList
             { let par_decl, isva = doOldParDecl (fst lst) (pair3 ops) in
                 "", PROTO(JUSTBASE,par_decl, isva), [], trd3 ops + snd lst + 1
             }
  ->  RPAREN ops:OldPardefList
             { let par_decl, isva = doOldParDecl [] (pair3 ops) in
                 "", PROTO(JUSTBASE,par_decl, isva), [], trd3 ops + 1
             }
  -> ops:OldPardefList
             { let par_decl, isva = doOldParDecl [] (pair3 ops) in
                 "", PROTO(JUSTBASE,par_decl, isva), [], trd3 ops
             }
  -> ops:SPOldPardefList
            { let par_decl, isva = doOldParDecl [] (pair3 ops) in
                 "", PROTO(JUSTBASE,par_decl, isva), [], trd3 ops
            }
  -> d:SPDirectDeclarator LPAREN RPAREN
            { let n, decl,count = d in
               "", PROTO((decl, [], false)), [], count + 2
            }
  -> LPAREN RPAREN
            { "", PROTO(JUSTBASE, [], false), [], 2 }
  -> RPAREN { "", PROTO(JUSTBASE, [], false), [], 1 }
}

nonterm (string list * int ) FPOldParameterListNE {
  -> lst:OldParameterListNE "," 
            {  fst lst, snd lst + 1 }
}

nonterm (string list * int ) SPOldParameterListNE {
  -> "," lst:OldParameterListNE 
            { fst lst, snd lst + 1 }
}

nonterm(Cabs.name_group list * bool * int) FPOldPardefList { 
  -> ds:DeclSpecList o:OldPardef ";"
            { [(fst3 ds, fst o)], true, snd o + trd3 ds + 1 }
  -> ds:DeclSpecList o:OldPardef
            { [(fst3 ds, fst o)], true, snd o + trd3 ds }
  -> ds:DeclSpecList o:FPOldPardef 
            { [(fst3 ds, fst o)], true, snd o + trd3 ds }
  -> ds:DeclSpecList 
            { [(fst3 ds, [])], false, trd3 ds }
  -> ds:FPDeclSpecList 
            { [(fst3 ds, [])], false, trd3 ds }
  -> ds:DeclSpecList o:OldPardef ";" lst:FPOldPardefList 
            { let rest, isva, count1 = lst in
                (fst3 ds, fst o) :: rest, isva, trd3 ds + count1 + snd o + 1
            }
}

nonterm(Cabs.name_group list * bool * int) SPOldPardefList { 
  -> ds:SPDeclSpecList o:OldPardef ";" "..."
            { [(fst3 ds, fst o)], true, snd o + trd3 ds + 2 }
  -> o:OldPardef ";" "..."
            { [([], fst o)], true, snd o + 2 }
  -> o:SPOldPardef ";" "..."
            { [([], fst o)], true, snd o + 2 }
  -> ";" "..."
            { [], false, 2 }
  -> ds:SPDeclSpecList o:OldPardef ";" lst:OldPardefList 
            { let rest, isva, count1 = lst in
                 (fst3 ds, fst o) :: rest, isva, trd3 ds + count1 + snd o + 1
            }
  -> o:OldPardef ";" lst:OldPardefList 
            { let rest, isva, count1 = lst in
                 ([], fst o) :: rest, isva, count1 + snd o + 1 
            }
  -> o:SPOldPardef ";" lst:OldPardefList 
            { let rest, isva, count1 = lst in
                 ([], fst o) :: rest, isva,  count1 + snd o + 1
            }
  -> ";" lst:OldPardefList 
            { let rest, isva, count1 = lst in
                rest, isva, count1 + 1
            }
}

nonterm(Cabs.name list * int) FPOldPardef {
  -> d:FPDeclarator
            { [fst d], snd d }
  -> d:Declarator "," o:FPOldPardef
            { (fst d) :: (fst o), snd o + snd d + 1 }
  -> d:Declarator ","
            { [(fst d)], snd d + 1 }
}

nonterm(Cabs.name list * int) SPOldPardef {
  -> d:SPDeclarator	
            { [fst d], snd d }
  -> d:SPDeclarator "," o:OldPardef
            { (fst d) :: fst o, snd o + snd d + 1 }
  -> "," o:OldPardef
            { fst o, snd o + 1 }
  -> o:OldPardef
            { fst o, snd o }
}

nonterm(Cabs.attribute list list * cabsloc * int) FPPointer { /* (* ISO 6.7.5 *) */ 
  -> s:STAR attrs:Attributes p:FPPointer
            { (fst attrs) :: (fst3 p), s, trd3 p + snd attrs + 1 }
  -> s:STAR attrs:FPAttributes 
            { [(fst attrs)], s, snd attrs + 1 }
  -> s:STAR { [], s, 1 }
}

nonterm(Cabs.attribute list list * cabsloc * int) SPPointer { /* (* ISO 6.7.5 *) */ 
  -> attrs:Attributes p:PointerOpt  
            { (fst attrs) ::(fst3 p), snd3 p, snd attrs + 1 }
  -> attrs:SPAttributes p:PointerOpt  
            { (fst attrs) :: (fst3 p), snd3 p, snd attrs + 1 }
}

nonterm(Cabs.specifier * Cabs.decl_type * int) FPTypeName {
 -> d1:DeclSpecList ab:FPAbstractDeclarator 
 			{ let d2, a, count = ab in
(*               if a <> [] then begin
                  parse_error "attributes in type name";
                  raise Parsing.Parse_error
                end;*)
                fst3 d1, d2, trd3 d1 + count
            }
  -> d:FPDeclSpecList
            { fst3 d, JUSTBASE, trd3 d }
}

nonterm(Cabs.specifier * Cabs.decl_type * int) SPTypeName {
 -> ab:AbstractDeclarator 
            { let d2, a, count = ab in
(*                if a <> [] then begin
                  parse_error "attributes in type name";
                   raise Parsing.Parse_error
                 end;*)
                 [], d2, count
            }
 -> d1:SPDeclSpecList ab:AbstractDeclarator 
 		    { let d2, a, count = ab in
(*                if a <> [] then begin
                  parse_error "attributes in type name";
                   raise Parsing.Parse_error
                 end;*)
                 fst3 d1, d2, trd3 d1 + count
            }
 -> ab:SPAbstractDeclarator 
            { let d2, a, count = ab in
(*                if a <> [] then begin
                  parse_error "attributes in type name";
                   raise Parsing.Parse_error
                 end;*)
                 [], d2, count
            }

  -> d:SPDeclSpecList
            { fst3 d, JUSTBASE, trd3 d }
}

// an abstract declarator (not opt) must have *some* ground syntax in it
nonterm(Cabs.decl_type * Cabs.attribute list * int) FPAbstractDeclarator {
  -> p:PointerOpt d:DirectAbstractDeclarator a:FPAttributes 
            { applyPointer (fst3 p) (fst d), fst a, trd3 p + snd d + snd a }
  -> p:PointerOpt d:DirectAbstractDeclarator
            { applyPointer (fst3 p) (fst d), [], trd3 p + snd d }
  -> p:PointerOpt d:FPDirectAbstractDeclarator
            { applyPointer (fst3 p) (fst d), [], trd3 p + snd d }
  -> p:FPPointer 
            { applyPointer (fst3 p) JUSTBASE, [], trd3 p}
}

nonterm(Cabs.decl_type * Cabs.attribute list * int) SPAbstractDeclarator {
  -> p:SPPointer d:DirectAbstractDeclarator a:Attributes 
            { applyPointer (fst3 p) (fst d), fst a, trd3 p + snd d + snd a }
  -> a:Attributes 
            { JUSTBASE, fst a, snd a }
  -> a:SPAttributes 
            {  JUSTBASE, fst a, snd a }
  -> p:SPPointer 
            { applyPointer (fst3 p) JUSTBASE, [], trd3 p}
  -> d:SPDirectAbstractDeclarator a:Attributes 
            { (fst d), fst a, snd d + snd a }

}

nonterm(Cabs.decl_type * int) FPDirectAbstractDeclarator {
  -> LPAREN attrs:Attributes a:AbstractDeclarator
            { let d, a2, count =  a in 
                PARENTYPE(fst attrs, d, a2), 
                  count + snd attrs + 1
            }
  -> LPAREN attrs:Attributes a:FPAbstractDeclarator
            { let d, a2, count =  a in 
                PARENTYPE(fst attrs, d, a2), count + snd attrs + 1
            }
  -> LPAREN attrs:Attributes
            { PARENTYPE(fst attrs, JUSTBASE, []), snd attrs + 1 }
  -> LPAREN attrs:FPAttributes
            { PARENTYPE(fst attrs, JUSTBASE, []), snd attrs + 1 }
  -> LPAREN { PARENTYPE([], JUSTBASE, []), 1 }   

  -> d:DirectAbstractDeclaratorOpt LBRACKET ae:CommaExpressionOpt
            { ARRAY(fst d, [], fst ae), snd d + snd ae + 1 }
  -> d:DirectAbstractDeclaratorOpt LBRACKET ae:FPCommaExpression
            { ARRAY(fst d, [], smooth_expression (fst3 ae)), snd d + trd3 ae + 1 }
  -> d:DirectAbstractDeclaratorOpt LBRACKET
            { ARRAY(fst d, [], nd(NOTHING)), snd d + 1 }

  -> d:DirectAbstractDeclarator  LPAREN lst:ParameterDeclList 
  	 		{ let params,isva,count = lst in
				PROTO(fst d, params, isva), count + snd d + 1 }
  -> d:DirectAbstractDeclarator  LPAREN lst:FPParameterDeclList 
  	 		{ let params,isva,count = lst in
				PROTO(fst d, params, isva), count + snd d + 1 }
  -> d:DirectAbstractDeclarator LPAREN 
  	 		{ PROTO(fst d, [], false), snd d + 1 }
}

nonterm(Cabs.decl_type * int) SPDirectAbstractDeclarator {
  -> attrs:Attributes a:AbstractDeclarator RPAREN 
            { let d, a2, count =  a in 
                PARENTYPE(fst attrs, d, a2), count + snd attrs + 1
            }
  -> attrs:SPAttributes a:AbstractDeclarator RPAREN 
            { let d, a2, count =  a in 
                PARENTYPE(fst attrs, d, a2), count + snd attrs + 1
            }
  -> a:AbstractDeclarator RPAREN 
            { let d, a2, count =  a in 
                PARENTYPE([], d, a2), count + 1
            }
  -> a:SPAbstractDeclarator RPAREN 
            { let d, a2, count =  a in 
                PARENTYPE([], d, a2), count + 1
            }
  -> d:SPDirectAbstractDeclarator LBRACKET ae:CommaExpressionOpt RBRACKET 
            { ARRAY(fst d, [], fst ae), snd d + snd ae + 2 }
  -> d:SPDirectAbstractDeclarator  LPAREN lst:ParameterDeclList  RPAREN
  	 		{ let params,isva,count = lst in
				PROTO(fst d, params, isva), count + snd d + 2 }

}

// -- function definition --
nonterm(Cabs.definition node * int) FPFunctionDefinition {
  -> start:FunctionDefStart b:FPBlock
            { let loc, specs, decl, count = start in
               doFunctionDef loc (trd4 b) specs decl (fst4 b), count + frth4 b
            } 
  -> start:FunctionDefStart
          {  let loc, specs, decl, count = start in
            doFunctionDef loc cabslu specs decl (empty_block), count
          } 
  -> start:FPFunctionDefStart
            { let loc, specs, decl, count = start in
              doFunctionDef loc cabslu specs decl (empty_block), count
            } 
}

nonterm(Cabs.definition node * int) SPFunctionDefinition {
  -> start:SPFunctionDefStart b:Block
            { let loc, specs, decl, count = start in
              doFunctionDef loc (trd4 b) specs decl (fst4 b), count + frth4 b
            } 
  -> b:Block
            { doFunctionDef (snd4 b) (trd4 b) [] ("",JUSTBASE,[],snd4 b) (fst4 b), frth4 b }
  -> b:SPBlock
            { doFunctionDef (snd4 b) (trd4 b) [] ("",JUSTBASE,[],snd4 b) (fst4 b), frth4 b }
}

nonterm(cabsloc * Cabs.specifier * Cabs.name * int) FPFunctionDefStart {
  -> ds:DeclSpecList d:FPDeclarator
            { snd3 ds, fst3 ds, fst d, snd d + trd3 ds }
  -> ds:DeclSpecList
            { snd3 ds, fst3 ds, ("",JUSTBASE,[],snd3 ds), trd3 ds }

  -> ds:FPDeclSpecList
            { snd3 ds, fst3 ds, ("",JUSTBASE,[],snd3 ds), trd3 ds }

/* (* Old-style function prototype *) */
  -> ds:DeclSpecList old:FPOldProtoDecl
            { snd3 ds, fst3 ds, fst old, snd old + trd3 ds }
/* (* New-style function that does not have a return type *) */
  -> v:IDENT  LPAREN lst:ParameterDeclList 
            { 
			 let params, isva, count = lst in
             let fdec = 
                (fst v, PROTO(JUSTBASE, params, isva), [], snd v) in
                (* Default is int type *)
             let defSpec = [SpecType (Tint)] in
                  (snd v, defSpec, fdec, count + 2)
            }
  -> v:IDENT  LPAREN lst:FPParameterDeclList 
            { 
			 let params, isva, count = lst in
             let fdec = 
                (fst v, PROTO(JUSTBASE, params, isva), [], snd v) in
                (* Default is int type *)
             let defSpec = [SpecType (Tint)] in
                  (snd v, defSpec, fdec, count + 2)
            }
/* (* No return type and old-style parameter list *) */
  -> v:IDENT LPAREN lst:OldParameterListNE RPAREN ops:FPOldPardefList
            { (* Convert pardecl to new style *)
               let pardecl, isva = doOldParDecl (fst lst) (pair3 ops) in
              (* Make the function declarator *)
             let fdec = 
                (fst v, PROTO(JUSTBASE, pardecl, isva), [], snd v) in
                (* Default is int type *)
             let defSpec = [SpecType (Tint)] in
				(snd v, defSpec, fdec, snd lst + trd3 ops + 3)
            }
}

nonterm(cabsloc * Cabs.specifier * Cabs.name * int) SPFunctionDefStart {
  -> ds:SPDeclSpecList d:Declarator
            { (snd3 ds, fst3 ds, fst d, snd d + trd3 ds) }
  -> d:Declarator
            { (cabslu, [], fst d, snd d) }
  -> d:SPDeclarator
            { (cabslu, [], fst d, snd d) }

/* (* Old-style function prototype *) */
  -> ds:SPDeclSpecList old:OldProtoDecl
            { (snd3 ds, fst3 ds, fst old, snd old + trd3 ds)  }
  -> old:OldProtoDecl
            { (cabslu, [], fst old, snd old) }
  -> old:SPOldProtoDecl
            { (cabslu, [], fst old, snd old) }
/* (* New-style function that does not have a return type *) */
  ->  LPAREN lst:ParameterDeclList  RPAREN
            { let params, isva, count = lst in
              let fdec = 
                ("<PARTIAL FUNCTION WITHOUT A PROTO>", PROTO(JUSTBASE, params, isva), [], cabslu) in
               (* Default is int type *)
             let defSpec = [SpecType (Tint)] in
               (cabslu, defSpec, fdec, count + 2)
            }
  ->  lst:ParameterDeclList  RPAREN
            { let params, isva, count = lst in
              let fdec =
                ("<PARTIAL FUNCTION WITHOUT A PROTO>", PROTO(JUSTBASE, params, isva), [], cabslu) in
               (* Default is int type *)
             let defSpec = [SpecType (Tint)] in
               (cabslu, defSpec, fdec, count + 1)
            }
  ->  lst:SPParameterDeclList RPAREN
            { let params, isva, count = lst in
              let fdec = 
                ("<PARTIAL FUNCTION WITHOUT A PROTO>", PROTO(JUSTBASE, params, isva), [], cabslu) in
               (* Default is int type *)
             let defSpec = [SpecType (Tint)] in
               (cabslu, defSpec, fdec, count + 1)
            }

/* (* No return type and old-style parameter list *) */
  -> LPAREN lst:OldParameterListNE RPAREN ops:OldPardefList
            { (* Convert pardecl to new style *)
              let pardecl, isva = doOldParDecl (fst lst) (pair3 ops) in
               (* Make the function declarator *)
              let fdec = ("<PARTIAL FUNCTION WITHOUT A PROTO>",
                            PROTO(JUSTBASE, pardecl,isva),  [], cabslu) in
               (* Default is int type *)
             let defSpec = [SpecType (Tint)] in
				 (cabslu, defSpec, fdec, snd lst + trd3 ops + 2)
            }
  -> lst:OldParameterListNE RPAREN ops:OldPardefList
            { (* Convert pardecl to new style *)
              let pardecl, isva = doOldParDecl (fst lst) (pair3 ops) in
               (* Make the function declarator *)
              let fdec = ("<PARTIAL FUNCTION WITHOUT A PROTO>",
                            PROTO(JUSTBASE, pardecl,isva),  [], cabslu) in
               (* Default is int type *)
             let defSpec = [SpecType (Tint)] in
				 (cabslu, defSpec, fdec, snd lst + trd3 ops + 1)
            }
  -> lst:SPOldParameterListNE RPAREN ops:OldPardefList
            { (* Convert pardecl to new style *)
              let pardecl, isva = doOldParDecl (fst lst) (pair3 ops) in
               (* Make the function declarator *)
              let fdec = ("<PARTIAL FUNCTION WITHOUT A PROTO>",
                            PROTO(JUSTBASE, pardecl,isva),  [], cabslu) in
               (* Default is int type *)
             let defSpec = [SpecType (Tint)] in
				 (cabslu, defSpec, fdec, snd lst + trd3 ops + 1)
            }
  -> RPAREN ops:OldPardefList
            { (* Convert pardecl to new style *)
              let pardecl, isva = doOldParDecl [] (pair3 ops) in
               (* Make the function declarator *)
              let fdec = ("<PARTIAL FUNCTION WITHOUT A PROTO>",
                            PROTO(JUSTBASE, pardecl,isva),  [], cabslu) in
               (* Default is int type *)
               let defSpec = [SpecType (Tint)] in
				 (cabslu, defSpec, fdec, trd3 ops + 1)
            }
  -> ops:OldPardefList
            { (* Convert pardecl to new style *)
              let pardecl, isva = doOldParDecl [] (pair3 ops) in
               (* Make the function declarator *)
              let fdec = ("<PARTIAL FUNCTION WITHOUT A PROTO>",
                            PROTO(JUSTBASE, pardecl,isva),  [], cabslu) in
               (* Default is int type *)
             let defSpec = [SpecType (Tint)] in
				 (cabslu, defSpec, fdec, trd3 ops + 1)
            }
  -> ops:SPOldPardefList
            { (* Convert pardecl to new style *)
              let pardecl, isva = doOldParDecl [] (pair3 ops) in
               (* Make the function declarator *)
              let fdec = ("<PARTIAL FUNCTION WITHOUT A PROTO>",
                            PROTO(JUSTBASE, pardecl,isva),  [], cabslu) in
               (* Default is int type *)
             let defSpec = [SpecType (Tint)] in
				 (cabslu, defSpec, fdec, trd3 ops)
            }
/* (* No return type and no parameters *) */
  -> LPAREN RPAREN 
            { (* Make the function declarator *)
              let fdec = ("<PARTIAL FUNCTION WITHOUT A PROTO>",
                            PROTO(JUSTBASE, [],false),  [], cabslu) in
               (* Default is int type *)
             let defSpec = [SpecType (Tint)] in
	  		    (cabslu, defSpec, fdec, 2)
            }
  -> RPAREN { (* Make the function declarator *)
              let fdec = ("<PARTIAL FUNCTION WITHOUT A PROTO>",
                            PROTO(JUSTBASE, [],false),  [], cabslu) in
               (* Default is int type *)
             let defSpec = [SpecType (Tint)] in
	  		    (cabslu, defSpec, fdec, 1)
            }
}

nonterm(Cabs.attribute list * int) FPAttributes {
  -> t:Attribute lst:FPAttributes
            { (fst3 t) :: ( fst lst), trd3 t + snd lst }
  -> t:FPAttribute      
            { [(fst3 t)], trd3 t }
}

nonterm(Cabs.attribute list * int) SPAttributes {
  -> t:SPAttribute lst:Attributes
            { (fst3 t) :: (fst lst), trd3 t + snd lst }
}


nonterm(Cabs.attribute list * int) FPAttributesWithASM {
  -> a:Attribute rest:FPAttributesWithASM 
            { (fst3 a) :: (fst rest), trd3 a + snd rest }
  -> a:FPAttribute
            { [ fst3 a ], trd3 a }
  -> ASM LPAREN s:StringConstant RPAREN aas:FPAttributes 
             { ("__asm__", 
					   [nd(CONSTANT(CONST_STRING (fst3 s)))]) :: (fst aas), snd aas + trd3 s + 3 }
  -> ASM LPAREN s:StringConstant
             { [("__asm__", 
					   [nd(CONSTANT(CONST_STRING (fst3 s)))])], trd3 s + 2 }
  -> ASM LPAREN { [("__asm__", 
					   [nd(CONSTANT(CONST_STRING ""))])],  2 }
  -> ASM    { [("__asm__", 
					   [nd(CONSTANT(CONST_STRING ""))])],  1 }

}

nonterm(Cabs.attribute list * int) SPAttributesWithASM {
  -> a:SPAttribute rest:AttributesWithASM 
            { (fst3 a) :: (fst rest), trd3 a + snd rest }
  -> LPAREN s:StringConstant RPAREN aas:Attributes 
            { ("__asm__", [nd(CONSTANT(CONST_STRING (fst3 s)))]) :: (fst aas), snd aas + trd3 s + 2 }
  -> s:StringConstant RPAREN aas:Attributes 
            { ("__asm__", [nd(CONSTANT(CONST_STRING (fst3 s)))]) :: (fst aas), snd aas + trd3 s + 1 }
  -> RPAREN aas:Attributes 
            { fst aas, snd aas + 1 }
  -> aas:Attributes 
            { fst aas, snd aas }
  -> aas:SPAttributes 
            { fst aas, snd aas }
}

nonterm(Cabs.attribute * cabsloc * int ) FPAttributeNoCV {
  -> a:ATTRIBUTE LPAREN ps:AttrList
            { ("__attribute__", fst ps), a, snd ps + 2 }
  -> a:ATTRIBUTE LPAREN ps:FPAttrList
            { ("__attribute__", fst ps), a, snd ps + 2 }
  -> a:ATTRIBUTE LPAREN 
            { ("__attribute__", []), a, 2 }
  -> a:ATTRIBUTE
            { ("__attribute__", []), a, 1 }
  -> d:DECLSPEC LPAREN p:AttrListNE
            { ("__declspec", fst p), d, snd p + 2 }
  -> d:DECLSPEC LPAREN p:FPAttrList
            { ("__declspec", fst p), d, snd p + 2 }
  -> d:DECLSPEC LPAREN 
            { ("__declspec", []), d, 2 }
  -> d:DECLSPEC
            { ("__declspec", []), d, 1 }
}

nonterm(Cabs.attribute * cabsloc * int ) SPAttributeNoCV {
  -> l:LPAREN ps:AttrList RPAREN
            { ("__attribute__", fst ps), l, snd ps + 2 }
  -> ps:AttrList r:RPAREN
            { ("__attribute__", fst ps), r, snd ps + 1 }
  -> ps:SPAttrList r:RPAREN
            { ("__attribute__", fst ps), r, snd ps + 1 }
}

nonterm(Cabs.attribute list * int) FPAttributeNoCVList {
  -> a:AttributeNoCV aas:FPAttributeNoCVList
            { (fst3 a) :: (fst aas), trd3 a + snd aas }
  -> a:FPAttributeNoCV
            { [fst3 a], trd3 a }
}

nonterm(Cabs.attribute list * int) SPAttributeNoCVList {
  -> a:SPAttributeNoCV aas:AttributeNoCVList  
            { fst3 a :: fst aas, trd3 a + snd aas }
}

/* __attribute__ plus const/volatile */
nonterm (Cabs.attribute * cabsloc * int) FPAttribute {
  -> a:FPAttributeNoCV
 	 		{ a }
}

nonterm (Cabs.attribute * cabsloc * int) SPAttribute {
  -> a:SPAttributeNoCV
 	 		{ a }
}


nonterm (Cabs.attribute * int) FPJustAttribute {
  -> ATTRIBUTE LPAREN ps:AttrList
            { ("__attribute__", fst ps), snd ps + 2 }
  -> ATTRIBUTE LPAREN ps:FPAttrList
            { ("__attribute__", fst ps), snd ps + 2 }
  -> ATTRIBUTE LPAREN
            { ("__attribute__", []), 2 }
  -> ATTRIBUTE
            { ("__attribute__", []), 1 }
  -> DECLSPEC LPAREN ps:AttrListNE
            { ("__declspec", fst ps), snd ps + 2 }
  -> DECLSPEC LPAREN ps:FPAttrList
            { ("__declspec", fst ps), snd ps + 2 }
  -> DECLSPEC LPAREN
            { ("__declspec", []), 2 }
  -> DECLSPEC
            { ("__declspec", []), 1 }
}

nonterm (Cabs.attribute list * int) FPJustAttributes {
  -> j:FPJustAttribute
            { [(fst j)], snd j }
  -> j:JustAttribute js:FPJustAttributes
            { (fst j) :: fst js, snd j + snd js }
}

/** (* PRAGMAS and ATTRIBUTES *) ***/
nonterm(Cabs.definition node * int) FPPragma {
  -> p:PRAGMA a:Attr
            { nd(PRAGMA (fst a, p)), snd a + 1 }
  -> p:PRAGMA a:FPAttr
            { nd(PRAGMA (fst a, p)), snd a + 1 }
  -> p:PRAGMA
            { nd(PRAGMA (nd(NOTHING), p)), 1 }
  -> p:PRAGMA a:Attr ";" 
            { nd(PRAGMA (fst a, p)), snd a + 2 }
}

nonterm(Cabs.definition node * int) SPPragma {
  -> a:Attr p:PRAGMA_EOL
            { nd(PRAGMA (fst a, p)), snd a + 1 }
  -> a:SPAttr p:PRAGMA_EOL
            { nd(PRAGMA (fst a, p)), snd a + 1 }
  -> p:PRAGMA_EOL
            { nd(PRAGMA (nd(NOTHING), p)), 1 }
  -> a:Attr s:SEMICOLON PRAGMA_EOL
            { nd(PRAGMA (fst a, s)), snd a + 2 }
  -> a:SPAttr s:SEMICOLON PRAGMA_EOL
            { nd(PRAGMA (fst a, s)), snd a + 2 }
  -> s:SEMICOLON PRAGMA_EOL
            { nd(PRAGMA (nd(NOTHING), s)), 2 }
}

/* (* We want to allow certain strange things that occur in pragmas, so we 
    * cannot use directly the language of expressions *) */ 
nonterm(Cabs.expression node * int) FPPrimaryAttr {
  -> LPAREN a:Attr
            { fst a, snd a + 1 }
  -> LPAREN a:FPAttr
            { fst a, snd a + 1 } 
  -> LPAREN    
            { nd(NOTHING), 1 } 
  -> i:IDENT ":"
            { nd(VARIABLE (fst i ^ ":")), 2 }

/*(* The following rule conflicts with the ? : attributes. We give it a very 
   * low priority *)*/ 
  -> ci:CST_INT ":" 
            { nd(VARIABLE (fst ci ^ ":")), 2 } 

  -> DEFAULT ":"   
            { nd(VARIABLE ("default:")), 2 }
}

nonterm(Cabs.expression node * int) SPPrimaryAttr {
  -> a:Attr RPAREN
            { fst a, snd a + 1 } 
  -> a:SPAttr RPAREN
            { fst a, snd a + 1 } 
}

nonterm(Cabs.expression node * int) FPPostfixAttr { 
  -> p:FPPrimaryAttr				         
            { p }
  /* (* use a VARIABLE "" so that the parentheses are printed *) */
  -> i:IDENT LPAREN
            { nd(CALL(nd(VARIABLE (fst i)), [nd(VARIABLE "")])), 2 }
  -> i:IDENT LPAREN ps:AttrListNE
            { nd(CALL(nd(VARIABLE (fst i)), fst ps)), snd ps + 2 }
  -> i:IDENT LPAREN ps:FPAttrList
            { nd(CALL(nd(VARIABLE (fst i)), fst ps)), snd ps + 2 }
  -> p:PostfixAttr "->" a:FPIdOrTypeName
            { nd(MEMBEROFPTR (fst p, fst a)), snd p + snd a + 1 }
  -> p:PostfixAttr "->"
            { nd(MEMBEROFPTR (fst p, "")), snd p + 1 }
  -> p:PostfixAttr "." a:FPIdOrTypeName    
            { nd(MEMBEROF (fst p, fst a)), snd p + snd a + 1 }
  -> p:PostfixAttr "."
            { nd(MEMBEROF (fst p, "")), snd p + 1 }
  -> p:PostfixAttr LBRACKET a:Attr
            { nd(INDEX (fst p, fst a)), snd p + snd a + 1 }
  -> p:PostfixAttr LBRACKET a:FPAttr
            { nd(INDEX (fst p, fst a)), snd p + snd a + 1 }
  -> p:PostfixAttr LBRACKET
            { nd(INDEX (fst p, nd(NOTHING))), snd p + 1 }
}

nonterm(Cabs.expression node * int) SPPostfixAttr { 
  -> p:SPPrimaryAttr
            { p }
  /* (* use a VARIABLE "" so that the parentheses are printed *) */
  -> LPAREN RPAREN
            { nd(CALL(nd(VARIABLE ""), [nd(VARIABLE "")])), 2 }
  -> p:SPPostfixAttr "->" a:IdOrTypeName   
            { nd(MEMBEROFPTR (fst p, fst a)), snd p + snd a + 1 }
  -> "->" a:IdOrTypeName   
            { nd(MEMBEROFPTR (nd(NOTHING), fst a)), snd a + 1 }
  -> a:IdOrTypeName   
            { nd(MEMBEROFPTR (nd(NOTHING), fst a)), snd a }
  -> a:SPIdOrTypeName   
            { nd(MEMBEROFPTR (nd(NOTHING), fst a)), snd a }
  -> p:SPPostfixAttr "." a:IdOrTypeName    
            { nd((MEMBEROF (fst p, fst a))), snd p + snd a + 1 }
  -> "." a:IdOrTypeName    
            { nd(MEMBEROF (nd(NOTHING), fst a)), snd a + 1 }
  -> p:SPPostfixAttr LBRACKET a:Attr RBRACKET        
            { nd(INDEX (fst p, fst a)), snd p + snd a + 2}
  -> LBRACKET a:Attr RBRACKET
            { nd(INDEX (nd(NOTHING), fst a)), snd a + 2}
  -> a:Attr RBRACKET
            { nd(INDEX (nd(NOTHING), fst a)), snd a + 1}
  -> a:SPAttr RBRACKET
            { nd(INDEX (nd(NOTHING), fst a)), snd a + 1}
}

/*(* Since in attributes we use both IDENT and NAMED_TYPE as indentifiers, 
 * that leads to conflicts for SIZEOF and ALIGNOF. In those cases we require 
 * that their arguments be expressions, not attributes *)*/
nonterm (Cabs.expression node * int) FPUnaryAttr {
  -> p:FPPostfixAttr               
            { p }
  -> "sizeof" e:FPUnaryExpression
            { nd(EXPR_SIZEOF (fst3 e)), trd3 e + 1 }
  -> "sizeof"
            { nd(EXPR_SIZEOF (nd(NOTHING))), 1 }
  -> "sizeof" LPAREN t:TypeName
            { let b, d, count = t in nd(TYPE_SIZEOF (b,d)), count + 2 }
  -> "sizeof" LPAREN t:FPTypeName
            { let b, d, count = t in nd(TYPE_SIZEOF (b,d)), count + 2 }
  -> "sizeof" LPAREN
            { nd(TYPE_SIZEOF ([],JUSTBASE)), 2 }
  -> "alignof" e:FPUnaryExpression
            { nd(EXPR_ALIGNOF (fst3 e)), trd3 e + 1 }
  -> "alignof" LPAREN t:TypeName
  	        { let b, d, count = t in nd(TYPE_ALIGNOF (b,d)), count + 2 }
  -> "alignof" LPAREN t:FPTypeName
  	        { let b, d, count = t in nd(TYPE_ALIGNOF (b,d)), count +  2}
  -> "alignof" LPAREN
            { nd(EXPR_ALIGNOF (nd(NOTHING))), 2 } 
  -> "alignof"
            { nd(EXPR_ALIGNOF (nd(NOTHING))), 1 } 
  -> "+" ea:FPCastAttr
            { nd(UNARY(PLUS, fst ea)), snd ea + 1}
  -> "+"    { nd(UNARY(PLUS, nd(NOTHING))), 1} 
  -> "-" ea:FPCastAttr
            { nd(UNARY(MINUS, fst ea)), snd ea + 1}
  -> "-"    { nd(UNARY(MINUS, nd(NOTHING))), 1}
  -> "*" ea:FPCastAttr
            { nd(UNARY(MEMOF, fst ea)), snd ea + 1}
  -> "*"    { nd(UNARY(MEMOF, nd(NOTHING))), 1}
  -> "&" ea:FPCastAttr
            { nd(UNARY(ADDROF, fst ea)), snd ea + 1}
  -> "&"    { nd(UNARY(ADDROF, nd(NOTHING))), 1}
  -> "!" ea:FPCastAttr
            { nd(UNARY(NOT, fst ea)), snd ea + 1}
  -> "!"    { nd(UNARY(NOT, nd(NOTHING))), 1}
  -> "~" ea:FPCastAttr
            { nd(UNARY (BNOT, fst ea)), snd ea + 1}
  -> "~"    { nd(UNARY (BNOT, nd(NOTHING))), 1}
}

nonterm (Cabs.expression node * int) SPUnaryAttr {
  -> p:SPPostfixAttr
            { p }
}

nonterm (Cabs.expression node * int) FPCastAttr {
  -> ca:FPUnaryAttr
		  	{ ca }
}
nonterm (Cabs.expression node * int) SPCastAttr {
  -> ca:SPUnaryAttr
		  	{ ca }
}

nonterm (Cabs.expression node * int) FPBinaryAttr {
  -> e:FPCastAttr	  			    
            { e }
  -> ua1:BinaryAttr bop:BinaryOp ua2:FPBinaryAttr
            { nd(BINARY(bop, fst ua1, fst ua2)), snd ua1 + snd ua2 + 1}
  -> ua1:BinaryAttr bop:BinaryOp
            { nd(BINARY(bop, fst ua1, nd(NOTHING))), snd ua1 + 1}
}

nonterm (Cabs.expression node * int) SPBinaryAttr {
  -> e:SPCastAttr			  			    
            { e }
  -> ua1:SPBinaryAttr bop:BinaryOp ua2:BinaryAttr  
            { nd(BINARY(bop, fst ua1, fst ua2)), snd ua1 + snd ua2 + 1}
  -> bop:BinaryOp ua2:BinaryAttr  
            { nd(BINARY(bop, nd(NOTHING), fst ua2)), snd ua2 + 1}
}

nonterm (Cabs.expression node * int) FPConditionalAttr {
  -> a:FPBinaryAttr
            { a }
  -> ua1:BinaryAttr "?" ua2:ConditionalAttr ":" ua3:FPConditionalAttr
            { nd(QUESTION(fst ua1, fst ua2, fst ua3)), snd ua1 + snd ua2 + snd ua3 + 2 }
  -> ua1:BinaryAttr "?" ua2:ConditionalAttr ":" 
            { nd(QUESTION(fst ua1, fst ua2, nd(NOTHING))), snd ua1 + snd ua2 + 2 }
  -> ua1:BinaryAttr "?" ua2:ConditionalAttr
            { nd(QUESTION(fst ua1, fst ua2, nd(NOTHING))), snd ua1 + snd ua2 + 1 }
  -> ua1:BinaryAttr "?" ua2:FPConditionalAttr
            { nd(QUESTION(fst ua1, fst ua2, nd(NOTHING) )), snd ua1 + snd ua2 + 1 }
  -> ua1:BinaryAttr "?"
            { nd(QUESTION(fst ua1, nd(NOTHING), nd(NOTHING))), snd ua1 + 1 }
}

nonterm (Cabs.expression node * int) SPConditionalAttr {
  -> a:SPBinaryAttr							
            { a }
  -> ua1:SPBinaryAttr "?" ua2:ConditionalAttr ":" ua3:ConditionalAttr
            { nd(QUESTION(fst ua1, fst ua2, fst ua3)), snd ua1 + snd ua2 + snd ua3 + 2 }
  -> "?" ua2:ConditionalAttr ":" ua3:ConditionalAttr
            { nd(QUESTION(nd(NOTHING), fst ua2, fst ua3)), snd ua2 + snd ua3 + 2 }
  -> ua2:ConditionalAttr ":" ua3:ConditionalAttr
            { nd(QUESTION(nd(NOTHING), fst ua2, fst ua3)), snd ua2 + snd ua3 + 2 }
  -> ua2:SPConditionalAttr ":" ua3:ConditionalAttr
            { nd(QUESTION(nd(NOTHING), fst ua2, fst ua3)), snd ua2 + snd ua3 + 1 }
  -> ":" ua3:ConditionalAttr
            { nd(QUESTION(nd(NOTHING), nd(NOTHING), fst ua3)), snd ua3 + 1 }
}

nonterm(Cabs.expression node * int) FPAttr {
  -> u:FPConditionalAttr
		 	{ u }
}

nonterm(Cabs.expression node * int) SPAttr {
  -> u:SPConditionalAttr
 	        { u }
}

nonterm(Cabs.expression node list * int) FPAttrList {
  -> a:FPAttr
            { [fst a], snd a }
  -> a:Attr "," lst:FPAttrList
            { (fst a) :: fst lst, snd a + snd lst + 1 }
  -> a:Attr ","
            { [(fst a)], snd a + 1 }
}

nonterm(Cabs.expression node list * int) SPAttrList {
  -> a:SPAttr
            { [fst a], snd a }
  -> a:SPAttr "," lst:AttrListNE
            { fst a :: (fst lst), snd a + snd lst + 1 }
  -> "," lst:AttrListNE
            { fst lst, snd lst + 1 }
}

/*** GCC ASM instructions ***/

nonterm(Cabs.asm_details option * int) FPASMOutputs {
  -> ":" os:ASMOperands ai:FPASMInputs 
            { let ins, clobs, count = ai in
               Some({aoutputs = fst os; ainputs = ins; aclobbers = clobs}), snd os + count + 1 }
  -> ":" os:ASMOperands
            { Some({aoutputs = fst os; ainputs = []; aclobbers = []}), snd os + 1 }
  -> ":" os:FPASMOperands
            { Some({aoutputs = fst os; ainputs = []; aclobbers = []}), snd os + 1 }
  -> ":"    { None, 1 }
}

nonterm(Cabs.asm_details option * int) SPASMOutputs {
  -> os:ASMOperands ai:ASMInputs 
            { let ins, clobs, count = ai in
               Some({aoutputs = fst os; ainputs = ins; aclobbers = clobs}), snd os + count }
  -> os:SPASMOperands ai:ASMInputs 
            { let ins, clobs, count = ai in
               Some({aoutputs = fst os; ainputs = ins; aclobbers = clobs}), 
                snd os + count }
  -> ai:ASMInputs 
            { let ins, clobs, count = ai in
               Some({aoutputs = []; ainputs = ins; aclobbers = clobs}), count }
  -> ai:SPASMInputs 
            { let ins, clobs, count = ai in
               Some({aoutputs = []; ainputs = ins; aclobbers = clobs}), count }
}

nonterm((string option * string * expression node) list * int) SPASMOperands { 
  -> empty
            { [], 0 } 
  -> ao:SPASMOperandsNE
            { List.rev (fst ao), snd ao }
}

nonterm((string option * string * expression node) list * int) FPASMOperands {
  -> ao:FPASMOperand                            
            { [fst ao], snd ao }
  -> lst:ASMOperandsNE "," ao:FPASMOperand
            { (fst ao) :: fst lst, snd ao + snd lst + 1 }
  -> lst:ASMOperandsNE ","
            {fst lst, snd lst + 1 }
}

nonterm((string option * string * expression node) list * int) SPASMOperandsNE {
  -> ao:SPASMOperand                        
            { [fst ao], snd ao }
  -> lst:SPASMOperandsNE "," ao:ASMOperand  
            { fst ao :: fst lst, snd ao + snd lst + 1 }
  -> "," ao:ASMOperand  
            { [fst ao], snd ao + 1 }
}

nonterm((string option * string * expression node) * int) FPASMOperand {
  -> name:ASMOpName sc:StringConstant LPAREN e:ExpOrFPExp 
            { (fst name, fst3 sc, fst3 e), 1 + trd3 sc + trd3 e + snd name}
  -> name:ASMOpName sc:StringConstant LPAREN
            { (fst name, fst3 sc, nd(NOTHING)), 1 + trd3 sc + snd name }
  -> name:ASMOpName sc:StringConstant
            { (fst name, fst3 sc, nd(NOTHING)), trd3 sc + snd name }
  -> name:ASMOpName
            { (fst name, "", nd(NOTHING)), snd name }
  -> name:FPASMOpName
            { (fst name, "", nd(NOTHING)), snd name }
}

nonterm((string option * string * expression node) * int) SPASMOperand {
  -> name:SPASMOpName sc:StringConstant LPAREN e:Expression RPAREN
            { (fst name, fst3 sc, (fst3 e)), 2 + snd name + trd3 sc + trd3 e }
  -> sc:StringConstant LPAREN e:Expression RPAREN
            { (None, fst3 sc, fst3 e), 2 + trd3 sc + trd3 e }
}

nonterm((string option * string * expression node) list * string list * int) FPASMInputs {
  -> ":" ao:ASMOperands ac:FPASMClobber
            { fst ao, fst ac, snd ao + snd ac + 1 }
  -> ":" ao:ASMOperands
            { fst ao, [], snd ao + 1 }
  -> ":" ao:FPASMOperands
            { fst ao, [], snd ao + 1 }
  -> ":"    { [], [], 1 }
}

nonterm((string option * string * expression node) list * string list * int) SPASMInputs {
  -> ao:SPASMOperands ac:ASMClobber
            { fst ao, fst ac, snd ao + snd ac }
  -> ac:ASMClobber
            { [], fst ac, snd ac }
  -> ac:SPASMClobber
            { [], fst ac, snd ac }
}

nonterm(string option * int) FPASMOpName {
  -> LBRACKET i:IDENT
            { Some (fst i), 2 }
  -> LBRACKET
            { None, 1 }
}

nonterm(string option * int) SPASMOpName {
  -> i:IDENT RBRACKET
            { Some (fst i), 2 }
  -> RBRACKET
            { None, 1 }
}

nonterm(string list * int) FPASMClobber {
  -> ":" lst:FPASMCloberLstNE
            { fst lst, snd lst + 1 }
  -> ":"    { [], 1 }
            
}

nonterm(string list * int) SPASMClobber {
  -> lst:SPASMCloberLstNE        
            { fst lst, snd lst + 1 }
}

nonterm(string list * int) FPASMCloberLstNE {
  -> osc:OneStringConstant ","
            { [fst osc], snd osc + 1 }
}

nonterm(string list * int) SPASMCloberLstNE {
  -> "," lst:ASMCloberLstNE
            { fst lst, snd lst + 1 }
}