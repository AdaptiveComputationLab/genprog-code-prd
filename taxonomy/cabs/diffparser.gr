/*
 * Elkhound Grammar for an OCaml parser for C
 *
 * Author: CLG
 * Date: November 22, 2010
 * Based on jabs, cil's frontc, and Scott McPeak's C++ parser. 
 * I sense that this is going to suck.
 */

/* option lang_OCaml; */

context_class diffParser {
public:

};

verbatim {
open Cabs
open Cabshelper
open Lexerhack

let parse_error msg : unit =       (* sm: c++-mode highlight hack: -> ' <- *)
  failwith msg

let print = print_string

let cabslu = {lineno = -10; 
	      filename = "cabs loc unknown"; 
	      byteno = -10;
              ident = 0;}

(*
** Expression building
*)
let smooth_expression lst =
  match lst with
    [] -> NOTHING
  | [expr] -> expr
  | _ -> COMMA (lst)


let currentFunctionName = ref "<outside any function>"
    
let announceFunctionName ((n, decl, _, _):name) =
  !Lexerhack.add_identifier n;
  (* Start a context that includes the parameter names and the whole body. 
   * Will pop when we finish parsing the function body *)
  !Lexerhack.push_context ();
  (* Go through all the parameter names and mark them as identifiers *)
  let rec findProto = function
      PROTO (d, args, _) when isJUSTBASE d -> 
        List.iter (fun (_, (an, _, _, _)) -> !Lexerhack.add_identifier an) args

    | PROTO (d, _, _) -> findProto d
    | PARENTYPE (_, d, _) -> findProto d
    | PTR (_, d) -> findProto d
    | ARRAY (d, _, _) -> findProto d
    | _ -> parse_error "Cannot find the prototype in a function definition";
           raise Parsing.Parse_error 

  and isJUSTBASE = function
      JUSTBASE -> true
    | PARENTYPE (_, d, _) -> isJUSTBASE d
    | _ -> false
  in
  findProto decl;
  currentFunctionName := n



let applyPointer (ptspecs: attribute list list) (dt: decl_type)  
       : decl_type = 
  (* Outer specification first *)
  let rec loop = function
      [] -> dt
    | attrs :: rest -> PTR(attrs, loop rest)
  in
  loop ptspecs

let doDeclaration (loc: cabsloc) (specs: spec_elem list) (nl: init_name list) : definition = 
  if isTypedef specs then begin
    (* Tell the lexer about the new type names *)
    List.iter (fun ((n, _, _, _), _) -> !Lexerhack.add_type n) nl;
    TYPEDEF ((specs, List.map (fun (n, _) -> n) nl), loc)
  end else
    if nl = [] then
      ONLYTYPEDEF (specs, loc)
    else begin
      (* Tell the lexer about the new variable names *)
      List.iter (fun ((n, _, _, _), _) -> !Lexerhack.add_identifier n) nl;
      DECDEF ((specs, nl), loc)  
    end


let doFunctionDef (loc: cabsloc)
                  (lend: cabsloc)
                  (specs: spec_elem list) 
                  (n: name) 
                  (b: block) : definition = 
  let fname = (specs, n) in
  FUNDEF (fname, b, loc, lend)


let doOldParDecl (names: string list)
                 ((pardefs: name_group list), (isva: bool)) 
    : single_name list * bool =
  let findOneName n =
    (* Search in pardefs for the definition for this parameter *)
    let rec loopGroups = function
        [] -> ([SpecType Tint], (n, JUSTBASE, [], cabslu))
      | (specs, names) :: restgroups ->
          let rec loopNames = function
              [] -> loopGroups restgroups
            | ((n',_, _, _) as sn) :: _ when n' = n -> (specs, sn)
            | _ :: restnames -> loopNames restnames
          in
          loopNames names
    in
    loopGroups pardefs
  in
  let args = List.map findOneName names in
  (args, isva)

let checkConnective (s : string) : unit =
begin
  (* checking this means I could possibly have more connectives, with *)
  (* different meaning *)
  if (s <> "to") then (
    parse_error "transformer connective must be 'to'";
    raise Parsing.Parse_error
  )
  else ()
end

let int64_to_char value =
  if (compare value (Int64.of_int 255) > 0) || (compare value Int64.zero < 0) then
    begin
      let msg = Printf.sprintf "cparser:intlist_to_string: character 0x%Lx too big" value in
      parse_error msg;
      raise Parsing.Parse_error
    end
  else
    Char.chr (Int64.to_int value)

(* takes a not-nul-terminated list, and converts it to a string. *)
let rec intlist_to_string (str: int64 list):string =
  match str with
    [] -> ""  (* add nul-termination *)
  | value::rest ->
      let this_char = int64_to_char value in
      (String.make 1 this_char) ^ (intlist_to_string rest)


let pair3 (one,two,_) = one,two
let triple4 (one,two,three,_) = one,two,three
let fst3 (result, _, _) = result
let snd3 (_, result, _) = result
let trd3 (_, _, result) = result
let add_e2 a b = (snd a) + (snd b)
let add_e3 a b = (trd3 a) + (trd3 b)
let fst4 (result,_,_,_) = result
let snd4 (_,result,_,_) = result
let trd4 (_,_,result,_) = result
let frth4 (_,_,_,result) = result
 
(*
   transform:  __builtin_offsetof(type, member)
   into     :  (size_t) (&(type * ) 0)->member
 *)

let transformOffsetOf (speclist, dtype) member =
  let rec addPointer = function
    | JUSTBASE ->
	PTR([], JUSTBASE)
    | PARENTYPE (attrs1, dtype, attrs2) ->
	PARENTYPE (attrs1, addPointer dtype, attrs2)
    | ARRAY (dtype, attrs, expr) ->
	ARRAY (addPointer dtype, attrs, expr)
    | PTR (attrs, dtype) ->
	PTR (attrs, addPointer dtype)
    | PROTO (dtype, names, variadic) ->
	PROTO (addPointer dtype, names, variadic)
  in
  let nullType = (speclist, addPointer dtype) in
  let nullExpr = CONSTANT (CONST_INT "0") in
  let castExpr = CAST (nullType, SINGLE_INIT nullExpr) in

  let rec replaceBase = function
    | VARIABLE field ->
	MEMBEROFPTR (castExpr, field)
    | MEMBEROF (base, field) ->
	MEMBEROF (replaceBase base, field)
    | INDEX (base, index) ->
	INDEX (replaceBase base, index)
    | _ ->
	parse_error "malformed offset expression in __builtin_offsetof";
        raise Parsing.Parse_error 
  in
  let memberExpr = replaceBase member in
  let addrExpr = UNARY (ADDROF, memberExpr) in
  (* slight cheat: hard-coded assumption that size_t == unsigned int *)
  let sizeofType = [SpecType Tunsigned], JUSTBASE in
  let resultExpr = CAST (sizeofType, SINGLE_INIT addrExpr) in
  resultExpr
}

terminals {
include(c.tok)

precedence {
    // high precedence
    prec  200 PREFER_REDUCE;
	left  190 IDENT;
	right 185  NAMED_TYPE;    /* We'll use this to handle redefinitions of
                              * NAMED_TYPE as variables */
	left 90 "." "->" "(" "{";
	left 85	"[";
	right 80 ")" "!" "~" "++" "--" "sizeof" "alignof" TYPEOF;
	left 75 "*" "/" "%" "const" "restrict" "volatile";
	left 70 "+" "-";
	left 65 ">>" "<<";
	left 60 ">" "<" "<=" ">=";
	left 55 "==" "!=";
	left 50 "&";
	left 45 "^";
	left 40 "|";
	left 35 "&&";
	left 30 "||";
	right 25 "?" ":";
	right 20  "=" "+=" "-=" "*=" "/=" "%=" "&=" "|=" "^=" ">>=" "<<=" ;
	left 15 ",";
	nonassoc 10 "else";
	nonassoc 5 	"if";
    prec    1 PREFER_SHIFT;
  }

}

// now: non-terminals
nonterm(Cabs.definition list) File -> EnterScope t:Globals LeaveScope { fst t }

// scoping
nonterm EnterScope -> empty    precedence(PREFER_REDUCE)
{ 
  !Lexerhack.push_context()
} 

nonterm LeaveScope -> empty   
{
  !Lexerhack.pop_context ()
}


// ---------------- higher-level syntax -----------------
// the section labels that follow (like "A.3") are from the
// C++ standard document (should track down a proper reference..)

// ------ A.3 Basic Concepts ------

nonterm(Cabs.definition list * int) Globals {
  -> empty										        { [], 0 }
  -> g:Global gs:Globals 								{ (fst g) :: (fst gs), add_e2 g gs }
  -> SEMICOLON gs:Globals								{ gs }
}

nonterm(Cabs.definition * int) Global {
  -> d:Declaration				     { d }
  -> e:ExternDeclaration 			 { e } 
  -> f:FunctionDefinition			 { f }
  -> a:ASM "(" sc:StringConstant ")" ";"		   { GLOBASM(fst sc, a), 0 }  // StringConstant won't have an error, because it's a list
  -> p:Pragma  					 	 			   { p }
  -> t:TransformDeclaration						   { t }
}

nonterm(Cabs.definition * int) ExternDeclaration {
  -> "extern" s:StringConstant d:Declaration      { LINKAGE (fst s,snd s, [fst d]), snd d }
  -> "extern" s:StringConstant "{" t:Globals "}"  { LINKAGE (fst s,snd s,fst t), snd t  }
}

nonterm(Cabs.definition * int) TransformDeclaration {
/* transformer for a toplevel construct */
-> a:AT_TRANSFORM "{" g:Global "}"  v:IDENT "{" t:Globals "}" {
    checkConnective(fst v);
    TRANSFORMER(fst g,fst t,a), add_e2 g t
  }
/* transformer for an expression */
-> a:AT_TRANSFORMEXPR "{" e1:Expression "}" i:IDENT "{" e2:Expression "}" {
    checkConnective(fst i);
    EXPRTRANSFORMER(fst3 e1, fst3 e2, a), add_e3 e1 e2
  }
}
// ------------- identifier ambiguity -------------------
// identifiers can play two primary roles, and this is the
// source of problems parsing C and C++
// name of a type; introduced by class, struct, union, enum, typedef

// names for situations where it does not matter what its previous
// meaning may have been
nonterm(string) IdOrTypeName {
  -> n:IDENT  	      { fst n } 	       
  -> n:NAMED_TYPE     { fst n }
  -> AT_NAME "(" n:IDENT ")"         { "@name("^ fst n ^")" }
}

nonterm(unit) MaybeComma {
  -> empty	   			{ () }
  -> ","				{ () }
}

// ------ A.4 Expressions ------
nonterm(Cabs.expression * cabsloc * int) PrimaryExpression {
  -> n:IDENT     { VARIABLE(fst n),snd n, 0 } 
  -> e:Constant  { CONSTANT(fst e),snd e, 0 }
  -> "(" e:CommaExpression ")"      { PAREN (smooth_expression(fst3 e)), snd3 e, trd3 e }
  -> l:LBRACE b:Block "}" { GNU_BODY(fst4 b), l, frth4 b }
  -> a:AT_EXPR "(" v:IDENT ")" { EXPR_PATTERN(fst v), a,0 }
}

nonterm(Cabs.expression * cabsloc * int) PostfixExpression {
  -> e:PrimaryExpression  { e }

  // array access
  -> a:PostfixExpression "[" e:CommaExpression "]"
  { INDEX (fst3 a, smooth_expression (fst3 e)), snd3 a, add_e3 a e }

  // fn call
  -> f:PostfixExpression "(" e:Arguments ")"
       { CALL (fst3 f, fst e), snd3 f, (trd3 f) + (snd e) }
  -> bu:BUILTIN_VA_ARG "(" e:Expression "," t:TypeName ")"
                        { let b, d,te = t in
                          CALL (VARIABLE "__builtin_va_arg", 
                                [fst3 e; TYPE_SIZEOF (b, d)]), bu,te+(trd3 e) }
  -> b:BUILTIN_TYPES_COMPAT "(" t1:TypeName "," t2:TypeName ")"
                        { let b1,d1,e1 = t1 in
                          let b2,d2,e2 = t2 in
                          CALL (VARIABLE "__builtin_types_compatible_p", 
                                [TYPE_SIZEOF(b1,d1); TYPE_SIZEOF(b2,d2)]), b, e1 + e2 }
  -> b:BUILTIN_OFFSETOF "(" t:TypeName "," o:OffsetofMemberDesignator ")"
                        { transformOffsetOf (pair3 t) (fst o), b, (trd3 t + snd o) } 
  // field access
  -> p:PostfixExpression "."  n:IdOrTypeName 
       { MEMBEROF (fst3 p, n), snd3 p, trd3 p }

  // deref + field access
  -> p:PostfixExpression "->" n:IdOrTypeName
       { MEMBEROFPTR (fst3 p, n), snd3 p, trd3 p }

  -> p:PostfixExpression "++"
       { UNARY (POSINCR, fst3 p), snd3 p, trd3 p }
  -> p:PostfixExpression "--"
       { UNARY (POSDECR, fst3 p), snd3 p, trd3 p }
  -> "(" t:TypeName ")" l:LBRACE lst:InitializerListOpt "}"
		        { CAST((pair3 t), COMPOUND_INIT (fst lst)), l, (trd3 t + snd lst) }
}

nonterm(Cabs.expression * int) OffsetofMemberDesignator {	/* GCC extension for __builtin_offsetof */
  -> v:IdOrTypeName 							           { VARIABLE (v),0 } 
  -> lst:OffsetofMemberDesignator "." v:IDENT  { MEMBEROF (fst lst, fst v), snd lst }
  -> lst:OffsetofMemberDesignator "[" c:CommaExpression "]"
  								  			 	   { INDEX (fst lst,
												   smooth_expression (fst3 c)), (snd lst) + (trd3 c) }
}

nonterm(Cabs.expression * cabsloc * int) UnaryExpression {
  -> e:PostfixExpression                 { e }
  -> p:PLUS_PLUS e:UnaryExpression       { UNARY (PREINCR, fst3 e), p, trd3 e } 
  -> m:MINUS_MINUS e:UnaryExpression     { UNARY (PREDECR, fst3 e), m, trd3 e }
  -> s:SIZEOF e:UnaryExpression          { EXPR_SIZEOF(fst3 e), s, trd3 e }
  -> s:SIZEOF "(" t:TypeName ")"         { let b, d, e = t in TYPE_SIZEOF (b,d), s, e }
  -> a:ALIGNOF u:UnaryExpression         { EXPR_ALIGNOF (fst3 u), a, trd3 u}
  -> a:ALIGNOF "(" t:TypeName ")"	     { let b, d, e = t in TYPE_ALIGNOF (b,d), a, e }
  -> p:PLUS e:CastExpression             { UNARY (PLUS, fst3 e), p, trd3 e }
  -> m:MINUS e:CastExpression            { UNARY (MINUS, fst3 e), m, trd3 e }
  -> s:STAR e:CastExpression             { UNARY (MEMOF, fst3 e), s, trd3 e }
  -> a:AND e:CastExpression              { UNARY (ADDROF, fst3 e), a, trd3 e }
  -> x:EXCLAM e:CastExpression           { UNARY (NOT, fst3 e), x, trd3 e }
  -> t:TILDE e:CastExpression            { UNARY (BNOT, fst3 e),t, trd3 e }
  -> a:AND_AND v:IDENT  			     { LABELADDR (fst v), a, 0 }
}

nonterm(Cabs.expression * cabsloc * int) CastExpression {
  -> u:UnaryExpression	  { u }
  -> "(" t:TypeName ")" e:CastExpression { CAST (pair3 t, SINGLE_INIT (fst3 e)), snd3 e, trd3 e }
}

// ++++ binary operator expression ++++
nonterm(Cabs.expression * cabsloc * int) BinaryExpression {
  -> e:CastExpression                                   { e } 
  -> left:BinaryExpression "*" right:BinaryExpression   { BINARY(MUL, fst3 left, fst3 right), snd3 left, trd3 left }
  -> left:BinaryExpression "/" right:BinaryExpression   { BINARY(DIV, fst3 left, fst3 right), snd3 left, trd3 left }
  -> left:BinaryExpression "%" right:BinaryExpression   { BINARY(MOD, fst3 left, fst3 right), snd3 left, trd3 left }
  -> left:BinaryExpression "+" right:BinaryExpression   { BINARY(ADD, fst3 left, fst3 right), snd3 left, trd3 left }
  -> left:BinaryExpression "-" right:BinaryExpression   { BINARY(SUB, fst3 left, fst3 right), snd3 left, trd3 left }
  -> left:BinaryExpression "<<" right:BinaryExpression  { BINARY(SHL, fst3 left, fst3 right), snd3 left, trd3 left }
  -> left:BinaryExpression ">>" right:BinaryExpression  { BINARY(SHR, fst3 left, fst3 right), snd3 left, trd3 left }
  -> left:BinaryExpression "<" right:BinaryExpression   { BINARY(LT, fst3 left, fst3 right), snd3 left, trd3 left }
  -> left:BinaryExpression ">" right:BinaryExpression   { BINARY(GT, fst3 left, fst3 right), snd3 left, trd3 left }
  -> left:BinaryExpression "<=" right:BinaryExpression  { BINARY(LE, fst3 left, fst3 right), snd3 left, trd3 left }
  -> left:BinaryExpression ">=" right:BinaryExpression  { BINARY(GE, fst3 left, fst3 right), snd3 left, trd3 left }
  -> left:BinaryExpression "==" right:BinaryExpression  { BINARY(EQ, fst3 left, fst3 right), snd3 left, trd3 left }
  -> left:BinaryExpression "!=" right:BinaryExpression  { BINARY(NE, fst3 left, fst3 right), snd3 left, trd3 left }
  -> left:BinaryExpression "&" right:BinaryExpression   { BINARY(BAND, fst3 left, fst3 right), snd3 left, trd3 left }
  -> left:BinaryExpression "^" right:BinaryExpression   { BINARY(XOR, fst3 left, fst3 right), snd3 left, trd3 left }
  -> left:BinaryExpression "|"  right:BinaryExpression  { BINARY(BOR, fst3 left, fst3 right), snd3 left, trd3 left }
  -> left:BinaryExpression "&&" right:BinaryExpression  { BINARY(AND, fst3 left, fst3 right), snd3 left, trd3 left }
  -> left:BinaryExpression "||" right:BinaryExpression  { BINARY(OR, fst3 left, fst3 right), snd3 left, trd3 left }
}

nonterm(Cabs.expression * cabsloc * int) ConditionalExpression {
  -> e:BinaryExpression	  { e }
  -> cond:BinaryExpression "?" th:ExpressionOpt ":" el:ConditionalExpression 
       { QUESTION (fst3 cond, fst th, fst3 el), snd3 cond, (trd3 cond) + (snd th) + (trd3 el) }
}

// why is conditional not allowed on left side of = ?  can I confirm
// that in another language spec?  clearly both alternatives would have
// to be like-typed lvalues, but...

nonterm(Cabs.expression * cabsloc * int) AssignmentExpression {
  -> e:ConditionalExpression  { e }
  -> e1:UnaryExpression "=" e2:AssignmentExpression
			{BINARY(ASSIGN, fst3 e1, fst3 e2), snd3 e1, add_e3 e1 e2}
  -> e1:UnaryExpression "+=" e2:AssignmentExpression
			{BINARY(ADD_ASSIGN, fst3 e1, fst3 e2), snd3 e1, add_e3 e1 e2}
  -> e1:UnaryExpression "-=" e2:AssignmentExpression
			{BINARY(SUB_ASSIGN, fst3 e1, fst3 e2), snd3 e1, add_e3 e1 e2}
  -> e1:UnaryExpression "*=" e2:AssignmentExpression
			{BINARY(MUL_ASSIGN, fst3 e1, fst3 e2), snd3 e1, add_e3 e1 e2}
  -> e1:UnaryExpression "/=" e2:AssignmentExpression
			{BINARY(DIV_ASSIGN, fst3 e1, fst3 e2), snd3 e1, add_e3 e1 e2}
  -> e1:UnaryExpression "%=" e2:AssignmentExpression
			{BINARY(MOD_ASSIGN, fst3 e1, fst3 e2), snd3 e1, add_e3 e1 e2}
  -> e1:UnaryExpression "&=" e2:AssignmentExpression
			{BINARY(BAND_ASSIGN, fst3 e1, fst3 e2), snd3 e1, add_e3 e1 e2}
  -> e1:UnaryExpression "|=" e2:AssignmentExpression
			{BINARY(BOR_ASSIGN, fst3 e1, fst3 e2), snd3 e1, add_e3 e1 e2}
  -> e1:UnaryExpression "^=" e2:AssignmentExpression
			{BINARY(XOR_ASSIGN, fst3 e1, fst3 e2), snd3 e1, add_e3 e1 e2}
  -> e1:UnaryExpression "<<=" e2:AssignmentExpression	
			{BINARY(SHL_ASSIGN, fst3 e1, fst3 e2), snd3 e1, add_e3 e1 e2}
  -> e1:UnaryExpression ">>=" e2:AssignmentExpression
			{BINARY(SHR_ASSIGN, fst3 e1, fst3 e2), snd3 e1, add_e3 e1 e2}
}

nonterm (Cabs.expression * cabsloc * int ) Expression {
  -> ae:AssignmentExpression { ae }
}

nonterm(Cabs.constant * cabsloc) Constant {
  -> i:CST_INT    {  CONST_INT(fst i),snd i }
  -> f:CST_FLOAT  {  CONST_FLOAT(fst f),snd f }
  -> c:CST_CHAR   { CONST_CHAR(fst c),snd c }
  -> c:CST_WCHAR  { CONST_WCHAR(fst c),snd c } 
  -> sc:StringConstant {CONST_STRING(fst sc),snd sc }
  -> ws:WStringList  { CONST_WSTRING (fst ws), snd ws }
}

nonterm(string * cabsloc) StringConstant {
->   slist:StringList                         {
     let queue, location = slist in
     let buffer = Buffer.create (Queue.length queue) in
     Queue.iter
       (List.iter
	  (fun value ->
	    let char = int64_to_char value in
	    Buffer.add_char buffer char))
       queue;
     Buffer.contents buffer, location
   }
}

nonterm(string) OneStringConstant {
  -> s:CST_STRING				  { intlist_to_string(fst s) }
}

nonterm(int64 list Queue.t * cabsloc) StringList {
  -> s:OneString	   					{  let queue = Queue.create () in 
        							   Queue.add (fst s) queue;
									   queue, snd s
									}
  -> list:StringList s:OneString		{  Queue.add (fst s) (fst list); list }
}

nonterm(int64 list * cabsloc) WStringList {
  -> s:CST_WSTRING                         { s }
  -> lst:WStringList s:OneString           { (fst lst) @ (fst s), snd lst } 
  -> lst:WStringList s:CST_WSTRING         { (fst lst) @ (fst s), snd lst }
}

nonterm(int64 list * cabsloc) OneString {
  -> s:CST_STRING				{s}
  -> f:FUNCTION__               {(Cabshelper.explodeStringToInts !currentFunctionName), f}
  -> pf:PRETTY_FUNCTION__       {(Cabshelper.explodeStringToInts !currentFunctionName), pf}
}

nonterm(Cabs.init_expression * int) InitExpression {
  -> e:Expression				  { SINGLE_INIT(fst3 e), trd3 e }
  -> "{" lst:InitializerListOpt "}"  { COMPOUND_INIT(fst lst), snd lst } 
}

nonterm((Cabs.initwhat * Cabs.init_expression) list * int) InitializerList {
  -> i:Initializer				 { [pair3 i], trd3 i }
  -> i:Initializer "," lst:InitializerListOpt		 { (pair3 i) :: (fst lst), snd lst + trd3 i }
}

nonterm((Cabs.initwhat * Cabs.init_expression) list * int) InitializerListOpt {
  -> empty			   	         { [], 0 }
  -> lst:InitializerList		 { lst }
}

nonterm(Cabs.initwhat * Cabs.init_expression * int) Initializer {
  -> id:InitDesignators EqOpt ie:InitExpression { fst id, fst ie, add_e2 id ie }
  /* gcc_init_designators */
  -> g:GccInitDesignators i:InitExpression  { g,fst i, snd i }
  -> ie:InitExpression { NEXT_INIT, fst ie, snd ie }
}

nonterm( unit ) EqOpt {
  -> "=" 	   { () }
  -> empty 	   { () }
}

nonterm(Cabs.initwhat * int) InitDesignators {
  -> "." i:IdOrTypeName lst:InitDesignatorsOpt      { INFIELD_INIT(i, fst lst), snd lst }
  -> "[" e:Expression "]" lst:InitDesignatorsOpt
                                        { ATINDEX_INIT(fst3 e, fst lst), (trd3 e) + (snd lst) }
  -> "[" e1:Expression "..." e2:Expression "]"
                                        { ATINDEXRANGE_INIT(fst3 e1, fst3 e2), add_e3 e1 e2 }
}

nonterm(Cabs.initwhat * int) InitDesignatorsOpt {
  -> empty	   					  { NEXT_INIT, 0 }
  -> lst:InitDesignators		  { lst }
}

nonterm(Cabs.initwhat) GccInitDesignators {
  -> v:IdOrTypeName ":"			  { INFIELD_INIT(v, NEXT_INIT) }
}

nonterm(Cabs.expression list * int) Arguments {
  -> empty					      { [], 0 }
  -> c:CommaExpression			  { fst3 c, trd3 c }
}

nonterm(Cabs.expression * int)  ExpressionOpt {
  -> empty				  		  { NOTHING,0 }
  -> c:CommaExpression			  { smooth_expression (fst3 c), trd3 c }
}

nonterm(Cabs.expression list * cabsloc * int ) CommaExpression {
  -> e:Expression    { [ fst3 e ], snd3 e, trd3 e }
  -> e1:Expression "," e2:CommaExpression 
      { (fst3 e1) :: (fst3 e2), snd3 e1, add_e3 e1 e2 }
}

nonterm(Cabs.expression * int) CommaExpressionOpt {
  -> empty				 { NOTHING, 0 }
  -> ce:CommaExpression	 { smooth_expression(fst3 ce), trd3 ce }
}

// ------ A.5 Statements ------
// labeled-statement


nonterm(Cabs.block * cabsloc * cabsloc * int) Block {
  // I must enter scope immediately upon seeing the open-brace, so
  // that if the first token of the first statement changes or queries
  // the scope, it's in the new one
  -> EnterScope lb:LBRACE labels:LocalLabels attrs:BlockAttrs seq:BlockElementList LeaveScope r:RBRACE
     { { blabels = labels; battrs = fst attrs; bstmts=fst seq }, lb, r, (snd attrs) + (snd seq) }
} 

nonterm(Cabs.attribute list * int) BlockAttrs {
  -> empty			   		 { [], 0 }
  -> BLOCKATTRIBUTE "(" lst:AttrListNE ")" { [("__blockattribute__", fst lst)], snd lst }
}

nonterm( Cabs.statement list * int ) BlockElementList {
  -> empty 					   		    { [],0 }
  ->  s:Statement seq:BlockElementList  { (fst s) :: (fst seq), add_e2 s seq }
       
  -> d:Declaration seq:BlockElementList { DEFINITION(fst d) :: (fst seq), add_e2 d seq }
  -> v:IDENT ":"                        { [ LABEL (fst v, NOP (snd v), snd v)], 0 }
  ->  "pragma" seq:BlockElementList     { seq }
}

nonterm(string list) LocalLabels {
  -> empty                                       { [] }
  -> LABEL__ lst:LocalLabelNames ";" lst2:LocalLabels  { lst @ lst2 }
}

nonterm(string list) LocalLabelNames {
  -> i:IDENT                                 { [ fst i ] }
  -> i:IDENT "," lst:LocalLabelNames         { fst i :: lst }
}

nonterm( Cabs.statement * int) Statement {
  -> s:SEMICOLON		    { NOP(s), 0 }
  -> ce:CommaExpression ";" {COMPUTATION (smooth_expression (fst3 ce), (snd3 ce)), trd3 ce }
  -> s:Block    			{ BLOCK(fst4 s, (snd4 s)), frth4 s }
  -> f:IF "(" e:CommaExpression ")" s:Statement     precedence(IF)
       { IF ((smooth_expression (fst3 e)), fst s, NOP f, f), (trd3 e) + (snd s) }

  // if-then-else preferred over if-then when ambiguous
  -> f:IF "(" e:CommaExpression ")" s1:Statement "else" s2:Statement
       { IF ((smooth_expression  (fst3 e)), fst s1,fst s2, f ), trd3 e + snd s1 + snd s2 }
  -> sw:SWITCH "(" e:CommaExpression ")" s:Statement
       { SWITCH (smooth_expression (fst3 e), fst s, sw ), trd3 e + snd s }
  -> w:WHILE "(" e:CommaExpression ")" s:Statement
       { WHILE (smooth_expression (fst3 e), fst s, w ), trd3 e + snd s }
  -> d:DO s:Statement "while" "(" e:CommaExpression ")" ";"
       { DOWHILE (smooth_expression (fst3 e), fst s, d), trd3 e + snd s }
  -> f:FOR LPAREN fc:ForClause oe1:ExpressionOpt ";" oe2:ExpressionOpt RPAREN s:Statement
       { FOR( fst fc, fst oe1, fst oe2, fst s, f), snd fc + snd oe1 + snd oe2 + snd s }

  -> n:IDENT ":" AttributeNoCVList s:Statement 
       {(* The only attribute that should appear here
                                     is "unused". For now, we drop this on the
                                     floor, since unused labels are usually
                                     removed anyways by Rmtmps. *)
									 LABEL(fst n, fst s, (snd n)), snd s }
  -> c:CASE e:Expression ":" s:Statement      { CASE(fst3 e, fst s, c), trd3 e + snd s }
  // gnu extension
  -> c:CASE low:Expression "..." high:Expression ":" s:Statement
        { CASERANGE ( fst3 low, fst3 high, fst s, c ), trd3 low + trd3 high + snd s }

  -> d:DEFAULT ":" 	  	  	   	       { DEFAULT (NOP d, d), 0 }
  -> r:RETURN ";"                       { RETURN (NOTHING, r), 0 }
  -> r:RETURN e:CommaExpression ";"          { RETURN (smooth_expression (fst3 e), r ), trd3 e }

  -> b:BREAK ";"                        { BREAK ( b ), 0 }
  -> c:CONTINUE ";"                     { CONTINUE( c ), 0 }
  -> g:GOTO i:IDENT ";"      			{ GOTO(fst i,g), 0 }
  -> g:GOTO "*" c:CommaExpression ";"
										{ COMPGOTO ( smooth_expression (fst3 c), g), trd3 c }

  -> a:ASM aattr:ASMAttr "(" at:ASMTemplate ao:ASMOutputs ")" ";"
                           { ASM (aattr, at, fst ao, a), snd ao }
  -> m:MSASM              { ASM ([], [fst m], None, (*handleLoc*)(snd m)), 0}
  -> t:TRY bc:Block "except" "(" c1:CommaExpression ")"  b2:Block
                        { let b, _, _, e1 = bc in
                          let h, _, _, e2 = b2 in
 (*                         if not !Cprint.msvcMode then 
    * FIXME                            parse_error "try/except in GCC code";*) 
                          TRY_EXCEPT (b, COMMA (fst3 c1), h, (*handleLoc*) t), e1 + e2 + trd3 c1 }
  -> t:TRY bc:Block "finally" bc2:Block  
                        { let b, _, _, e1 = bc in
                          let h, _, _, e2= bc2 in
(*                          if not !Cprint.msvcMode then 
  FIXME                          parse_error "try/finally in GCC code";*)
                          TRY_FINALLY (b, h, (*handleLoc*) t), e1 + e2 }

}

nonterm( Cabs.for_clause * int) ForClause {
  -> e:ExpressionOpt ";" { FC_EXP(fst e), snd e }
  -> s:Declaration       { FC_DECL(fst s), snd s }
}

// ----- A.6 Declarations ------

nonterm(Cabs.definition * int) Declaration {
  -> d:DeclSpecList lst:InitDeclaratorList ";"
                 { doDeclaration ((*handleLoc*)(snd3 d)) (fst3 d) (fst lst), (snd lst) + (trd3 d) } 
  -> d:DeclSpecList ";"
                 { doDeclaration ((*handleLoc*)(snd3 d)) (fst3 d) [], trd3 d} 
 ->  v:IDENT "(" old:OldParameterListNE ")" ops:OldPardefList ";"
                           { (* Convert pardecl to new style *)
                             let pardecl, isva = doOldParDecl old (pair3 ops) in 
                             (* Make the function declarator *)
                             doDeclaration ((*handleLoc*) (snd v)) []
                               [((fst v, PROTO(JUSTBASE, pardecl,isva), [], cabslu),
                                 NO_INIT)],trd3 ops
                            }
/* (* Old style function prototype, but without any arguments *) */
-> v:IDENT "(" ")" ";"
                           { (* Make the function declarator *)
                             doDeclaration ((*handleLoc*)(snd v)) []
                               [((fst v, PROTO(JUSTBASE,[],false), [], cabslu),
                                 NO_INIT)], 0
                            }
}

// ------ A.7 Declarators ------
// -- declarator --
// a declarator is the "x" in a declaration like "int x"

nonterm(Cabs.init_name list * int) InitDeclaratorList {
  -> d:InitDeclarator  		 { [fst d], snd d }
  -> d:InitDeclarator "," lst:InitDeclaratorList
       						 { (fst d) :: (fst lst), add_e2 d lst }
}

nonterm(Cabs.init_name * int) InitDeclarator {
  -> d:Declarator                       { (fst d, NO_INIT), snd d }
  -> d:Declarator "=" i:InitExpression     // (int)  x = 5
  	 			  	  					 { (fst d,fst i), add_e2 d i }
}

nonterm(Cabs.spec_elem list * cabsloc * int ) DeclSpecList {
  -> t:TYPEDEF lst:DeclSpecListOpt  { SpecTypedef :: (fst lst), t, snd lst }
  -> e:EXTERN lst:DeclSpecListOpt    { SpecStorage EXTERN :: (fst lst), e, snd lst }
  -> s:STATIC lst:DeclSpecListOpt    { SpecStorage STATIC :: (fst lst), s, snd lst }
  -> a:AUTO lst:DeclSpecListOpt      { SpecStorage AUTO :: (fst lst), a, snd lst }
  -> r:REGISTER lst:DeclSpecListOpt  { SpecStorage REGISTER :: (fst lst), r, snd lst }
  -> t:TypeSpecifier lst:DeclSpecListOptNoNamed  { SpecType (fst3 t) :: (fst lst), snd3 t, trd3 t + snd lst }
  -> i:INLINE lst:DeclSpecListOpt    { SpecInline :: (fst lst), i, snd lst }
  -> c:CVSpec lst:DeclSpecListOpt    { (fst c) :: (fst lst), snd c, snd lst  }
  -> attr:AttributeNoCV lst:DeclSpecListOpt { SpecAttr(fst3 attr) :: (fst lst), snd3 attr, snd lst + trd3 attr }
  -> a:AT_SPECIFIER "(" n:IDENT ")"    { [SpecPattern(fst n)], a, 0 }
  	 					   			
}

nonterm(Cabs.spec_elem list * int) DeclSpecListOpt {
-> empty 				precedence(NAMED_TYPE)
 				{ [],0 } 
-> lst:DeclSpecList	{ fst3 lst, trd3 lst }
}
nonterm(Cabs.spec_elem list * int) DeclSpecListOptNoNamed {
-> empty 				precedence(IDENT)
 				{ [], 0 } 
-> lst:DeclSpecList	{ fst3 lst, trd3 lst }
}

nonterm(Cabs.typeSpecifier * cabsloc * int) TypeSpecifier {
  -> v:VOID                     { Tvoid, v, 0 }
  -> c:CHAR                     { Tchar, c, 0 }
  -> s:SHORT					{ Tshort, s, 0 }
  -> i:INT 					    { Tint, i, 0 }
  -> l:LONG                     { Tlong, l, 0 }
  -> i:INT64  				    { Tint64, i, 0 }
  -> f:FLOAT                    { Tfloat, f, 0 }
  -> d:DOUBLE                   { Tdouble, d, 0 }
  -> s:SIGNED                   { Tsigned, s, 0 }
  -> u:UNSIGNED  				{ Tunsigned, u, 0 }
  -> s:STRUCT                   n:IdOrTypeName    		  			 { Tstruct (n, None, []), s, 0 } 
  -> s:STRUCT ja:JustAttributes n:IdOrTypeName                       { Tstruct (n, None, fst ja), s, snd ja } 
  -> s:STRUCT                   n:IdOrTypeName "{" memb:StructDeclList "}"
                                          	                         { Tstruct (n, Some (fst memb), []), s, snd memb }
  -> s:STRUCT                                  "{" memb:StructDeclList "}"
  	 									   	                         { Tstruct ("", Some (fst memb), []), s, snd memb }
                                                 
  -> s:STRUCT ja:JustAttributes n:IdOrTypeName "{" memb:StructDeclList "}"
                                          	                         { Tstruct (n, Some (fst memb), fst ja), s, add_e2 memb ja }
  -> s:STRUCT ja:JustAttributes                "{" memb:StructDeclList "}"
                                          	                         { Tstruct ("", Some (fst memb), fst ja), s, add_e2 memb ja }

  -> s:UNION                   n:IdOrTypeName     		  			 { Tunion (n, None, []), s,0 } 
  -> s:UNION                   n:IdOrTypeName "{" memb:StructDeclList "}"
                                          	                         { Tunion (n, Some (fst memb), []), s,snd memb }
  -> s:UNION                                  "{" memb:StructDeclList "}"
  	 									   	                         { Tunion ("", Some (fst memb), []), s, snd memb }
  -> s:UNION ja:JustAttributes n:IdOrTypeName "{" memb:StructDeclList "}"
                                          	                         { Tunion (n, Some (fst memb), fst ja), s, add_e2 ja memb }
  -> s:UNION ja:JustAttributes                "{" memb:StructDeclList "}"
                                          	                         { Tunion ("", Some (fst memb), fst ja), s, add_e2 ja memb }
                                                 
  -> s:ENUM                     n:IdOrTypeName 		  			     { Tenum (n, None, []), s,0 } 
  -> s:ENUM  ja:JustAttributes  n:IdOrTypeName                       { Tenum (n, None, fst ja), s,snd ja } 
  -> s:ENUM                     n:IdOrTypeName "{" memb:EnumList MaybeComma "}"
                                          	                         { Tenum (n, Some (fst memb), []), s, snd memb }
  -> s:ENUM                               "{" memb:EnumList MaybeComma "}"
  	 									   	                         { Tenum ("", Some(fst memb), []), s, snd memb }
                                                 
  -> s:ENUM  ja:JustAttributes  n:IdOrTypeName "{" memb:EnumList MaybeComma "}"
                                          	                         { Tenum (n, Some (fst memb), fst ja), s,add_e2 ja memb }
  -> s:ENUM  ja:JustAttributes            "{" memb:EnumList MaybeComma "}"
                                          	                         { Tenum ("", Some (fst memb), fst ja), s, add_e2 ja  memb }

  // the existence of this production is part of why parsing C is hard
  -> n:NAMED_TYPE  	  	        {  Tnamed(fst n), snd n, 0 }

  -> t:TYPEOF "(" e:Expression ")"  { TtypeofE (fst3 e), t, trd3 e }
  -> t:TYPEOF "(" e:TypeName  ")"		{ let s,d,err = e in TtypeofT (s,d), t, err}
  	 			   						  
}

nonterm(Cabs.field_group list * int) StructDeclList { /* (* ISO 6.7.2. Except that we allow empty structs. We 
                      * also allow missing field names. *)
                   */
  -> empty                           { [], 0 }
  -> dlist:DeclSpecList ";" slist:StructDeclList
                                         { (fst3 dlist, 
                                            [(missingFieldDecl, None)]) :: (fst slist), trd3 dlist + snd slist }
/*(* GCC allows extra semicolons *)*/
  -> ";" lst:StructDeclList      { lst }
  -> dlist:DeclSpecList flist:FieldDeclList ";" slist:StructDeclList 
                                         { (fst3 dlist, fst flist) :: (fst slist), trd3 dlist + snd flist + snd slist }
/*(* MSVC allows pragmas in strange places *)*/
  ->"pragma" slist:StructDeclList       { slist }
}

nonterm((Cabs.name * expression option) list * int) FieldDeclList {
  -> f:FieldDecl				           { [pair3 f], trd3 f }
  -> f:FieldDecl "," fs:FieldDeclList  { (pair3 f) :: (fst fs), trd3 f + snd fs }
}

nonterm(Cabs.name * expression option * int) FieldDecl { /* (* ISO 6.7.2. Except that we allow unnamed fields. *) */
  -> d:Declarator                      { fst d, None, snd d }
  -> d:Declarator ":" e:Expression a:Attributes
                                    { let (n,decl,al,loc), err = d in
                                      let al' = al @ (fst a) in
                                     (n,decl,al',loc), Some (fst3 e), trd3 e + err + snd a }    
  -> ":" e:Expression     { missingFieldDecl, Some (fst3 e), trd3 e }
}

nonterm(Cabs.enum_item list * int) EnumList {  /* (* ISO 6.7.2.2 *) */
  -> e:Enumerator				{[fst e], snd e}
  -> lst:EnumList "," e:Enumerator	        {(fst lst) @ [(fst e)], add_e2 lst e}
}

nonterm(Cabs.enum_item * int) Enumerator {
  -> i:IDENT			{(fst i, NOTHING, snd i), 0}
  -> i:IDENT "=" e:Expression		{(fst i, fst3 e, snd i), trd3 e}
}

nonterm(Cabs.name * int) Declarator {
  -> p:PointerOpt d:DirectDeclarator aas:AttributesWithASM
  	   { let n,decl, err = d in (n, applyPointer (fst3 p) decl,fst aas, snd3 p), trd3 p + err + snd aas } 
}

nonterm(string * Cabs.decl_type * int) DirectDeclarator {
  -> n:IdOrTypeName       { (n, JUSTBASE,0) }  

  -> "(" a:Attributes d:Declarator ")"
                                  { let (n,decl,al,loc),e = d in
                                     n, PARENTYPE(fst a,decl,al),e + snd a}

  -> d:DirectDeclarator "[" aas:Attributes c:CommaExpressionOpt "]"
  	 							   { let n,decl, err = d in
								     n, ARRAY(decl, fst aas, fst c),snd c + err + snd aas }
  -> d:DirectDeclarator EnterScope "(" ps:ParameterDeclList LeaveScope ")" // FIXME: did not change this
  	 							   { let n, decl, err1 = d in
                                     let (params, isva, err2) = ps in
                                     n, PROTO(decl, params, isva), err1 + err2
                                   }  	 							   
}

nonterm(Cabs.single_name list * bool * int) ParameterDeclList {
   -> empty	   					   { [], false,0 }
  -> p:ParameterDecl rest:RestParList1 	   {  let (params, isva, err1) = rest in 
                                     ((fst p) :: params, isva,snd p + err1)  }
}

nonterm(Cabs.single_name list * bool * int) RestParList1 {
   -> empty				 	  		  	   { [], false, 0 }
   -> "," "..."					   		   { [], true, 0 }
   -> "," p:ParameterDecl rst:RestParList1 {  let (params, isva, err1) = rst in 
                                           (fst p :: params, isva, snd p + err1) }
}

nonterm(Cabs.single_name * int) ParameterDecl {
  -> ds:DeclSpecList d:Declarator  { (fst3 ds, (fst d)), trd3 ds + snd d }
  -> ds:DeclSpecList ad:AbstractDeclarator 
  	 						  { let d,a,err= ad in
							  	(fst3 ds, ("",d,a,cabslu)), trd3 ds + err} 
  -> ds:DeclSpecList  { (fst3 ds, ("",JUSTBASE, [], cabslu)),trd3 ds}
  -> "(" p:ParameterDecl ")" { p }   	 						  
}

/* (* Old style prototypes. Like a declarator *) */
nonterm(Cabs.name * int) OldProtoDecl {
  -> p:PointerOpt ds:DirectOldProtoDecl   { let (n, decl, a, err1) = ds in
					  					  	    (n, applyPointer (fst3 p) decl, a, snd3 p), err1 + trd3 p
                                          }
}

nonterm(string * Cabs.decl_type * Cabs.attribute list * int) DirectOldProtoDecl { 
  -> d:DirectDeclarator "(" lst:OldParameterListNE ")" ops:OldPardefList
                                   { let par_decl, isva = doOldParDecl lst (pair3 ops) in
                                     let n, decl, err1 = d in
                                     (n, PROTO(decl, par_decl, isva), [], err1 + trd3 ops)
                                   }
  -> d:DirectDeclarator "(" ")"
                                   { let n, decl, err = d in
                                     (n, PROTO(decl, [], false), [], err)
                                   }

/* (* appears sometimesm but generates a shift-reduce conflict. *)
 | LPAREN STAR direct_decl LPAREN old_parameter_list_ne RPAREN RPAREN LPAREN RPAREN old_pardef_list
                                   { let par_decl, isva 
                                             = doOldParDecl $5 $10 in
                                     let n, decl = $3 in
                                     (n, PROTO(decl, par_decl, isva), [])
                                   }
*/
}

nonterm (string list ) OldParameterListNE {
  -> v:IDENT                                       { [fst v] }
  -> v:IDENT "," lst:OldParameterListNE 
                                               {  (fst v) :: lst }
}

nonterm(Cabs.name_group list * bool * int) OldPardefList { 
  -> empty  { ([], false, 0) }
  -> ds:DeclSpecList o:OldPardef ";" "..."
                                          { ([(fst3 ds, fst o)], true, trd3 ds + snd o) }  
  -> ds:DeclSpecList o:OldPardef ";" lst:OldPardefList 
                                          { let rest, isva, err1 = lst in
                                            ((fst3 ds, fst o) :: rest, isva, trd3 ds + err1 + snd o) 
                                          }
}

nonterm(Cabs.name list * int) OldPardef {
  -> d:Declarator						     { [fst d], snd d }
  -> d:Declarator "," o:OldPardef            { (fst d) :: (fst o), add_e2 d o }
}

nonterm(Cabs.attribute list list * cabsloc * int) Pointer { /* (* ISO 6.7.5 *) */ 
  -> s:STAR attrs:Attributes p:PointerOpt  { (fst attrs) :: (fst3 p), s, snd attrs + trd3 p }
}

nonterm(Cabs.attribute list list * cabsloc * int) PointerOpt {
  -> empty 	   { [], cabslu,0 } // FIXME?
  -> p:Pointer  { p } 
}


nonterm(Cabs.spec_elem list * Cabs.decl_type * int) TypeName {
 -> d1:DeclSpecList ab:AbstractDeclarator 
 								{ let d2, a,e = ab in
                                 if a <> [] then begin
                                   parse_error "attributes in type name";
                                   raise Parsing.Parse_error
                                 end;
                                 (fst3 d1, d2, e+ (trd3 d1)) 
                               }
  -> d:DeclSpecList                { fst3 d, JUSTBASE, trd3 d }
}

// an abstract declarator (not opt) must have *some* ground syntax in it
nonterm(Cabs.decl_type * Cabs.attribute list * int) AbstractDeclarator {
  -> p:PointerOpt d:DirectAbstractDeclarator a:Attributes { applyPointer ( fst3 p) (fst d), fst a, snd d + snd a + trd3 p}
  -> p:Pointer  { applyPointer (fst3 p) JUSTBASE, [], trd3 p }
}

// this also must have some ground syntax
nonterm(Cabs.decl_type * int) DirectAbstractDeclarator {
  -> "(" attrs:Attributes a:AbstractDeclarator ")" 
                                   { let d, a2, err =  a in 
                                     PARENTYPE (fst attrs, d, a2), err + snd attrs
                                   }

  -> d:DirectAbstractDeclaratorOpt "[" ae:CommaExpressionOpt "]" 
                                   { ARRAY(fst d, [], fst ae), add_e2 d ae }

  -> d:DirectAbstractDeclarator EnterScope "(" lst:ParameterDeclList LeaveScope ")"
  	 							   { let params,isva, err1 = lst in
								      PROTO(fst d, params, isva), err1 + snd d }
}


nonterm(Cabs.decl_type * int) DirectAbstractDeclaratorOpt {
  -> empty                       { JUSTBASE,0 }
  -> d:DirectAbstractDeclarator  { d } 
}

// -- function definition --
nonterm(Cabs.definition * int) FunctionDefinition {
  -> start:FunctionDefStart b:Block
          {  let (loc, specs, decl, err1) = start in
            currentFunctionName := "<__FUNCTION__ used outside any functions>";
            !Lexerhack.pop_context (); (* The context pushed by 
                                        * announceFunctionName. Sort of a bad hack *)
            doFunctionDef ((*handleLoc*) loc) (trd4 b) specs decl (fst4 b), err1 + frth4 b
          } 
}

nonterm(cabsloc * Cabs.spec_elem list * Cabs.name * int) FunctionDefStart {
  -> ds:DeclSpecList d:Declarator
                            { announceFunctionName (fst d);
							  (snd3 ds, fst3 ds, fst d, trd3 ds + snd d)
                            } 

/* (* Old-style function prototype *) */
  -> ds:DeclSpecList old:OldProtoDecl
                            { announceFunctionName (fst old);
							 (snd3 ds, fst3 ds, fst old, snd old + trd3 ds) 
                            } 
/* (* New-style function that does not have a return type *) */
  -> v:IDENT EnterScope "(" lst:ParameterDeclList LeaveScope ")"
                           { 
						   let (params, isva, err1) = lst in
                             let fdec = 
                               (fst v, PROTO(JUSTBASE, params, isva), [], snd v) in
                             announceFunctionName fdec;
                             (* Default is int type *)
                             let defSpec = [SpecType Tint] in
                              (snd v, defSpec, fdec, err1)
                           }

/* (* No return type and old-style parameter list *) */
  -> v:IDENT "(" lst:OldParameterListNE ")" ops:OldPardefList
                           { (* Convert pardecl to new style *)
                             let pardecl, isva = doOldParDecl lst (pair3 ops) in
                             (* Make the function declarator *)
                             let fdec = (fst v,
                                         PROTO(JUSTBASE, pardecl,isva), 
                                         [], snd v) in
                             announceFunctionName fdec;
                             (* Default is int type *)
                             let defSpec = [SpecType Tint] in
							 (snd v, defSpec, fdec, trd3 ops)
                            }
/* (* No return type and no parameters *) */
  -> v:IDENT "(" ")" 
                           { (* Make the function declarator *)
                             let fdec = (fst v,
                                         PROTO(JUSTBASE, [], false), 
                                         [], snd v) in
                             announceFunctionName fdec;
                             (* Default is int type *)
                             let defSpec = [SpecType Tint] in
							 (snd v, defSpec, fdec, 0)
                            }
}

nonterm(Cabs.spec_elem * cabsloc) CVSpec {
  -> c:CONST                               { SpecCV(CV_CONST), c }
  -> v:VOLATILE                            { SpecCV(CV_VOLATILE), v }
  -> r:RESTRICT                            { SpecCV(CV_RESTRICT), r }
}

nonterm(Cabs.attribute list * int) Attributes {
  -> empty			   		 	     { [], 0 }
  -> t:Attribute lst:Attributes      { fst3 t :: fst lst, trd3 t + snd lst }
}

nonterm(Cabs.attribute list * int) AttributesWithASM {
  -> empty			   		 { [], 0 }
  -> a:Attribute rest:AttributesWithASM { (fst3 a) :: fst rest, trd3 a + snd rest }
  -> ASM "(" s:StringConstant ")" aas:Attributes 
                                        { ("__asm__", 
					   [CONSTANT(CONST_STRING (fst s))]) :: (fst aas), snd aas }

}

nonterm(Cabs.attribute * cabsloc * int ) AttributeNoCV {
  -> a:ATTRIBUTE "(" ps:AttrList ")"
                                        { ("__attribute__", fst ps), a, snd ps }
  -> d:DECLSPEC "(" p:AttrListNE ")"       { ("__declspec", fst p), d, snd p }
  -> m:MSATTR                           { (fst m, []), snd m,0 }
                                        /* ISO 6.7.3 */
  -> t:THREAD                              { ("__thread",[]), t,0 }
}

nonterm(Cabs.attribute list * int) AttributeNoCVList {
  -> empty 	   					 { [], 0}
  -> a:AttributeNoCV aas:AttributeNoCVList  { (fst3 a) :: (fst aas), trd3 a + snd aas }
}

/* __attribute__ plus const/volatile */
nonterm (Cabs.attribute * cabsloc * int) Attribute {
  -> a:AttributeNoCV 	 		   { a }
  -> c:CONST                       { ("const", []), c,0 }
  -> r:RESTRICT                    { ("restrict",[]), r,0 }
  -> v:VOLATILE                    { ("volatile",[]), v,0 }
}

/* (* sm: I need something that just includes __attribute__ and nothing more,
 *  to support them appearing between the 'struct' keyword and the type name. 
 * Actually, a declspec can appear there as well (on MSVC) *)  */
nonterm (Cabs.attribute * int) JustAttribute {
  -> ATTRIBUTE "(" ps:AttrList")"
                                        { ("__attribute__", fst ps), snd ps }
  -> DECLSPEC "(" ps:AttrListNE ")"    { ("__declspec", fst ps), snd ps }
}

/* this can't be empty, b/c I folded that possibility into the calling
 * productions to avoid some S/R conflicts */
nonterm (Cabs.attribute list * int) JustAttributes {
  -> j:JustAttribute                      { [fst j], snd j }
  -> j:JustAttribute js:JustAttributes    { fst j :: fst js, add_e2 j js }
}

/** (* PRAGMAS and ATTRIBUTES *) ***/
nonterm(Cabs.definition * int) Pragma {
  -> p:PRAGMA a:Attr PRAGMA_EOL		{ PRAGMA (fst a, p), snd a }
  -> p:PRAGMA a:Attr ";" PRAGMA_EOL	{ PRAGMA (fst a, p), snd a }
  -> p:PRAGMA_LINE                  { PRAGMA (VARIABLE (fst p), snd p), 0 }
}

/* (* We want to allow certain strange things that occur in pragmas, so we 
    * cannot use directly the language of expressions *) */ 
nonterm(Cabs.expression * int) PrimaryAttr {
  -> v:IDENT				    { VARIABLE (fst v), 0 }
    /*(* The NAMED_TYPE here creates conflicts with IDENT *)*/
  -> t:NAMED_TYPE				{ VARIABLE (fst t), 0 } 
  -> "(" a:Attr ")"             { fst a, snd a } 
  -> a:IDENT b:IDENT            { CALL(VARIABLE (fst a), [VARIABLE (fst b)]), 0 }
  -> i:CST_INT                  { CONSTANT(CONST_INT (fst i)), 0 } 
  -> sc:StringConstant          { CONSTANT(CONST_STRING (fst sc)), 0 }
                                  /*(* Const when it appears in 
                                   * attribute lists, is translated 
                                   * to aconst *)*/
  -> CONST                    { VARIABLE "aconst",0 }

  -> i:IDENT ":" ci:CST_INT     { VARIABLE (fst i ^ ":" ^ fst ci),0 }

/*(* The following rule conflicts with the ? : attributes. We give it a very 
   * low priority *)*/ 
  -> ci:CST_INT ":" ci2:CST_INT { VARIABLE (fst ci ^ ":" ^ fst ci2),0 } 

  -> DEFAULT ":" ci:CST_INT   { VARIABLE ("default:" ^ fst ci),0 }
                          
                                /*(** GCC allows this as an 
                                 * attribute for functions, 
                                 * synonym for noreturn **)*/
  -> VOLATILE                 { VARIABLE ("__noreturn__"),0 }
}

nonterm(Cabs.expression * int) PostfixAttr { 
  -> p:PrimaryAttr				         { p }
                                         /* (* use a VARIABLE "" so that the 
                                             * parentheses are printed *) */
  -> i:IDENT "(" ")"                     { CALL(VARIABLE (fst i), [VARIABLE ""]), 0 }
  -> i:IDENT "(" ps:AttrListNE ")" 		 { CALL(VARIABLE (fst i), fst ps), snd ps }
  -> p:PostfixAttr "->" a:IdOrTypeName   {MEMBEROFPTR (fst p, a), snd p} 
  -> p:PostfixAttr "." a:IdOrTypeName    {MEMBEROF (fst p, a), snd p}
  -> p:PostfixAttr "[" a:Attr "]"        {INDEX (fst p, fst a), add_e2 p a }
}

/*(* Since in attributes we use both IDENT and NAMED_TYPE as indentifiers, 
 * that leads to conflicts for SIZEOF and ALIGNOF. In those cases we require 
 * that their arguments be expressions, not attributes *)*/
nonterm (Cabs.expression * int) UnaryAttr {
  -> p:PostfixAttr                         { p }
  -> "sizeof" e:UnaryExpression            {EXPR_SIZEOF (fst3 e), trd3 e }
  -> "sizeof" "(" t:TypeName ")"
		                                   { let b, d, err = t in TYPE_SIZEOF (b, d), err}
  -> "alignof" e:UnaryExpression           { EXPR_ALIGNOF (fst3 e),trd3 e }
  -> "alignof" "(" t:TypeName ")"          { let b, d, err = t in TYPE_ALIGNOF (b, d), err}
  -> "+" ea:CastAttr                       { UNARY (PLUS, fst ea), snd ea}
  -> "-" ea:CastAttr                       { UNARY (MINUS, fst ea), snd ea}
  -> "*" ea:CastAttr		               {UNARY (MEMOF, fst ea), snd ea}
  -> "&" ea:CastAttr                       {UNARY (ADDROF, fst ea), snd ea}
  -> "!" ea:CastAttr    	               {UNARY (NOT, fst ea), snd ea}
  -> "~" ea:CastAttr                       {UNARY (BNOT, fst ea), snd ea}
}

nonterm (Cabs.expression * int) CastAttr {
  -> ca:UnaryAttr		  		   { ca }
}

nonterm (Cabs.expression * int) BinaryAttr {
  -> e:CastAttr			  			    { e }
  -> ua1:BinaryAttr "*" ua2:BinaryAttr  {BINARY(MUL, fst ua1, fst ua2), add_e2 ua1 ua2}
  -> ua1:BinaryAttr "/" ua2:BinaryAttr	{BINARY(DIV, fst ua1, fst ua2), add_e2 ua1 ua2}
  -> ua1:BinaryAttr "%" ua2:BinaryAttr  {BINARY(MOD, fst ua1, fst ua2), add_e2 ua1 ua2}
  -> ua1:BinaryAttr "+" ua2:BinaryAttr  {BINARY(ADD, fst ua1, fst ua2), add_e2 ua1 ua2} 
  -> ua1:BinaryAttr "-" ua2:BinaryAttr  {BINARY(SUB, fst ua1, fst ua2), add_e2 ua1 ua2}
  -> ua1:BinaryAttr "<<" ua2:BinaryAttr {BINARY(SHL, fst ua1, fst ua2), add_e2 ua1 ua2}
  -> ua1:BinaryAttr ">>" ua2:BinaryAttr {BINARY(SHR, fst ua1, fst ua2), add_e2 ua1 ua2}
  -> ua1:BinaryAttr "<" ua2:BinaryAttr  {BINARY(LT, fst ua1, fst ua2), add_e2 ua1 ua2}
  -> ua1:BinaryAttr ">" ua2:BinaryAttr  {BINARY(GT, fst ua1, fst ua2), add_e2 ua1 ua2}
  -> ua1:BinaryAttr "<=" ua2:BinaryAttr {BINARY(LE, fst ua1, fst ua2), add_e2 ua1 ua2}
  -> ua1:BinaryAttr ">=" ua2:BinaryAttr {BINARY(GE, fst ua1, fst ua2), add_e2 ua1 ua2}
  -> ua1:BinaryAttr "==" ua2:BinaryAttr {BINARY(EQ, fst ua1, fst ua2), add_e2 ua1 ua2}
  -> ua1:BinaryAttr "!=" ua2:BinaryAttr {BINARY(NE, fst ua1, fst ua2), add_e2 ua1 ua2}
  -> ua1:BinaryAttr "&" ua2:BinaryAttr  {BINARY(BAND, fst ua1, fst ua2), add_e2 ua1 ua2}
  -> ua1:BinaryAttr "^" ua2:BinaryAttr  {BINARY(XOR, fst ua1, fst ua2), add_e2 ua1 ua2}
  -> ua1:BinaryAttr "|" ua2:BinaryAttr  {BINARY(BOR, fst ua1, fst ua2), add_e2 ua1 ua2}
  -> ua1:BinaryAttr "&&" ua2:BinaryAttr {BINARY(AND, fst ua1, fst ua2), add_e2 ua1 ua2}
  -> ua1:BinaryAttr "||" ua2:BinaryAttr {BINARY(OR, fst ua1, fst ua2), add_e2 ua1 ua2}
}

nonterm (Cabs.expression * int) ConditionalAttr {
  -> a:BinaryAttr							{ a }
/* This is in conflict for now */
  -> ua1:BinaryAttr "?" ua2:ConditionalAttr ":" ua3:ConditionalAttr
                                          { QUESTION(fst ua1, fst ua2, fst ua3), snd ua1 + snd ua2 + snd ua3 }
}

nonterm(Cabs.expression * int) Attr {
  -> u:ConditionalAttr		 	  { u }
}

nonterm(Cabs.expression list * int) AttrListNE {
  -> a:Attr                                  { [fst a], snd a }
  -> a:Attr "," lst:AttrListNE               { (fst a) :: (fst lst), add_e2 a lst }
} 

nonterm(Cabs.expression list * int) AttrList {
  -> empty                             { [], 0 }
  -> lst:AttrListNE                    { lst }
}

/*** GCC ASM instructions ***/
nonterm(Cabs.attribute list) ASMAttr { 
  -> empty	                           { [] }
  -> VOLATILE a:ASMAttr                  { ("volatile", []) :: a }
  -> CONST a:ASMAttr                      { ("const", []) :: a } 
}

nonterm(string list) ASMTemplate {
  -> o:OneStringConstant                          { [o] }
  -> o:OneStringConstant a:ASMTemplate            { o :: a }
}

nonterm(Cabs.asm_details option * int) ASMOutputs { 
  -> empty           { None, 0 }
  -> ":" os:ASMOperands ai:ASMInputs 
                        { let (ins, clobs, err1) = ai in
                          Some {aoutputs = fst os; ainputs = ins; aclobbers = clobs}, snd os + err1}
}

nonterm((string option * string * expression) list * int) ASMOperands { 
  -> empty 	   			   	 { [],0 } 
  -> ao:ASMOperandsNE        { List.rev (fst ao), snd ao }
}

nonterm((string option * string * expression) list * int) ASMOperandsNE {
  -> ao:ASMOperand                            { [triple4 ao], frth4 ao }
  -> lst:ASMOperandsNE "," ao:ASMOperand  { (triple4 ao) :: (fst lst), snd lst + frth4 ao }
}

nonterm(string option * string * expression * int) ASMOperand {
  -> name:ASMOpName sc:StringConstant "(" e:Expression ")"    { name, fst sc, fst3 e, trd3 e }
}

nonterm((string option * string * expression) list * string list * int) ASMInputs {
  -> empty                { ([], [], 0) }
  -> ":" ao:ASMOperands ac:ASMClobber
                        { fst ao, ac, snd ao }
}

nonterm(string option) ASMOpName {
  -> empty                         { None }
  -> "[" i:IDENT "]"             { Some (fst i) }
}

nonterm(string list) ASMClobber {
  -> empty                         { [] }
  -> ":" lst:ASMCloberLstNE                 { lst }
}

nonterm(string list) ASMCloberLstNE {
  -> osc:OneStringConstant                           { [osc] }
  -> osc:OneStringConstant "," lst:ASMCloberLstNE     { osc :: lst }
}