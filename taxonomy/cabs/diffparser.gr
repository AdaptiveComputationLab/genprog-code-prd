/*
 * Elkhound Grammar for an OCaml parser for C
 *
 * Author: CLG
 * Date: November 22, 2010
 * Based on jabs, cil's frontc, and Scott McPeak's C++ parser. 
 * I sense that this is going to suck.
 */

/* option lang_OCaml; */

context_class diffParser {
public:

};

verbatim {
open Cabs
open Cabshelper

let empty_block = { blabels = []; battrs = []; bstmts = [] }

let parse_error msg : unit =       (* sm: c++-mode highlight hack: -> ' <- *)
  failwith msg

let print = print_string

let cabslu = {lineno = -10; 
	      filename = "cabs loc unknown"; 
	      byteno = -10;
              ident = 0;}

(*
** Expression building
*)

let pair3 (one,two,_) = one,two
let triple4 (one,two,three,_) = one,two,three
let fst3 (result, _, _) = result
let snd3 (_, result, _) = result
let trd3 (_, _, result) = result
let add_e2 a b = (snd a) + (snd b)
let add_e3 a b = (trd3 a) + (trd3 b)
let fst4 (result,_,_,_) = result
let snd4 (_,result,_,_) = result
let trd4 (_,_,result,_) = result
let frth4 (_,_,_,result) = result
 
let smooth_expression lst =
  match lst with
    [] -> nd(NOTHING)
  | [expr] -> expr
  | _ -> nd(COMMA (lst))

let applyPointer (ptspecs: attribute list list) (dt: decl_type)  
       : decl_type = 
  (* Outer specification first *)
  let rec loop = function
      [] -> dt
    | attrs :: rest -> PTR(attrs, loop rest)
  in
  loop ptspecs

let doDeclaration (loc: cabsloc) (specs: specifier) (nl: init_name list) : definition node = 
  if isTypedef specs then begin
    (* Tell the lexer about the new type names *)
        List.iter (fun sn -> 
				     let (namenode,_) = sn in 
					 let an = fst4 namenode in 
					 	 !Lexerhack.add_identifier an) nl;
    nd(TYPEDEF ((specs, List.map (fun nde -> let (n, _) = nde in n) nl), loc))
  end else
    if nl = [] then
      nd(ONLYTYPEDEF (specs, loc))
    else begin
      (* Tell the lexer about the new variable names *)
        List.iter (fun sn -> 
				     let (namenode,_) =  sn in 
					 let an = fst4 namenode in 
					 	 !Lexerhack.add_identifier an) nl;
      nd(DECDEF ((specs, nl), loc))
    end

let doFunctionDef (loc: cabsloc)
                  (lend: cabsloc)
                  (specs: specifier) 
                  (n: name) 
                  (b: block) : definition node = 
  let fname = (specs, n) in
  nd(FUNDEF (fname, b, loc, lend))

let doOldParDecl (names: string list)
                 ((pardefs: name_group list), (isva: bool)) 
    : single_name list * bool =
  let findOneName (n : string) : single_name =
    (* Search in pardefs for the definition for this parameter *)
    let rec loopGroups (lst : name_group list) : single_name =
	  match lst with
        [] -> [SpecType (Tint)], (n, JUSTBASE, [], cabslu)
      | node :: restgroups ->
	    let (specs, names) = node in
          let rec loopNames (names : name list) : single_name = 
		     match names with
              [] -> loopGroups restgroups
			| sn :: restnames ->
			   let (n',_,_,_) = sn in
			     if n' = n then (specs, sn) 
			   else loopNames restnames
          in
          loopNames names
    in
    loopGroups pardefs
  in
  let args = List.map findOneName names in
  (args, isva)

let checkConnective (s : string) : unit =
begin
  (* checking this means I could possibly have more connectives, with *)
  (* different meaning *)
  if (s <> "to") then (
    parse_error "transformer connective must be 'to'";
    raise Parsing.Parse_error
  )
  else ()
end

let int64_to_char value =
  if (compare value (Int64.of_int 255) > 0) || (compare value Int64.zero < 0) then
    begin
      let msg = Printf.sprintf "cparser:intlist_to_string: character 0x%Lx too big" value in
      parse_error msg;
      raise Parsing.Parse_error
    end
  else
    Char.chr (Int64.to_int value)

(* takes a not-nul-terminated list, and converts it to a string. *)
let rec intlist_to_string (str: int64 list):string =
  match str with
    [] -> ""  (* add nul-termination *)
  | value::rest ->
      let this_char = int64_to_char value in
      (String.make 1 this_char) ^ (intlist_to_string rest)

(*
   transform:  __builtin_offsetof(type, member)
   into     :  (size_t) (&(type * ) 0)->member
 *)

let transformOffsetOf (speclist, dtype) member =
  let rec addPointer d = 
     match d with
    | JUSTBASE -> PTR([], JUSTBASE)
    | PARENTYPE (attrs1, dtype, attrs2) -> PARENTYPE (attrs1, addPointer dtype, attrs2)
    | ARRAY (dtype, attrs, expr) -> ARRAY (addPointer dtype, attrs, expr)
    | PTR (attrs, dtype) -> PTR (attrs, addPointer dtype)
    | PROTO (dtype, names, variadic) -> PROTO (addPointer dtype, names, variadic)
  in
  let nullType = (speclist, addPointer dtype) in
  let nullExpr = nd(CONSTANT (CONST_INT "0")) in
  let castExpr = nd(CAST (nullType, SINGLE_INIT nullExpr)) in

  let rec replaceBase (b : Cabs.expression node) = 
     match (dn b) with
    | VARIABLE field ->  nd(MEMBEROFPTR (castExpr, field))
    | MEMBEROF (base, field) ->  nd(MEMBEROF (replaceBase base, field))
    | INDEX (base, index) -> nd(INDEX (replaceBase base, index))
    | _ ->
	parse_error "malformed offset expression in __builtin_offsetof";
        raise Parsing.Parse_error 
  in
  let memberExpr = replaceBase member in
  let addrExpr = nd(UNARY (ADDROF, memberExpr)) in
  (* slight cheat: hard-coded assumption that size_t == unsigned int *)
  let sizeofType = [SpecType (Tunsigned)], JUSTBASE in
  let resultExpr = CAST (sizeofType, SINGLE_INIT addrExpr) in
  nd resultExpr
}

terminals {
include(c.tok)

precedence {
    // high precedence
    prec  200 PREFER_REDUCE;
	left  190 IDENT;
	right 185  NAMED_TYPE;    /* We'll use this to handle redefinitions of
                              * NAMED_TYPE as variables */
	left 90 "." "->" "(" "{";
	left 85	"[";
    right 82 "sizeof" "alignof" TYPEOF;
	right 80 ")" "!" "~" "++" "--" ;
	left 75 "*" "/" "%" "const" "restrict" "volatile";
	left 70 "+" "-";
	left 65 ">>" "<<";
	left 60 ">" "<" "<=" ">=";
	left 55 "==" "!=";
	left 50 "&";
	left 45 "^";
	left 40 "|";
	left 35 "&&";
	left 30 "||";
	right 25 "?" ":";
	right 20  "=" "+=" "-=" "*=" "/=" "%=" "&=" "|=" "^=" ">>=" "<<=" ;
	left 15 ",";
	nonassoc 10 "else";
	nonassoc 5 	"if";
    prec    1 PREFER_SHIFT;
  }

}

// now: non-terminals
//nonterm(Cabs.tree_node  list * int) File ->  t:TreeNodes r:RandomTokens { t }
nonterm(Cabs.tree_node node list * int) File {
  ->  t:TreeNodes { t }
  -> empty { [], 0 }
}

//include(partial.gr)
// ---------------- higher-level syntax -----------------
// the section labels that follow (like "A.3") are from the
// C++ standard document (should track down a proper reference..)

// ------ A.3 Basic Concepts ------

nonterm(Cabs.tree_node node list * int) TreeNodes {
  -> gs:GlobalsNE
		    { [nd(Globals(fst gs))], snd gs }
}

nonterm(Cabs.directive node * cabsloc * int) Directive {
  -> p:PREINCLUDE s:StringConstant
  	 		{ nd(PREINCLUDE(fst3 s,p)), p, 1 + trd3 s }
  -> p:PREINCLUDE "<" s:StringConstant ">"
  	 		{ nd(PREINCLUDE(fst3 s,p)), p, 1 + trd3 s }
  -> p:PREINCLUDE "<" t:QualifiedType ">"
  	 		{ nd(PREINCLUDE(fst t,p)), p, 1 + snd t }

  -> p1:PREIFNDEF e1:Expression e2:Expression PREENDIF
            { nd(PREIFNDEF(fst3 e1, MACEXP([fst3 e2]),MACEMPTY, p1)), p1, trd3 e1 + trd3 e2 + 2}
  -> p1:PREIFNDEF e1:Expression e2:BlockElementList PREENDIF
// covers the empty e2 case
            { nd(PREIFNDEF(fst3 e1, MACSTMT(fst e2),MACEMPTY, p1)), p1, trd3 e1 + snd e2 + 2 }
  -> p1:PREIFNDEF e1:Expression e2:GlobalsNE PREENDIF
            { nd(PREIFNDEF(fst3 e1, MACDEF(fst e2),MACEMPTY, p1)), p1, trd3 e1 + snd e2 + 2 }

  -> p1:PREIFNDEF e1:Expression e2:Expression ei:ElseIf PREENDIF
            { nd(PREIFNDEF(fst3 e1, MACEXP([fst3 e2]),fst ei, p1)), p1, trd3 e1 + trd3 e2 + snd ei + 2 }
  -> p1:PREIFNDEF e1:Expression e2:BlockElementList ei:ElseIf PREENDIF
            { nd(PREIFNDEF(fst3 e1, MACSTMT(fst e2),fst ei, p1)), p1, trd3 e1 + snd e2 + snd ei + 2 }
  -> p1:PREIFNDEF e1:Expression e2:GlobalsNE ei:ElseIf PREENDIF
            { nd(PREIFNDEF(fst3 e1, MACDEF(fst e2), fst ei, p1)), p1, trd3 e1 + snd e2 + snd ei + 2 }

  -> p1:PREIF e1:Expression e2:Expression PREENDIF
            { nd(PREIF(fst3 e1, MACEXP([fst3 e2]), MACEMPTY, p1)), p1, trd3 e1 + trd3 e2 + 2 }
  -> p1:PREIF e1:Expression e2:BlockElementList PREENDIF
            { nd(PREIF(fst3 e1, MACSTMT(fst e2), MACEMPTY, p1)), p1, trd3 e1 + snd e2 + 2 }
  -> p1:PREIF e1:Expression e2:GlobalsNE PREENDIF
            { nd(PREIF(fst3 e1, MACDEF(fst e2), MACEMPTY, p1)), p1, trd3 e1 + snd e2 + 2}

  -> p1:PREIF e1:Expression e2:Expression ei:ElseIf PREENDIF
            { nd(PREIF(fst3 e1, MACEXP([fst3 e2]), fst ei, p1)), p1, trd3 e1 + trd3 e2 + snd ei + 2 }
  -> p1:PREIF e1:Expression e2:BlockElementList ei:ElseIf PREENDIF
            { nd(PREIF(fst3 e1, MACSTMT(fst e2), fst ei, p1)), p1, trd3 e1 + snd e2 + snd ei + 2 }
  -> p1:PREIF e1:Expression e2:GlobalsNE ei:ElseIf PREENDIF
            { nd(PREIF(fst3 e1, MACDEF(fst e2), fst ei, p1)), p1, trd3 e1 + snd e2 + snd ei + 2 }

  -> p:PREDEFINE e:Expression s:Statement
            { nd(PREDEFINE(fst3 e, [], MACSTMT([fst s]),p)), p, 3 + snd s + trd3 e }
  -> p:PREDEFINE i:IDENT precedence(PREFER_SHIFT)
            { nd(PREDEFINE(nd(VARIABLE(fst i)), [], MACEMPTY,p)), p, 3 }

  -> p:PREDEFINE e1:Expression e2:Expression precedence(PREFER_SHIFT)
            { nd(PREDEFINE(fst3 e1, [], MACEXP([fst3 e2]), p)), p, 3 }
  -> p:PREDEFINE i:IDENT "(" ce:CommaExpression ")" s:Statement
   { nd(PREDEFINE(nd(VARIABLE(fst i)), fst3 ce, MACSTMT([fst s]),  p)), p, 3 + trd3 ce + snd s + 2 }
  -> p:PREPASTE
            { nd(PREPASTE(p)), p, 1 }
 -> p:PREUNDEF i:IDENT
 	 { nd(PREUNDEF(nd(VARIABLE(fst i)), p)), p, 2 }
}

nonterm (Cabs.macro * int )  ElseIf {
  -> PREELSE bs:BlockElementList
  	 			{ MACSTMT(fst bs), snd bs + 1 }
  -> PREELSE bs:Expression 
  	 			{ MACEXP([fst3 bs]),trd3 bs + 1 }
  -> PREELSE bs:GlobalsNE
  	 			{ MACDEF(fst bs), snd bs+ 1 }
  -> p1:PREELSEIF e:Expression bs:BlockElementList p:ElseIf
  	 			{ MACDIR(nd(PREIF(fst3 e, MACSTMT(fst bs), fst p, p1))), trd3 e + snd bs + snd p + 1 }
  -> p1:PREELSEIF e:Expression bs:Expression p:ElseIf
  	 			{ MACDIR(nd(PREIF(fst3 e, MACEXP([fst3 bs]), fst p, p1))), trd3 e + trd3 bs + snd p + 1 }
  -> p1:PREELSEIF e:Expression bs:GlobalsNE p:ElseIf
  	 			{ MACDIR(nd(PREIF(fst3 e, MACDEF(fst bs), fst p, p1))), trd3 e + snd bs + snd p + 1 }
  -> p1:PREELSEIF e:Expression bs:BlockElementList
  	 			{ MACDIR(nd(PREIF(fst3 e, MACSTMT(fst bs), MACEMPTY, p1))), trd3 e + snd bs + 1 }
  -> p1:PREELSEIF e:Expression bs:Expression 
  	 			{ MACDIR(nd(PREIF(fst3 e, MACEXP([fst3 bs]), MACEMPTY, p1))), trd3 e + trd3 bs + 1 }
  -> p1:PREELSEIF e:Expression bs:GlobalsNE
  	 			{ MACDIR(nd(PREIF(fst3 e, MACDEF(fst bs), MACEMPTY, p1))), trd3 e + snd bs + 1 }
}

nonterm(string * int) QualifiedType {
  -> i:IDENT 
  	   { fst i, 1 }
  -> t1:QualifiedType "." t2:QualifiedType 
       { (fst t1) ^ "." ^ (fst t2), (snd t1) + (snd t2) + 1 }
  -> t1:QualifiedType "/" t2:QualifiedType
       { (fst t1) ^ "/" ^ (fst t2), (snd t1) + (snd t2) + 1 }

}
nonterm(unit) RandomTokens {
  -> empty  { () }
  -> RandomToken RandomTokens { () }
}
nonterm(unit) RandomToken {
  -> EQ 	  { () }
  -> PLUS_EQ  { () }
  -> MINUS_EQ 	{ () }
  -> STAR_EQ 	{ () }
  -> SLASH_EQ 	{ () }
  -> PERCENT_EQ   { () }
  -> AND_EQ 	  { () }
  -> PIPE_EQ 	  { () }
  -> CIRC_EQ 	  { () }
  -> INF_INF_EQ   { () }
  -> SUP_SUP_EQ   { () }
  -> ARROW	  { () }
  -> DOT		  { () }
  -> EQ_EQ 		  { () }
  -> EXCLAM_EQ 	  { () }
  -> INF 		  { () }
  -> SUP 		  { () }
  -> INF_EQ 	  { () }
  -> SUP_EQ 	  { () }
  -> SLASH 		  { () }
  -> PERCENT 	  { () }
  -> PIPE 		  { () }
  -> CIRC 		  { () }
  -> PIPE_PIPE 	  { () }
  -> INF_INF 	  { () }
  -> SUP_SUP 	  { () }
  -> RPAREN	  { () }
  -> LBRACKET  { () }
  -> RBRACKET  { () }
  -> COLON { () }
  -> COMMA { () }
  -> ELLIPSIS 	{ () }
  -> QUEST 		{ () }
  -> ELSE	{ () }
  -> LABEL__ 	{ () }
  -> BUILTIN_VA_LIST	{ () }
  -> BLOCKATTRIBUTE 	{ () }
  -> PRAGMA_EOL		{ () }
  -> AT_NAME 	{ () }
  -> IDENT	{ () }
  -> CST_CHAR  { () }
  -> CST_WCHAR { () }
  -> CST_INT	  { () }
  -> CST_FLOAT { () }
  -> NAMED_TYPE	{ () }
  -> CST_STRING	{ () }
  -> CST_WSTRING	{ () }
  -> CHAR	 { () }
  -> INT		 { () }
  -> DOUBLE	 { () }
  -> FLOAT	 { () }
  -> VOID	 { () }
  -> INT64	 { () }
  -> INT32	 { () }
  -> ENUM	 { () }
  -> STRUCT	 { () }
  -> TYPEDEF	 { () }
  -> UNION	 { () }
  -> SIGNED	 { () }
  -> UNSIGNED { () }
  -> LONG  { () }
  -> SHORT { () }
  -> VOLATILE   { () }
  -> EXTERN	   { () }
  -> STATIC	   { () }
  -> CONST	   { () }
  -> RESTRICT   { () }
  -> AUTO  { () }
  -> REGISTER   { () }
  -> THREAD	   { () }
  -> SIZEOF	   { () }
  -> ALIGNOF	   { () }
  -> PLUS { () }
  -> MINUS  { () }
  -> STAR   { () }
  -> TILDE  { () }
  -> AND	   { () }
  -> EXCLAM { () }
  -> AND_AND	 { () }
  -> PLUS_PLUS  { () }
  -> MINUS_MINUS	 { () }
  -> LPAREN	 { () }
  -> RBRACE	 { () }
  -> LBRACE	 { () }
  -> SEMICOLON  { () }
  -> BREAK  { () }
  -> CONTINUE { () }
  -> GOTO  { () }
  -> RETURN	{ () }
  -> SWITCH	{ () }
  -> CASE	{ () }
  -> DEFAULT	{ () }
  -> WHILE	{ () }
  -> DO { () }
  -> FOR	 { () }
  -> IF	 { () }
  -> TRY	 { () }
  -> EXCEPT { () }
  -> FINALLY	 { () }
  -> ATTRIBUTE  { () }
  -> INLINE { () }
  -> ASM	{ () }
  -> TYPEOF	 { () }
  -> FUNCTION__ { () }
  -> PRETTY_FUNCTION__		{ () }
  -> BUILTIN_VA_ARG { () }
  -> ATTRIBUTE_USED 	 { () }
  -> BUILTIN_TYPES_COMPAT  { () }
  -> BUILTIN_OFFSETOF  { () }
  -> DECLSPEC	  { () }
  -> MSASM { () }
  -> MSATTR	{ () }
  -> PRAGMA_LINE	 { () }
  -> PRAGMA	 { () }
  -> AT_TRANSFORM  { () }
  -> AT_TRANSFORMEXPR   { () }
  -> AT_SPECIFIER  { () }
  -> AT_EXPR 	  { () }
}

nonterm(Cabs.expression node list * int) Expressions {
  -> empty  { [], 0 }
  -> e:Expression es:Expressions 
            { fst3 e :: fst es, trd3 e + snd es }
}

nonterm(Cabs.expression node list * int) ExpressionsNE {
  -> e:Expression es:Expressions 
            { fst3 e :: fst es, trd3 e + snd es }
}

nonterm(Cabs.statement node list * int) Statements {
  -> empty  { [], 0 }
  -> s:Statement ss:Statements
            { fst s :: fst ss, snd s + snd ss }
}

nonterm(Cabs.statement node list * int) StatementsNE {
  -> s:Statement ss:Statements
            { fst s :: fst ss, snd s + snd ss }
}

nonterm(Cabs.definition node list * int) Globals {
  -> empty	{ [],0 }
  -> g:Global gs:Globals
 			{ fst g :: fst gs, snd g + snd gs }
  -> ";" gs:Globals
			{ gs }
}

nonterm(Cabs.definition node list * int) GlobalsNE {
  -> g:Global gs:Globals
 			{ fst g :: fst gs, snd g + snd gs }
  -> ";" gs:Globals
			{ gs }
}

nonterm(Cabs.definition node * int) Global {
  -> d:Directive 
            { nd(DIRECTIVE(fst3 d)), trd3 d }
  -> d:Declaration				     { d }
  -> e:ExternDeclaration 			 { e } 
  -> f:FunctionDefinition			 { f }
  -> a:ASM "(" sc:StringConstant ")" ";"		   { nd(GLOBASM(fst3 sc, a)), trd3 sc + 4 }
  -> p:Pragma  					 	 			   { p }
}

nonterm(Cabs.definition node * int) ExternDeclaration {
  -> "extern" s:StringConstant d:Declaration      { nd(LINKAGE (fst3 s, snd3 s, [fst d])), snd d + trd3 s + 1 }
  -> "extern" s:StringConstant "{" t:Globals "}"  { nd(LINKAGE (fst3 s, snd3 s, fst t)), snd t + trd3 s + 3 }
}

// ------------- identifier ambiguity -------------------
// identifiers can play two primary roles, and this is the
// source of problems parsing C and C++
// name of a type; introduced by class, struct, union, enum, typedef

// names for situations where it does not matter what its previous
// meaning may have been
nonterm(string * int) IdOrTypeName {
  -> n:IDENT  	      { fst n, 1 } 	       
  -> n:NAMED_TYPE     { fst n, 1 }
  -> AT_NAME "(" n:IDENT ")"         { "@name("^ fst n ^")", 4 }
}

nonterm(int) MaybeComma {
  -> empty	   			{ 0 }
  -> ","				{ 1 }
}

// ------ A.4 Expressions ------
nonterm(Cabs.expression node * cabsloc * int) PrimaryExpression {
  -> n:IDENT
            { nd(VARIABLE(fst n)),snd n, 1 } 
  -> e:Constant  
            { nd(CONSTANT(fst3 e)),snd3 e, trd3 e }
  -> e:ParenCommaExpression
            { nd(PAREN (smooth_expression(fst3 e))), snd3 e, trd3 e + 2 }
  -> l:LBRACE b:Block "}" 
            { nd(GNU_BODY(fst4 b)), l, frth4 b + 2 }
  -> a:AT_EXPR "(" v:IDENT ")" 
            { nd(EXPR_PATTERN(fst v)), a, 4 }
}

nonterm(Cabs.expression node * cabsloc * int) PostfixExpression {
  -> e:PrimaryExpression  { e }

  // array access
  -> a:PostfixExpression "[" e:CommaExpression "]"
            { nd(INDEX (fst3 a, smooth_expression (fst3 e))), snd3 a, trd3 e + trd3 a + 2 }

  // fn call
  -> f:PostfixExpression "(" e:Arguments ")"
             { nd(CALL (fst3 f, fst e)), snd3 f, trd3 f + snd e + 2  }
  -> bu:BUILTIN_VA_ARG "(" e:Expression "," t:TypeName ")"
                        { let b, d, count = t in
                          nd(CALL (nd(VARIABLE "__builtin_va_arg"),
                                [fst3 e; nd(TYPE_SIZEOF (b, d))])), bu, count + trd3 e + 4 }
  -> b:BUILTIN_TYPES_COMPAT "(" t1:TypeName "," t2:TypeName ")"
                        { let b1,d1,count1 = t1 in
                          let b2,d2,count2 = t2 in
                          nd(CALL (nd(VARIABLE "__builtin_types_compatible_p"), 
                                [nd(TYPE_SIZEOF(b1,d1)); nd(TYPE_SIZEOF(b2,d2))])), b, count1 + count2 + 4 }
  -> b:BUILTIN_OFFSETOF "(" t:TypeName "," o:OffsetofMemberDesignator ")"
                        { transformOffsetOf (pair3 t) (fst o), b, trd3 t + snd o + 4 }
  // field access
  -> p:PostfixExpression "."  n:IdOrTypeName 
       { nd(MEMBEROF (fst3 p, fst n)), snd3 p, trd3 p + snd n + 1 } 

  // deref + field access
  -> p:PostfixExpression "->" n:IdOrTypeName
       { nd(MEMBEROFPTR (fst3 p, fst n)), snd3 p, trd3 p + snd n + 1}

  -> p:PostfixExpression "++"
       { nd(UNARY (POSINCR, fst3 p)), snd3 p, trd3 p + 1 }
  -> p:PostfixExpression "--"
       { nd(UNARY (POSDECR, fst3 p)), snd3 p, trd3 p + 1}
  -> "(" t:TypeName ")" l:LBRACE lst:InitializerListOpt "}"
		        { nd(CAST( pair3 t, COMPOUND_INIT (fst lst))), l, trd3 t + snd lst + 4 }
}

nonterm(Cabs.expression node * int) OffsetofMemberDesignator {	/* GCC extension for __builtin_offsetof */
  -> v:IdOrTypeName
            { nd(VARIABLE (fst v)), snd v }
  -> lst:OffsetofMemberDesignator "." v:IDENT  
            { nd(MEMBEROF (fst lst, fst v)), snd lst + 2 }
  -> lst:OffsetofMemberDesignator "[" c:CommaExpression "]"
            { nd(INDEX (fst lst,smooth_expression (fst3 c))), snd lst + trd3 c + 2 }
}

nonterm(Cabs.expression node * cabsloc * int) UnaryExpression {
  -> e:PostfixExpression                 { e }
  -> p:PLUS_PLUS e:UnaryExpression       { nd(UNARY (PREINCR, fst3 e)), p, trd3 e + 1 }
  -> m:MINUS_MINUS e:UnaryExpression     { nd(UNARY (PREDECR, fst3 e)), m, trd3 e + 1  }
  -> s:SIZEOF e:UnaryExpression          { nd(EXPR_SIZEOF(fst3 e)), s, trd3 e + 1 }
  -> s:SIZEOF "(" t:TypeName ")"         { let b, d, count = t in nd(TYPE_SIZEOF (b,d)), s, count + 3 }
  -> a:ALIGNOF u:UnaryExpression         { nd(EXPR_ALIGNOF (fst3 u)), a, trd3 u + 1 }
  -> a:ALIGNOF "(" t:TypeName ")"	     { let b, d, count = t in nd(TYPE_ALIGNOF (b,d)), a, count + 3 }
  -> p:PLUS e:CastExpression             { nd(UNARY (PLUS, fst3 e)), p, trd3 e + 1 }
  -> m:MINUS e:CastExpression            { nd(UNARY (MINUS, fst3 e)), m, trd3 e + 1 }
  -> s:STAR e:CastExpression             { nd(UNARY (MEMOF, fst3 e)), s, trd3 e + 1 }
  -> a:AND e:CastExpression              { nd(UNARY (ADDROF, fst3 e)), a, trd3 e + 1 }
  -> x:EXCLAM e:CastExpression           { nd(UNARY (NOT, fst3 e)), x, trd3 e + 1 }
  -> t:TILDE e:CastExpression            { nd(UNARY (BNOT, fst3 e)), t, trd3 e + 1 }
  -> a:AND_AND v:IDENT  			     { nd(LABELADDR (fst v)), a, 2 }
}

nonterm(Cabs.expression node * cabsloc * int) CastExpression {
  -> u:UnaryExpression	  
            { u }
  -> "(" t:TypeName ")" e:CastExpression 
            { nd(CAST ( (pair3 t), SINGLE_INIT (fst3 e))), snd3 e, trd3 e + trd3 t + 2 }
}

// ++++ binary operator expression ++++
nonterm(Cabs.expression node * cabsloc * int) BinaryExpression {
  -> e:CastExpression                                   { e } 
  -> left:BinaryExpression bop:BinaryOp right:BinaryExpression   
            { nd(BINARY(bop, fst3 left, fst3 right)), snd3 left, trd3 left + 1 + trd3 right }
}

nonterm(Cabs.binary_operator) BinaryOp {
  -> "*"  { MUL }
  -> "/"  { DIV }
  -> "%"  { MOD }
  -> "+"  { ADD }
  -> "-"  { SUB }
  -> "<<" { SHL }
  -> ">>" { SHR }
  -> "<"  { LT }
  -> ">"  { GT } 
  -> "<=" { LE }
  -> ">=" { GE }
  -> "==" { EQ }
  -> "!=" { NE }
  -> "&"  { BAND }
  -> "^"  { XOR }
  -> "|"  { BOR }
  -> "&&" { AND }
  -> "||" { OR }
}

nonterm(Cabs.expression node * cabsloc * int) ConditionalExpression {
  -> e:BinaryExpression	  { e }
  -> cond:BinaryExpression "?" th:ExpressionOpt ":" el:ConditionalExpression 
       { nd(QUESTION (fst3 cond, fst th, fst3 el)), snd3 cond, trd3 cond + 1 + snd th + 1 + trd3 el }
}

// why is conditional not allowed on left side of = ?  can I confirm
// that in another language spec?  clearly both alternatives would have
// to be like-typed lvalues, but...

nonterm(Cabs.expression node * cabsloc * int) AssignmentExpression {
  -> e:ConditionalExpression  { e }
  -> e1:UnaryExpression a:AssignmentOp e2:AssignmentExpression
			{nd(BINARY(a, fst3 e1, fst3 e2)), snd3 e1, trd3 e1 + trd3 e2 + 1 }
}

nonterm (Cabs.binary_operator) AssignmentOp {
  -> "="  { ASSIGN }
  -> "+=" { ADD_ASSIGN }
  -> "-=" { SUB_ASSIGN }
  -> "*=" { MUL_ASSIGN }
  -> "/=" { DIV_ASSIGN } 
  -> "%=" { MOD_ASSIGN }
  -> "&=" { BAND_ASSIGN }
  -> "|=" { BOR_ASSIGN }
  -> "^=" { XOR_ASSIGN }
  -> "<<=" { SHL_ASSIGN }
  -> ">>=" { SHR_ASSIGN }
}
nonterm (Cabs.expression node * cabsloc * int) Expression {
  -> d:Directive { nd(EXPDIRECTIVE(fst3 d)), snd3 d, trd3 d }
  -> ae:AssignmentExpression { ae }
}

nonterm(Cabs.constant * cabsloc * int) Constant {
  -> i:CST_INT    {  CONST_INT(fst i),snd i, 1 }
  -> f:CST_FLOAT  {  CONST_FLOAT(fst f),snd f, 1 }
  -> c:CST_CHAR   { CONST_CHAR(fst c),snd c, 1 }
  -> c:CST_WCHAR  { CONST_WCHAR(fst c),snd c, 1 } 
  -> sc:StringConstant {CONST_STRING(fst3 sc),snd3 sc, trd3 sc }
  -> ws:WStringList  { CONST_WSTRING (fst3 ws), snd3 ws, trd3 ws }
}

nonterm(string * cabsloc * int) StringConstant {
->   slist:StringList                         {
     let queue, location, count = slist in
     let buffer = Buffer.create (Queue.length queue) in
     Queue.iter
       (List.iter
	  (fun value ->
	    let char = int64_to_char value in
	    Buffer.add_char buffer char))
       queue;
     Buffer.contents buffer, location, count
   }
}

nonterm(string * int) OneStringConstant {
  -> s:CST_STRING				  { intlist_to_string(fst s), List.length (fst s) }
}

nonterm(int64 list Queue.t * cabsloc * int) StringList {
  -> s:CST_STRING	   					{  let queue = Queue.create () in 
        							   Queue.add (fst s) queue;
									   queue, snd s, List.length (fst s)
									}
  -> lst:StringList s:CST_STRING		{  Queue.add (fst s) (fst3 lst); fst3 lst, snd3 lst, (List.length (fst s)) + trd3 lst }
}

nonterm(int64 list * cabsloc * int) WStringList {
  -> s:CST_WSTRING                         { fst s, snd s, List.length (fst s) }
  -> lst:WStringList s:CST_STRING          { (fst3 lst) @ (fst s), snd3 lst, (List.length (fst s)) + trd3 lst } 
  -> lst:WStringList s:CST_WSTRING         { (fst3 lst) @ (fst s), snd3 lst, trd3 lst + (List.length (fst s)) }
}

nonterm(Cabs.init_expression * int) InitExpression {
  -> a:ArbitraryList { SINGLE_INIT(smooth_expression(fst3 a)), trd3 a }
  -> e:Expression
            { SINGLE_INIT(fst3 e), trd3 e }
  -> "{" lst:InitializerListOpt "}"  
            { COMPOUND_INIT(fst lst), snd lst + 2 }
}

nonterm((Cabs.initwhat * Cabs.init_expression) list * int) InitializerList {
  -> i:Initializer				 { [pair3 i], trd3 i }
  -> i:Initializer "," lst:InitializerListOpt
		    { (pair3 i) :: (fst lst), trd3 i + snd lst + 1 }
}

nonterm((Cabs.initwhat * Cabs.init_expression) list * int) InitializerListOpt {
  -> empty			   	         { [], 1 }
  -> lst:InitializerList		 { lst }
}

nonterm(Cabs.initwhat * Cabs.init_expression * int) Initializer {
  -> id:InitDesignators e:EqOpt ie:InitExpression 
            { fst id, fst ie, snd id + e + snd ie }
  /* gcc_init_designators */
  -> g:GccInitDesignators i:InitExpression  
            { fst g, fst i, snd g + snd i }
  -> ie:InitExpression 
            { NEXT_INIT, fst ie, snd ie }
}

nonterm( int ) EqOpt {
  -> "=" 	   { 1 }
  -> empty 	   { 0 }
}

nonterm(Cabs.initwhat * int) InitDesignators {
  -> "." i:IdOrTypeName lst:InitDesignatorsOpt
            { INFIELD_INIT(fst i, fst lst), snd lst + snd i + 1 }
  -> "[" e:Expression "]" lst:InitDesignatorsOpt
            { ATINDEX_INIT(fst3 e, fst lst), trd3 e + snd lst + 2 }
  -> "[" e1:Expression "..." e2:Expression "]"
            { ATINDEXRANGE_INIT(fst3 e1, fst3 e2), trd3 e1 + trd3 e2 + 3 }
}

nonterm(Cabs.initwhat * int) InitDesignatorsOpt {
  -> empty	   					  { NEXT_INIT, 0 }
  -> lst:InitDesignators		  { lst }
}

nonterm(Cabs.initwhat * int) GccInitDesignators {
  -> v:IdOrTypeName ":"			  { INFIELD_INIT(fst v,NEXT_INIT), snd v + 1 }
}

nonterm(Cabs.expression node list * int) Arguments {
  -> empty					      { [], 0 }
  -> c:CommaExpression			  { fst3 c, trd3 c }
  -> a:ArbitraryList			  { fst3 a, trd3 a }
}

nonterm(Cabs.expression node * int)  ExpressionOpt {
  -> empty				  		  { nd(NOTHING), 0 }
  -> c:CommaExpression			  { smooth_expression (fst3 c), trd3 c }
}

nonterm(Cabs.expression node list * cabsloc * int ) CommaExpression {
  -> e:Expression    { [ fst3 e ], snd3 e, trd3 e }
  -> e1:Expression "," e2:CommaExpression 
      { (fst3 e1) :: (fst3 e2), snd3 e1, trd3 e1 + trd3 e2 + 1 }
}

nonterm(Cabs.expression node list * cabsloc * int ) ArbitraryList {
  -> e:Expression { [fst3 e], snd3 e, trd3 e }
  -> e:Expression e2:ArbitraryList { fst3 e :: fst3 e2, snd3 e, trd3 e }
  -> e:Expression "," e2:ArbitraryList { fst3 e :: fst3 e2, snd3 e, trd3 e }
}

nonterm(Cabs.expression node * int) CommaExpressionOpt {
  -> empty				 { nd(NOTHING), 0 }
  -> ce:CommaExpression	 { smooth_expression(fst3 ce), trd3 ce }
}

nonterm(Cabs.expression node list * cabsloc * int) ParenCommaExpression {
  -> "(" c:CommaExpression ")"		     { fst3 c, snd3 c, trd3 c + 2 }
}

// ------ A.5 Statements ------
// labeled-statement


nonterm(Cabs.block * cabsloc * cabsloc * int) Block {
  // I must enter scope immediately upon seeing the open-brace, so
  // that if the first token of the first statement changes or queries
  // the scope, it's in the new one
  -> lb:LBRACE labels:LocalLabels attrs:BlockAttrs seq:BlockElementList r:RBRACE
     {  { blabels = fst labels; battrs = fst attrs; bstmts=fst seq }, lb, r, snd labels + snd attrs + snd seq + 2 }
} 

nonterm(Cabs.attribute list * int) BlockAttrs {
  -> empty			   		 { [], 0 }
  -> b:BlockAttrsNE			 { b }
}

nonterm(Cabs.attribute list * int) BlockAttrsNE {
  -> BLOCKATTRIBUTE "(" lst:AttrListNE ")" { [("__blockattribute__", fst lst)], snd lst + 3 }
}

nonterm( Cabs.statement node list * int ) BlockElementList {
  -> empty 					   		    { [], 0 }
  ->  s:Statement seq:BlockElementList  {   (fst s) :: (fst seq), snd s + snd seq }
       
  -> d:Declaration seq:BlockElementList precedence(PREFER_SHIFT)
             {   nd(DEFINITION(fst d)) :: (fst seq), snd d + snd seq }
  -> v:IDENT ":"                        { [ nd(LABEL (fst v, nd(NOP (snd v)), snd v))], 2 }
  ->  "pragma" seq:BlockElementList     { seq }
}

nonterm( Cabs.statement node list * int ) BlockElementListNE {
  ->  s:Statement seq:BlockElementList  {  (fst s) :: (fst seq), snd s + snd seq }
       
  -> d:Declaration seq:BlockElementList {  nd(DEFINITION(fst d)) :: (fst seq), snd d + snd seq }
  -> v:IDENT ":"                        { [ nd(LABEL (fst v, nd(NOP (snd v)), snd v))], 2 }
  ->  "pragma" seq:BlockElementList     { seq }
}

nonterm(string list * int) LocalLabels {
  -> empty                                       { [], 0 }
  -> LABEL__ lst:LocalLabelNames ";" lst2:LocalLabels  { (fst lst) @ (fst lst2), snd lst + snd lst2 + 2 }
}

nonterm(string list * int) LocalLabelsNE {
  -> LABEL__ lst:LocalLabelNames ";" lst2:LocalLabels  { (fst lst) @ (fst lst2), snd lst + snd lst2 + 2 }
}

nonterm(string list * int) LocalLabelNames {
  -> i:IDENT                                 { [ fst i ], 1 }
  -> i:IDENT "," lst:LocalLabelNames         { fst i :: (fst lst), snd lst + 2 }
}

nonterm( Cabs.statement node * int) Statement {
  -> d:Directive precedence(PREFER_SHIFT)		    {  nd (STMTDIRECTIVE(fst3 d, snd3 d)),trd3 d } 
  -> s:SEMICOLON		    {  nd(NOP(s)), 1 }
  -> ce:CommaExpression ";" { nd(COMPUTATION (smooth_expression (fst3 ce), snd3 ce)), trd3 ce + 1 }
  -> s:Block    			{  nd(BLOCK(fst4 s, snd4 s)), frth4 s }
  -> f:IF "(" e:CommaExpression ")" s:Statement     precedence(IF)
       {  nd(IF (smooth_expression (fst3 e), fst s, nd(NOP f), f)), trd3 e + snd s + 3 }

  // if-then-else preferred over if-then when ambiguous
  -> f:IF "(" e:CommaExpression ")" s1:Statement "else" s2:Statement
       { nd(IF (smooth_expression  (fst3 e), fst s1,fst s2, f )), trd3 e + snd s1 + snd s2 + 4 }
  -> sw:SWITCH "(" e:CommaExpression ")" s:Statement
       { nd(SWITCH (smooth_expression (fst3 e), fst s, sw )), snd s + trd3 e + 3 }
  -> w:WHILE "(" e:CommaExpression ")" s:Statement
       { nd(WHILE (smooth_expression (fst3 e), fst s, w )), trd3 e + snd s + 3 }
  -> d:DO s:Statement "while" "(" e:CommaExpression ")" ";"
       { nd(DOWHILE (smooth_expression (fst3 e), fst s, d)), trd3 e + snd s + 5 }
  -> f:FOR "(" fc:ForClause oe1:ExpressionOpt ";" oe2:ExpressionOpt ")" s:Statement
       { nd(FOR(fst fc,fst oe1,fst oe2,fst s, f)), snd fc + snd oe1 + snd oe2 + snd s + 4  }

  -> n:IDENT ":" a:AttributeNoCVList s:Statement 
       {(* The only attribute that should appear here
                                     is "unused". For now, we drop this on the
                                     floor, since unused labels are usually
                                     removed anyways by Rmtmps. *)
									 nd(LABEL(fst n,fst s, (snd n))), 2 + snd a + snd s }
  -> c:CASE e:Expression ":" s:Statement      { nd(CASE(fst3 e, fst s, c)), trd3 e + snd s + 2 }
  // gnu extension
  -> c:CASE low:Expression "..." high:Expression ":" s:Statement
        { nd(CASERANGE ( fst3 low, fst3 high, fst s, c )), trd3 low + trd3 high + snd s + 3 }

  -> d:DEFAULT ":" 	  	  	   	       { nd(DEFAULT (nd(NOP d), d)), 2 }
  -> r:RETURN ";"                       { nd(RETURN (nd(NOTHING), r)), 2 }
  -> r:RETURN e:CommaExpression ";"          { nd(RETURN (smooth_expression (fst3 e), r )), trd3 e + 2 }

  -> b:BREAK ";"                        { nd(BREAK ( b )), 2 }
  -> c:CONTINUE ";"                     { nd(CONTINUE( c )), 2 }
  -> g:GOTO i:IDENT ";"      			{ nd(GOTO(fst i,g)), 3 }
  -> g:GOTO "*" c:CommaExpression ";"
            { nd(COMPGOTO ( smooth_expression (fst3 c), g)), trd3 c + 3 }
  -> a:ASM aattr:ASMAttr "(" at:ASMTemplate ao:ASMOutputs ")" ";"
            { nd(ASM (fst aattr, fst at, fst ao, a)), snd aattr + snd at + snd ao + 4 }
  -> m:MSASM
            { nd(ASM ([], [fst m], None, (*handleLoc*)(snd m))), 1 }
  -> t:TRY bc:Block "except" "(" c1:CommaExpression ")"  b2:Block
                        { let b, _, _, count1 = bc in
                          let h, _, _, count2 = b2 in
                          nd(TRY_EXCEPT (b, nd(COMMA (fst3 c1)), h, (*handleLoc*) t)), count1 + count2 + trd3 c1 + 4 }
  -> t:TRY bc:Block "finally" bc2:Block  
                        { let b, _, _, count1 = bc in
                          let h, _, _, count2 = bc2 in
                          nd(TRY_FINALLY (b, h, (*handleLoc*) t)), count1 + count2 + 2 }

}

nonterm( Cabs.for_clause * int) ForClause {
  -> e:ExpressionOpt ";" { FC_EXP(fst e), snd e + 1}
  -> s:Declaration       { FC_DECL(fst s), snd s }
}

// ----- A.6 Declarations ------

nonterm(Cabs.definition node * int) Declaration {
  -> d:DeclSpecList lst:InitDeclaratorList ";"
                 {  doDeclaration ((*handleLoc*)(snd3 d)) (fst3 d) (fst lst), trd3 d + snd lst + 1 }
  -> d:DeclSpecList ";"
                 { doDeclaration ((*handleLoc*)(snd3 d)) (fst3 d) [], trd3 d + 1 }
 ->  v:IDENT "(" old:OldParameterListNE ")" ops:OldPardefList ";"
                           { (* Convert pardecl to new style *)
                             let pardecl, isva = doOldParDecl (fst old) (pair3 ops) in 
                             (* Make the function declarator *)
                             doDeclaration ((*handleLoc*) (snd v)) []
                               [((fst v, PROTO(JUSTBASE, pardecl,isva), [], cabslu),
                                 NO_INIT)],  snd old + trd3 ops + 4
						    }
/* (* Old style function prototype, but without any arguments *) */
-> v:IDENT "(" ")" ";"
                           { (* Make the function declarator *)
                             doDeclaration ((*handleLoc*)(snd v)) []
                               [((fst v, PROTO(JUSTBASE,[],false), [], cabslu),
                                 NO_INIT)], 4
                            }
}

// ------ A.7 Declarators ------
// -- declarator --
// a declarator is the "x" in a declaration like "int x"

nonterm(Cabs.init_name list * int) InitDeclaratorList {
  -> d:InitDeclarator  		 { [fst d], snd d }
  -> d:InitDeclarator "," lst:InitDeclaratorList
       						 { (fst d) :: (fst lst), snd d + snd lst + 1 }
}

nonterm(Cabs.init_name * int) InitDeclarator {
  -> d:Declarator                       { (fst d, NO_INIT), snd d }
  -> d:Declarator "=" i:InitExpression     // (int)  x = 5
  	 			  	  					 { (fst d, fst i), snd d + snd i + 1 }
}

nonterm(Cabs.spec_elem list * cabsloc * int ) DeclSpecList {
  -> t:TYPEDEF lst:DeclSpecListOpt  { SpecTypedef :: (fst lst), t, snd lst + 1 }
  -> e:EXTERN lst:DeclSpecListOpt    { SpecStorage EXTERN :: (fst lst), e, snd lst + 1 }
  -> s:STATIC lst:DeclSpecListOpt    { SpecStorage STATIC :: (fst lst), s, snd lst + 1 }
  -> a:AUTO lst:DeclSpecListOpt      { SpecStorage AUTO :: (fst lst), a, snd lst + 1 }
  -> r:REGISTER lst:DeclSpecListOpt  { SpecStorage REGISTER :: (fst lst), r, snd lst + 1 }
  -> t:TypeSpecifier lst:DeclSpecListOptNoNamed  { SpecType (fst3 t) :: (fst lst), snd3 t, trd3 t + snd lst }
  -> i:INLINE lst:DeclSpecListOpt    { SpecInline :: (fst lst), i, snd lst + 1 }
  -> c:CVSpec lst:DeclSpecListOpt    { fst c :: (fst lst), snd c, 1 + snd lst }
  -> attr:AttributeNoCV lst:DeclSpecListOpt { SpecAttr(fst3 attr) :: (fst lst), snd3 attr, trd3 attr + snd lst }
  -> a:AT_SPECIFIER "(" n:IDENT ")"    { [SpecPattern(fst n)], a, 4 }
  	 					   			
}

nonterm(Cabs.spec_elem list * int) DeclSpecListOpt {
-> empty 				precedence(NAMED_TYPE)
 				{ [], 0 } 
-> lst:DeclSpecList	{ fst3 lst, trd3 lst }
}

nonterm(Cabs.spec_elem list * int) DeclSpecListOptNoNamed {
-> empty 				precedence(IDENT)
 				{ [], 0 } 
-> lst:DeclSpecList	{ fst3 lst, trd3 lst }
}

nonterm(Cabs.typeSpecifier * cabsloc * int) TypeSpecifier {
  -> v:VOID                     { Tvoid, v, 1 }
  -> c:CHAR                     { Tchar, c, 1 }
  -> s:SHORT					{ Tshort, s, 1 }
  -> i:INT 					    { Tint, i, 1 }
  -> l:LONG                     { Tlong, l, 1 }
  -> i:INT64  				    { Tint64, i, 1 }
  -> f:FLOAT                    { Tfloat, f, 1 }
  -> d:DOUBLE                   { Tdouble, d, 1 }
  -> s:SIGNED                   { Tsigned, s, 1 }
  -> u:UNSIGNED  				{ Tunsigned, u, 1 }
  -> s:STRUCT                   n:IdOrTypeName    		  			 
            { Tstruct (fst n, None, []), s, snd n + 1 } 
  -> s:STRUCT ja:JustAttributes n:IdOrTypeName                       
            { Tstruct (fst n, None, fst ja), s, snd ja + snd n + 1 }

  -> s:STRUCT                   n:IdOrTypeName "{" memb:StructDeclList "}"
            { Tstruct (fst n, Some (fst memb), []), s, snd memb + snd n + 3 }
  -> s:STRUCT                                  "{" memb:StructDeclList "}"
  	 		{ Tstruct ("", Some (fst memb), []), s, snd memb + 3 }
                                                 
  -> s:STRUCT ja:JustAttributes n:IdOrTypeName "{" memb:StructDeclList "}"
            { Tstruct (fst n, Some (fst memb), fst ja), s, snd memb + snd ja + snd n + 3 }
  -> s:STRUCT ja:JustAttributes                "{" memb:StructDeclList "}"
            { Tstruct ("", Some (fst memb), fst ja), s, snd memb + snd ja + 3 }

  -> s:UNION                   n:IdOrTypeName     		  			 
            { Tunion (fst n, None, []), s, snd n + 1 }
  -> s:UNION                   n:IdOrTypeName "{" memb:StructDeclList "}"
            { Tunion (fst n, Some (fst memb), []), s, snd memb + snd n + 3 }
  -> s:UNION                                  "{" memb:StructDeclList "}"
  	 		{ Tunion ("", Some (fst memb), []), s, snd memb + 3 }
  -> s:UNION ja:JustAttributes n:IdOrTypeName "{" memb:StructDeclList "}"
            { Tunion (fst n, Some (fst memb), fst ja), s, snd memb + snd ja + snd n + 3 }
  -> s:UNION ja:JustAttributes                "{" memb:StructDeclList "}"
            { Tunion ("", Some (fst memb), fst ja), s, snd memb + snd ja + 3 }
                                                 
  -> s:ENUM                     n:IdOrTypeName 		  			     
            { Tenum (fst n, None, []), s, snd n + 1 }
  -> s:ENUM  ja:JustAttributes  n:IdOrTypeName                       
            { Tenum (fst n, None, fst ja), s, snd ja + snd n + 1}
  -> s:ENUM                     n:IdOrTypeName "{" memb:EnumList m:MaybeComma "}"
            { Tenum (fst n, Some (fst memb), []), s, snd memb + m + snd n + 3 }
  -> s:ENUM                               "{" memb:EnumList m:MaybeComma "}"
  	 		{ Tenum ("", Some(fst memb), []), s, snd memb + m + 3 }
                                                 
  -> s:ENUM  ja:JustAttributes  n:IdOrTypeName "{" memb:EnumList m:MaybeComma "}"
            { Tenum (fst n, Some (fst memb),fst ja), s, snd memb + snd ja + m + snd n + 3 }
  -> s:ENUM  ja:JustAttributes            "{" memb:EnumList m:MaybeComma "}"
            { Tenum ("", Some (fst memb), fst ja), s, snd memb + snd ja + m + 3 }

  // the existence of this production is part of why parsing C is hard
  -> n:IDENT  	  	        { Tnamed(fst n), cabslu, 1}

  -> t:TYPEOF "(" e:Expression ")"  { TtypeofE (fst3 e), t, trd3 e + 3}
  -> t:TYPEOF "(" e:TypeName  ")"	{ let s,d,count = e in TtypeofT (s,d), t, count + 3 }
  	 			   						  
}

nonterm(Cabs.field_group list * int) StructDeclListNE { /* (* ISO 6.7.2. Except that we allow empty structs. We 
                      * also allow missing field names. *)
                   */
  -> dlist:DeclSpecList ";" slist:StructDeclList
                                         { (fst3 dlist, 
                                            [(missingFieldDecl, None)]) :: (fst slist), trd3 dlist + snd slist + 1 }
/*(* GCC allows extra semicolons *)*/
  -> ";" lst:StructDeclList      { fst lst, snd lst + 1 }
  -> dlist:DeclSpecList flist:FieldDeclList ";" slist:StructDeclList 
                                         { ((fst3 dlist), fst flist) :: (fst slist), trd3 dlist + snd flist +  snd slist + 1}
/*(* MSVC allows pragmas in strange places *)*/
  ->"pragma" slist:StructDeclList       { slist }
}

nonterm(Cabs.field_group list * int) StructDeclList { /* (* ISO 6.7.2. Except that we allow empty structs. We 
                      * also allow missing field names. *)
                   */
  -> empty                           { [], 0 }
  -> slist:StructDeclListNE			 { slist }
}

nonterm((Cabs.name * expression node option) list * int) FieldDeclList {
  -> f:FieldDecl				           { [pair3 f], trd3 f }
  -> f:FieldDecl "," fs:FieldDeclList  { (pair3 f) :: (fst fs), trd3 f + snd fs + 1 }
}

nonterm(Cabs.name * expression node option * int) FieldDecl { /* (* ISO 6.7.2. Except that we allow unnamed fields. *) */
  -> d:Declarator                      { fst d, None, snd d }
  -> d:Declarator ":" e:Expression a:Attributes
                                    { let (n,decl,al,loc), count = d in 
                                      let al' = al @ (fst a) in
                                     (n,decl,al',loc), Some (fst3 e), count + 1 + trd3 e + snd a }
  -> ":" e:Expression     { missingFieldDecl, Some (fst3 e), trd3 e + 1 }
}

nonterm(Cabs.enum_item list * int) EnumList {  /* (* ISO 6.7.2.2 *) */
  -> e:Enumerator				{[fst e], snd e }
  -> lst:EnumList "," e:Enumerator	        { (fst lst) @ [ (fst e) ], snd lst + 1 + snd e }
}

nonterm(Cabs.enum_item * int ) Enumerator {
  -> i:IDENT			{(fst i, nd(NOTHING), snd i), 1}
  -> i:IDENT "=" e:Expression		{(fst i, fst3 e, snd i), trd3 e + 2 }
}

nonterm(Cabs.name * int ) Declarator {
  -> p:PointerOpt d:DirectDeclarator aas:AttributesWithASM
  	   { let n,decl, count = d in (n, applyPointer (fst3 p) decl,fst aas, snd3 p), trd3 p + count + snd aas }
}

nonterm(string * Cabs.decl_type * int) DirectDeclarator {
  -> n:IdOrTypeName
            { fst n, JUSTBASE, snd n }  

  -> "(" a:Attributes d:Declarator ")"
            { let (n,decl,al,loc), count = d  in
                n, PARENTYPE(fst a,decl,al), snd a + count + 2 }

  -> d:DirectDeclarator "[" aas:Attributes c:CommaExpressionOpt "]"
  	 		{ let n,decl,count = d in
			   n, ARRAY(decl, fst aas,fst c), count + snd aas + snd c + 2 }
  -> d:DirectDeclarator "(" ps:ParameterDeclList  ")"
  	 		{ let n, decl, count1 = d in
              let params, isva, count2 = ps in
                n, PROTO(decl, params, isva), count1 + count2 + 2 }
}

nonterm(Cabs.single_name list * bool * int) ParameterDeclList {
   -> empty { [], false, 0 }
  -> p:ParameterDecl rest:RestParList1
 	        {  let params, isva, count = rest in 
                  (fst p) :: params, isva, snd p + count  }
}

nonterm(Cabs.single_name list * bool * int ) RestParList1 {
   -> empty				 	  		  	   { [], false, 0 }
   -> "," "..."					   		   { [], true, 2 }
   -> "," p:ParameterDecl rst:RestParList1 {  let (params, isva, count) = rst in 
                                           fst p :: params, isva, count + snd p + 1  }
}

nonterm(Cabs.single_name * int ) ParameterDecl {
  -> ds:DeclSpecList d:Declarator  { (fst3 ds, fst d), trd3 ds + snd d }
  -> ds:DeclSpecList ad:AbstractDeclarator 
  	 						  { let d,a, count= ad in
							  	(fst3 ds, ("",d,a,cabslu)), trd3 ds + count }
  -> ds:DeclSpecList  { (fst3 ds, ("",JUSTBASE, [], cabslu)), trd3 ds }
  -> "(" p:ParameterDecl ")" { fst p, snd p + 2 }
}

/* (* Old style prototypes. Like a declarator *) */
nonterm(Cabs.name * int ) OldProtoDecl {
  -> p:PointerOpt ds:DirectOldProtoDecl   { let n, decl, a, count = ds in 
					  					  	    (n, applyPointer (fst3 p) decl, a, snd3 p), trd3 p + count
                                          }
}

nonterm(string * Cabs.decl_type * Cabs.attribute list * int) DirectOldProtoDecl { 
  -> d:DirectDeclarator "(" lst:OldParameterListNE ")" ops:OldPardefList
                                   { let par_decl, isva = doOldParDecl (fst lst) (pair3 ops) in
                                     let n, decl, count = d in
                                     n, PROTO(decl, par_decl, isva), [], trd3 ops + snd lst + count + 2
                                   }
  -> d:DirectDeclarator "(" ")"
                                   { let n, decl,count = d in
                                     n, PROTO(decl, [], false), [], count + 2
                                   }

/* (* appears sometimesm but generates a shift-reduce conflict. *)
 | LPAREN STAR direct_decl LPAREN old_parameter_list_ne RPAREN RPAREN LPAREN RPAREN old_pardef_list
                                   { let par_decl, isva 
                                             = doOldParDecl $5 $10 in
                                     let n, decl = $3 in
                                     (n, PROTO(decl, par_decl, isva), [])
                                   }
*/
}

nonterm (string list * int ) OldParameterListNE {
  -> v:IDENT                                       { [fst v], 1 }
  -> v:IDENT "," lst:OldParameterListNE 
                                               {  (fst v) :: (fst lst), snd lst + 2 }
}

nonterm(Cabs.name_group list * bool * int) OldPardefList { 
  -> empty  { [], false, 0 }
  -> ds:DeclSpecList o:OldPardef ";" "..."
                                          { [(fst3 ds, fst o)], true, snd o + trd3 ds + 2 }
  -> ds:DeclSpecList o:OldPardef ";" lst:OldPardefList 
                                          { let rest, isva, count1 = lst in
                                            (fst3 ds, fst o) :: rest, isva, trd3 ds + count1 + snd o + 1 
                                          }
}

nonterm(Cabs.name_group list * bool * int) OldPardefListNE { 
  -> ds:DeclSpecList o:OldPardef ";" "..."
                                          { [(fst3 ds, fst o)], true, snd o + trd3 ds + 2 }
  -> ds:DeclSpecList o:OldPardef ";" lst:OldPardefList 
                                          { let rest, isva, count1 = lst in
                                            (fst3 ds, fst o) :: rest, isva, trd3 ds + count1 + snd o + 1 
                                          }
}

nonterm(Cabs.name list * int) OldPardef {
  -> d:Declarator						     { [fst d], snd d }
  -> d:Declarator "," o:OldPardef            { (fst d) :: (fst o), snd o + snd d + 1 }
}

nonterm(Cabs.attribute list list * cabsloc * int) Pointer { /* (* ISO 6.7.5 *) */ 
  -> s:STAR attrs:Attributes p:PointerOpt  { (fst attrs) :: (fst3 p), s, trd3 p + snd attrs + 1 }
}

nonterm(Cabs.attribute list list * cabsloc * int) PointerOpt {
  -> empty 	   { [], cabslu, 0 }
  -> p:Pointer  { p } 
}

nonterm(Cabs.specifier * Cabs.decl_type * int) TypeName {
 -> d1:DeclSpecList ab:AbstractDeclarator 
 								{ let d2, a,count = ab in
(*                                 if a <> [] then begin
                                   parse_error "attributes in type name";
                                   raise Parsing.Parse_error
                                 end;*)
                                 fst3 d1, d2, trd3 d1 + count
                               }
  -> d:DeclSpecList                { fst3 d, JUSTBASE, trd3 d }
}

// an abstract declarator (not opt) must have *some* ground syntax in it
nonterm(Cabs.decl_type * Cabs.attribute list * int) AbstractDeclarator {
  -> p:PointerOpt d:DirectAbstractDeclarator a:Attributes 
            { applyPointer (fst3 p) (fst d), fst a, trd3 p + snd d + snd a }
  -> p:Pointer 
            { applyPointer (fst3 p) JUSTBASE, [], trd3 p}
}

// this also must have some ground syntax
nonterm(Cabs.decl_type * int) DirectAbstractDeclarator {
  -> "(" attrs:Attributes a:AbstractDeclarator ")" 
                                   { let d, a2, count =  a in 
                                     PARENTYPE (fst attrs, d, a2), count + snd attrs + 2
                                   }

  -> d:DirectAbstractDeclaratorOpt "[" ae:CommaExpressionOpt "]" 
                                   { ARRAY(fst d, [], fst ae), snd d + snd ae + 2 }

  -> d:DirectAbstractDeclarator "(" lst:ParameterDeclList  ")"
  	 							   { let params,isva,count = lst in
								      PROTO(fst d, params, isva), count + snd d + 2 }
}

nonterm(Cabs.decl_type * int) DirectAbstractDeclaratorOpt {
  -> empty  { JUSTBASE, 0 }
  -> d:DirectAbstractDeclarator  
            { d } 
}

// -- function definition --
nonterm(Cabs.definition node * int) FunctionDefinition {
  -> start:FunctionDefStart b:Block
          {  let loc, specs, decl, count = start in
            doFunctionDef ((*handleLoc*) loc) (trd4 b) specs decl (fst4 b), count + frth4 b
          } 
}

nonterm(cabsloc * Cabs.specifier * Cabs.name * int) FunctionDefStart {
  -> ds:DeclSpecList d:Declarator
            { snd3 ds, fst3 ds, fst d, snd d + trd3 ds }
/* (* Old-style function prototype *) */
  -> ds:DeclSpecList old:OldProtoDecl
            { snd3 ds, fst3 ds, fst old, snd old + trd3 ds }
/* (* New-style function that does not have a return type *) */
  -> v:IDENT "(" lst:ParameterDeclList ")"
                           { 
						   let params, isva, count = lst in
                             let fdec = 
                               (fst v, PROTO(JUSTBASE, params, isva), [], snd v) in
                             (* Default is int type *)
                             let defSpec = [SpecType (Tint)] in
                              snd v, defSpec, fdec, count + 3
                           }

/* (* No return type and old-style parameter list *) */
  -> v:IDENT "(" lst:OldParameterListNE ")" ops:OldPardefList
                           { (* Convert pardecl to new style *)
                             let pardecl, isva = doOldParDecl (fst lst) (pair3 ops) in
                             (* Make the function declarator *)
                             let fdec = (fst v,
                                         PROTO(JUSTBASE, pardecl,isva), 
                                         [], snd v) in
                             (* Default is int type *)
                             let defSpec = [SpecType (Tint)] in
							 snd v, defSpec, fdec, snd lst + trd3 ops + 3
                            }
/* (* No return type and no parameters *) */
  -> v:IDENT "(" ")" 
                           { (* Make the function declarator *)
                             let fdec = (fst v,
                                         PROTO(JUSTBASE, [], false), 
                                         [], snd v) in
                             (* Default is int type *)
                             let defSpec = [SpecType (Tint)] in
							 snd v, defSpec, fdec, 3
                            }
}

nonterm(Cabs.spec_elem * cabsloc) CVSpec {
  -> c:CONST
            { SpecCV(CV_CONST), c }
  -> v:VOLATILE
            { SpecCV(CV_VOLATILE), v }
  -> r:RESTRICT
            { SpecCV(CV_RESTRICT), r }
}

nonterm(Cabs.attribute list * int) Attributes {
  -> empty			   		 	     { [], 0 }
  -> t:Attribute lst:Attributes      { fst3 t :: ( fst lst), trd3 t + snd lst }
}


nonterm(Cabs.attribute list * int) AttributesWithASM {
  -> empty			   		 { [], 0 }
  -> a:Attribute rest:AttributesWithASM { (fst3 a) :: (fst rest), trd3 a + snd rest }
  -> ASM "(" s:StringConstant ")" aas:Attributes 
                                        { ("__asm__", 
					   [nd(CONSTANT(CONST_STRING (fst3 s)))]) :: (fst aas), snd aas + trd3 s + 3 }

}

nonterm(Cabs.attribute * cabsloc * int ) AttributeNoCV {
  -> a:ATTRIBUTE "(" ps:AttrList ")"
                                        { ("__attribute__", fst ps), a, snd ps + 3 }
  -> d:DECLSPEC "(" p:AttrListNE ")"       { ("__declspec", fst p), d, snd p + 3 }
  -> m:MSATTR                           { (fst m, []), snd m, 1 }
                                        /* ISO 6.7.3 */
  -> t:THREAD                              { ("__thread",[]), t, 1 }
}

nonterm(Cabs.attribute list * int) AttributeNoCVList {
  -> empty 	   					 { [], 0 }
  -> a:AttributeNoCV aas:AttributeNoCVList  { fst3 a :: (fst aas), trd3 a + snd aas }
}

nonterm(Cabs.attribute list * int) AttributeNoCVListNE {
  -> a:AttributeNoCV
	   		{ [fst3 a], trd3 a }
  -> a:AttributeNoCV aas:AttributeNoCVList
            { fst3 a :: (fst aas), trd3 a + snd aas }
}

/* __attribute__ plus const/volatile */
nonterm(Cabs.attribute * cabsloc * int) Attribute {
  -> a:AttributeNoCV 	 		   { a }
  -> c:CONST                       { ("const", []), c, 1 }
  -> r:RESTRICT                    { ("restrict",[]), r, 1 }
  -> v:VOLATILE                    { ("volatile",[]), v, 1 }
}

/* (* sm: I need something that just includes __attribute__ and nothing more,
 *  to support them appearing between the 'struct' keyword and the type name. 
 * Actually, a declspec can appear there as well (on MSVC) *)  */
nonterm(Cabs.attribute * int) JustAttribute {
  -> ATTRIBUTE "(" ps:AttrList ")"
            { ("__attribute__", fst ps), snd ps + 3  }
  -> DECLSPEC "(" ps:AttrListNE ")"
            { ("__declspec", fst ps), snd ps + 3 }
}


nonterm(Cabs.attribute list * int) JustAttributes {
  -> j:JustAttribute                      { [fst j], snd j }
  -> j:JustAttribute js:JustAttributes    { fst j :: fst js, snd j + snd js }
}

/** (* PRAGMAS and ATTRIBUTES *) ***/
nonterm(Cabs.definition node * int) Pragma {
  -> p:PRAGMA a:Attr PRAGMA_EOL		{ nd(PRAGMA (fst a, p)), snd a + 2 }
  -> p:PRAGMA a:Attr ";" PRAGMA_EOL	{ nd(PRAGMA (fst a, p)), snd a + 3 }
  -> p:PRAGMA_LINE                  { nd(PRAGMA (nd(VARIABLE (fst p)), snd p)), 1 }
                                                  
}

/* (* We want to allow certain strange things that occur in pragmas, so we 
    * cannot use directly the language of expressions *) */ 
nonterm(Cabs.expression node * int) PrimaryAttr {
  -> v:IDENT				    { nd(VARIABLE (fst v)), 1 }
    /*(* The NAMED_TYPE here creates conflicts with IDENT *)*/
  -> "(" a:Attr ")"             { fst a, snd a + 2 } 
  -> a:IDENT b:IDENT            { nd(CALL(nd(VARIABLE (fst a)), [nd(VARIABLE (fst b))])), 2 }
  -> i:CST_INT                  { nd(CONSTANT(CONST_INT (fst i))), 1 }
  -> sc:StringConstant          { nd(CONSTANT(CONST_STRING (fst3 sc))), trd3 sc }
                                  /*(* Const when it appears in 
                                   * attribute lists, is translated 
                                   * to aconst *)*/
  -> CONST                    { nd(VARIABLE "aconst"), 1 }

  -> i:IDENT ":" ci:CST_INT     { nd(VARIABLE (fst i ^ ":" ^ fst ci)), 3 }

/*(* The following rule conflicts with the ? : attributes. We give it a very 
   * low priority *)*/ 
  -> ci:CST_INT ":" ci2:CST_INT { nd(VARIABLE (fst ci ^ ":" ^ fst ci2)), 3 } 

  -> DEFAULT ":" ci:CST_INT   { nd(VARIABLE ("default:" ^ fst ci)), 3 }
                          
                                /*(** GCC allows this as an 
                                 * attribute for functions, 
                                 * synonim for noreturn **)*/
  -> VOLATILE                 { nd(VARIABLE ("__noreturn__")), 1 }
}

nonterm(Cabs.expression node * int) PostfixAttr { 
  -> p:PrimaryAttr				         
            { p }
  /* (* use a VARIABLE "" so that the parentheses are printed *) */
  -> i:IDENT "(" ")"
            { nd(CALL(nd(VARIABLE (fst i)), [nd(VARIABLE "")])), 3 }
  -> i:IDENT "(" ps:AttrListNE ")" 		 
            { nd(CALL(nd(VARIABLE (fst i)), fst ps)), snd ps + 3 }
  -> p:PostfixAttr "->" a:IdOrTypeName   
            { nd(MEMBEROFPTR (fst p, fst a)), snd p + snd a + 1 }
  -> p:PostfixAttr "." a:IdOrTypeName    
            { nd(MEMBEROF (fst p, fst a)), snd p + snd a + 1 }
  -> p:PostfixAttr "[" a:Attr "]"        
            { nd(INDEX (fst p, fst a)), snd p + snd a + 2 }
}

/*(* Since in attributes we use both IDENT and NAMED_TYPE as indentifiers, 
 * that leads to conflicts for SIZEOF and ALIGNOF. In those cases we require 
 * that their arguments be expressions, not attributes *)*/
nonterm(Cabs.expression node * int) UnaryAttr {
  -> p:PostfixAttr                         
            { p }
  -> "sizeof" e:UnaryExpression           
            { nd(EXPR_SIZEOF (fst3 e)), trd3 e + 1 }
  -> "sizeof" "(" t:TypeName ")"
		    {let b, d, count = t in nd(TYPE_SIZEOF (b, d)), count + 3}
  -> "alignof" e:UnaryExpression
            {nd(EXPR_ALIGNOF (fst3 e)), trd3 e + 1 }
  -> "alignof" "(" t:TypeName ")"
            {let b, d, count = t in nd(TYPE_ALIGNOF (b, d)), count + 3}
  -> "+" ea:CastAttr
            {nd(UNARY (PLUS, fst ea)), snd ea + 1}
  -> "-" ea:CastAttr
            {nd(UNARY (MINUS, fst ea)), snd ea + 1}
  -> "*" ea:CastAttr
            {nd(UNARY (MEMOF, fst ea)), snd ea + 1}
  -> "&" ea:CastAttr
            {nd(UNARY (ADDROF, fst ea)), snd ea + 1}
  -> "!" ea:CastAttr    	        
            {nd(UNARY (NOT, fst ea)), snd ea + 1}
  -> "~" ea:CastAttr                     
            {nd(UNARY (BNOT, fst ea)), snd ea + 1}
}

nonterm(Cabs.expression node * int) CastAttr {
  -> ca:UnaryAttr		  		   { ca }
}

nonterm(Cabs.expression node * int) BinaryAttr {
  -> e:CastAttr			  			    
            { e }
  -> ua1:BinaryAttr bop:BinaryOp ua2:BinaryAttr  
            {nd(BINARY(bop, fst ua1, fst ua2)), snd ua1 + snd ua2 + 1}
}

nonterm(Cabs.expression node * int) ConditionalAttr {
  -> a:BinaryAttr							
            { a }
/* This is in conflict for now */
  -> ua1:BinaryAttr "?" ua2:ConditionalAttr ":" ua3:ConditionalAttr
            { nd(QUESTION(fst ua1, fst ua2, fst ua3)), snd ua1 + snd ua2 + snd ua3 + 2 }
}

nonterm(Cabs.expression node * int) Attr {
  -> u:ConditionalAttr		 	  { u }
}

nonterm(Cabs.expression node list * int) AttrListNE {
  -> a:Attr                                  { [fst a], snd a }
  -> a:Attr "," lst:AttrListNE               { fst a :: fst lst, snd a + snd lst + 1 }
}

nonterm(Cabs.expression node list * int) AttrList {
  -> empty  { [], 0 }
  -> lst:AttrListNE
            { lst }
}

/*** GCC ASM instructions ***/
nonterm(Cabs.attribute list * int) ASMAttr {
  -> empty	{ [], 0 }
  -> VOLATILE a:ASMAttr
            { ("volatile", []) :: fst a, snd a + 1 }
  -> CONST a:ASMAttr                      
            { ("const", []) :: fst a, snd a + 1 } 
}

nonterm(string list * int) ASMTemplate {
  -> o:OneStringConstant                          { [fst o], snd o }
  -> o:OneStringConstant a:ASMTemplate            { fst o :: fst a, snd o + snd a }
}

nonterm(Cabs.asm_details option * int) ASMOutputs { 
  -> empty  { None, 0 }
  -> ":" os:ASMOperands ai:ASMInputs 
            { let ins, clobs, count = ai in
               Some({aoutputs = fst os; ainputs = ins; aclobbers = clobs}), snd os + count + 1 }
}

nonterm((string option * string * expression node) list * int) ASMOperands { 
  -> empty 	   			   	 { [], 0 } 
  -> ao:ASMOperandsNE        { List.rev (fst ao), snd ao }
}

nonterm((string option * string * expression node) list * int) ASMOperandsNE {
  -> ao:ASMOperand                            
            { [fst ao], snd ao }
  -> lst:ASMOperandsNE "," ao:ASMOperand  
            { (fst ao) :: fst lst, snd ao + snd lst + 1 }
}

nonterm((string option * string * expression node) * int) ASMOperand {
  -> name:ASMOpName sc:StringConstant "(" e:Expression ")"
            { (fst name, fst3 sc, fst3 e), 2 + trd3 sc + trd3 e + snd name }
}

nonterm((string option * string * expression node) list * string list * int) ASMInputs {
  -> empty  { [], [], 0 }
  -> ":" ao:ASMOperands ac:ASMClobber
            { fst ao, fst ac, snd ao + snd ac + 1 }
}

nonterm(string option * int) ASMOpName {
  -> empty                         { None, 0 }
  -> "[" i:IDENT "]"             { Some (fst i), 3 }
}

nonterm(string list * int) ASMClobber {
  -> empty                         { [], 0 }
  -> ":" lst:ASMCloberLstNE        { fst lst, snd lst + 1 }
}

nonterm(string list * int) ASMCloberLstNE {
  -> osc:OneStringConstant                           { [fst osc], snd osc }
  -> osc:OneStringConstant "," lst:ASMCloberLstNE     { fst osc :: fst lst, snd osc + snd lst + 1 }
}
