(* Main for the predicate project. Process command line and
 * does the appropriate workflow in terms of calling different
 * functions from elsewhere. As, you know, main usually does. *)

open List
open Globals (* global and utility functions *)
open File_process (* file input/output *)
open Predicate (* predicate table maniuplation and predicate ranking *)
open Prune (* pruning/filtering functions *)


(* We can prune the predicates and counters emitted by the sampler in several
 * ways. These heuristics are set by the -filter flag. The -filter flag
 * is one integer; you give it the sum of all the filters you want.
 * 
 * filter bits:
 * 1 - elimination by universal falsehood
 * 2 - elimination by lack of failing coverage
 * 4- elimination by lack of failing example
 * 8 - elimination when increase <= 0
 * 16 - only emit predicates that are sometimes > 0 on successful runs
 *      and always 0 on failing runs
 * 32 - only emit predicates that are always > 0 on all runs
 * 64 - emit predicates that are always 0 on successful runs and 
 *      sometimes > 0 on failing runs
 * 
 *)
   
let main () = begin
  let runs_in = ref "" in

  let hashes_in = ref "" in 
  let concise_runs_in = ref [] in
  let cbi_hash_tables = ref "" in
    
  let filters = ref 0 in
  let modify_input = ref false in

  let usageMsg = "Process samples produced by Liblit's CBI sampler.\n" in
  let argDescr = [
    "-cbi-hin", Arg.Set_string cbi_hash_tables, 
    "\t File containing serialized hash tables from my implementation \\
                of CBI." ;
    "-rs", Arg.Set_string runs_in,
            "\t File listing names of files containing runs, followed by a GOOD \\
                or BAD on the same line to delineate runs. Files are output of  \\
                resolvedSamples output by default. See \"ss\"." ;
    "-cout", Arg.Set_string concise_runs_out, 
            "\t File to print out concise run info.";
    "-hout", Arg.Set_string hashes_out, 
             "\t File to serialize the hash tables.";
    "-cin", Arg.String (fun s -> concise_runs_in := s:: !concise_runs_in),
            "\t File to read in concise good run info. \\
	    Requires -hin flag to be set.";
    "-hin", Arg.Set_string hashes_in, 
            "\t File to read serialized hash tables from. \\
	     Required if reading in concise run info.";
    "-filter", Arg.Set_int filters, 
            "\t Integer denoting which filtering schemes to apply.";
    "-mi", Arg.Set modify_input, 
            "\t Output formatted to be read into modify.";
    "-debug", Arg.Set debug, "\t Debug printouts.";
  ] 
  in
  let process = ref [] in
  let handleArg a = process := !process @ [a] in
    Arg.parse argDescr handleArg usageMsg ; 
    if not (!hashes_in = "") then begin
      let in_channel = open_in_bin !hashes_in in
	run_num_to_fname_and_good := Marshal.from_channel in_channel;
	close_in in_channel
    end ;

    if not (!cbi_hash_tables == "") then begin
      Printf.printf "cbi hash tables\n"; flush stdout;
      let in_channel = open_in !cbi_hash_tables in
      let (p_ht, s_ht, p2s_ht) = Marshal.from_channel in_channel in
	pred_to_site_ht := p2s_ht;
	site_ht := s_ht;
	pred_ht := p_ht
    end;
    if not (!runs_in = "") then begin
      Printf.printf "runs: %s\n" !runs_in; flush stdout;
      let file_list = ref [] in
      let fin = open_in !runs_in in 
	try
	  while true do
	    let line = input_line fin in
	    let split = Str.split whitespace_regexp line in
	      file_list := ((hd split), (hd (tl split))) :: !file_list
	  done
	with _ -> close_in fin;
	List.iter (fun (file, gorb) -> conciseify file gorb) !file_list;

	(* print concise runs to concise_run_out *) 
	let out_runs_file = open_out !concise_runs_out in
	  List.iter 
	    (fun (file, _) -> print_run out_runs_file file) 
	    !file_list;
	  close_out out_runs_file;

	  (* serialize out the hashtables so we can interpret the printed data 
	   * again later *)
	  let fout = open_out_bin !hashes_out in
	    Marshal.to_channel fout (!run_num_to_fname_and_good) [];
	    close_out fout;
	    print "post hashtable print\n";
    end;        
    (* we read in any concise output generated by print_run; this is
     * less efficient then just serializing the hashtable containing
     * runs to a file, but allows for human-readable output, which
     * for now is a win *)

    if (not (empty !concise_runs_in)) then
      List.iter (fun file -> read_run file) !concise_runs_in;

    (* OK. Now, under all circumstances, we have all of our runs into the 3 
     * hash tables. Now, process predicates *)

    Hashtbl.iter
      (fun run ->
	 (fun inner_tbl ->
	   (Hashtbl.iter
	      (fun pred ->
		(fun res_list ->
		   Printf.printf "Run %d, pred %d, result: " run pred;
		   (List.iter (fun res -> Printf.printf "%d:" res) res_list);
		   Printf.printf "\n"; flush stdout)) inner_tbl))) !run_and_pred_to_res;
    let pred_tbl = make_pred_tbl () in
    let filter_bit_set bit = (!filters land bit) == bit in

    let pred_pruned = 
      if (filter_bit_set 2) then begin
	Printf.printf "Pruning?\n"; flush stdout;
        prune_on_full_set pred_tbl filter_bit_set 
      end
      else pred_tbl in
    let exploded_tbl = explode_preds pred_pruned in 
    let counter_pruned = prune_on_individual_counters exploded_tbl filter_bit_set in
    let increase_pruned = if (filter_bit_set 8) then 
                           prune_on_increase counter_pruned 
                          else counter_pruned 
    in
    let ranked_preds = rank_preds increase_pruned in
      Printf.printf "%d ranked preds\n" (List.length ranked_preds); flush stdout;
      if not !modify_input then begin
      Printf.printf "Predicate,file name,lineno,cfg_node,F(P),S(P),Failure(P),Context,Increase,F(P Observed),S(P Observed),numF,Importance\n";
      end;
      List.iter (fun ((pred_num, pred_counter), 
		      importance, increase, context,
		      fP, sP, failureP, fObserved, sObserved, numF) ->
		   let (name, filename, lineno, rest) = get_pred_text pred_num pred_counter in 
		   Printf.printf "%s,%s,%s,%s,%g,%g,%g,%g,%g,%g,%g,%g,%g\n" 
		     name filename lineno rest fP sP failureP context increase fObserved sObserved numF importance;
		     flush stdout)
	ranked_preds;
      print "After rank preds\n"
end ;;

main () ;;
