(* Main for the predicate project. Process command line and
 * does the appropriate workflow in terms of calling different
 * functions from elsewhere. As, you know, main usually does. *)

open List
open Globals (* global and utility functions *)
open File_process (* file input/output *)
open Predicate (* predicate table maniuplation and predicate ranking *)
open Prune (* pruning/filtering functions *)


(* We can prune the predicates and counters emitted by the sampler in several
 * ways. These heuristics are set by the -filter flag. The -filter flag
 * is one integer; you give it the sum of all the filters you want.
 * 
 * filter bits:
 * 1 - elimination by universal falsehood
 * 2 - elimination by lack of failing coverage
 * 4- elimination by lack of failing example
 * 8 - elimination when increase <= 0
 * 16 - only emit predicates that are sometimes > 0 on successful runs
 *      and always 0 on failing runs
 * 32 - only emit predicates that are always > 0 on all runs
 * 64 - emit predicates that are always 0 on successful runs and 
 *      sometimes > 0 on failing runs
 * 
 *)
   
let main () = begin
  let resolved_runs_in = ref "" in

  let hashes_in = ref "" in 
  let concise_runs_in = ref [] in
    
  let filters = ref 0 in
  let skip_simplify = ref false in
  let modify_input = ref false in

  let usageMsg = "Process samples produced by Liblit's CBI sampler.\n" in
  let prefix = ref "" in
  let argDescr = [
    "-rs", Arg.Set_string resolved_runs_in,
            "\t File listing names of files containing runs, followed by a GOOD \\
                or BAD on the same line to delineate runs. Files are output of  \\
                resolvedSamples output by default. See \"ss\"." ;
    "-ss", Arg.Set skip_simplify, 
           "\t Skip simplification. Input is comma-delimited and first column \\
	   (source .sites file) is removed,";

    "-cout", Arg.Set_string concise_runs_out, 
            "\t File to print out concise run info.";
    "-hout", Arg.Set_string hashes_out, 
             "\t File to serialize the hash tables.";
    "-cin", Arg.String (fun s -> concise_runs_in := s:: !concise_runs_in),
            "\t File to read in concise good run info. \\
	    Requires -hin flag to be set.";
	     
    "-hin", Arg.Set_string hashes_in, 
            "\t File to read serialized hash tables from. \\
	     Required if reading in concise run info.";

    "-cut", Arg.Set_string prefix, 
            "\t prefix of project filenames to eliminate in conciseification.";
    "-filter", Arg.Set_int filters, 
            "\t Integer denoting which filtering schemes to apply.";
    "-mi", Arg.Set modify_input, 
            "\t Output formatted to be read into modify.";
    "-debug", Arg.Set debug, "\t Debug printouts.";
  ] 
  in
  let process = ref [] in
  let handleArg a = process := !process @ [a] in
    Arg.parse argDescr handleArg usageMsg ; 
    if not (!hashes_in = "") then begin
      let in_channel = open_in_bin !hashes_in in
	num_to_pred := Marshal.from_channel in_channel;
	run_num_to_fname_and_good := Marshal.from_channel in_channel;
	close_in in_channel
    end ;

    if (not (!resolved_runs_in = "")) then begin
      print "simplify block\n";
      let file_list = ref [] in
      let fin = open_in !resolved_runs_in in
	(try
	  while true do
	    let line = input_line fin in
	    let split = Str.split whitespace_regexp line in
	      file_list := ((hd split), (hd (tl split))) :: !file_list
	  done;
	with _ -> ());
      if not !skip_simplify then begin
	print "Not skipping simplify\n";
	let temp_list = List.map (fun (file, gorb) -> 
				    let file' = simplify file !prefix in
				      (file', gorb)
				 ) !file_list
	in
	  file_list := temp_list;
	  print "end simplify block\n";
      end;
      List.iter (fun (file, gorb) -> conciseify file gorb) !file_list;
      (* print concise runs to concise_run_out *) 
      let out_runs_file = open_out !concise_runs_out
      in
	List.iter 
	  (fun (file, _) -> print_run out_runs_file file) 
	  !file_list;
	close_out out_runs_file;
	print "post run print\n";
	(* serialize out the hashtables so we can interpret the printed data 
	 * again later *)
	let fout = open_out_bin !hashes_out in
	  Marshal.to_channel fout (!num_to_pred) [];
	  Marshal.to_channel fout (!run_num_to_fname_and_good) [];
	  close_out fout;
	  print "post hashtable print\n";
    end;
    
    (* we read in any concise output generated by print_run; this is
     * less efficient then just serializing the hashtable containing
     * runs to a file, but allows for human-readable output, which
     * for now is a win *)

    if (not (empty !concise_runs_in)) then begin
      List.iter (fun file -> read_run file) !concise_runs_in
    end;
    
    (* OK. Now, under all circumstances, we have all of our runs into the 3 
     * hash tables. Now, process predicates *)

    let pred_tbl = make_pred_tbl () in
    let filter_bit_set bit = (!filters land bit) == bit in

    let pred_pruned = if (filter_bit_set 2) then 
                            prune_on_full_set pred_tbl filter_bit_set 
                         else pred_tbl
    in
    let exploded_tbl = explode_preds pred_pruned in 
    let counter_pruned = prune_on_individual_counters exploded_tbl filter_bit_set in
    let increase_pruned = if (filter_bit_set 8) then 
                           prune_on_increase counter_pruned 
                          else counter_pruned 
    in
    let ranked_preds = rank_preds increase_pruned in
      if not !modify_input then begin
      Printf.printf "Predicate,file name,lineno,cfg_node,F(P),S(P),Failure(P),Context,Increase,F(P Observed),S(P Observed),numF,Importance\n";
      end;
      List.iter (fun ((pred_num, pred_counter), 
		      importance, increase, context,
		      fP, sP, failureP, fObserved, sObserved, numF) ->
		   let (name, filename, lineno, rest) = get_pred_text pred_num pred_counter in 
		   Printf.printf "%s,%s,%s,%s,%g,%g,%g,%g,%g,%g,%g,%g,%g\n" 
		     name filename lineno rest fP sP failureP context increase fObserved sObserved numF importance;
		     flush stdout)
	ranked_preds;
      print "After rank preds\n"


end ;;

main () ;;
